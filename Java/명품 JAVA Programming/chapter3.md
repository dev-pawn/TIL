# Chapter 3 반복문과 배열 그리고 예외 처리



## 목차

- 반복문
- continue 문과 break 문
- 배열
- 다차원 배열
- 메소드에서 배열 리턴
- main() 메소드
- 자바의 예외 처리



## 반복문

자바는 반복 연산을 수행할 수 있도록 다음 3가지 종류의 반복문을 제공한다.

```
for, while, do-while
```

for문은 처음부터 반복 횟수를 알 수 있는 경우에, while문과 do-while 문은 반복 횟수를 알 수 없고 조건에 따라 반복이 계속 되거나 중단되는 경우에 이용한다.  
while문은 반복 조건을 처음부터 따지는 경우에, do-while 문은 반복 조건을 나중에 따지는 경우에 적합하다.



> for 문

![](./img/chapter3/ex1.jpg)

- 초기문

  초기문은 주로 조건식에서 사용하는 변수를 초기화한다.

  - 초기문은 시작할 때 한 번만 수행된다.
  - 콤마(,)로 분리하여 여러 문장을 나열할 수 있다.
  - 초기문은 빈 상태로 두어도 되지만 끝에 세미콜론(;)은 있어야 한다.



- 조건식

  조건식에는 논리형 변수나 논리 연산을 사용한다. 조건식의 결과가 true이면 반복이 계속되고 false이면 for 문을 벗어난다.  
  조건식은 for 문의 작업 문장을 수행하기 전에 검사되므로 조건식이 처음부터 false이면 바로 반복문을 벗어난다.

  ```java
  for(i=0; i<10; i++) {		// i가 0~9까지 10번 반복
  	System.out.print(i);
  }
  ```

  다음과 같이 조건식에 true가 있거나 비어 있으면 무한 반복(infinity loop) 된다.

  ```java
  for(초기문; true; 반복 후 작업) {		// 무한 반복
  	.......
  }
  for(초기문; ; 반복 후 작업) {			// 조건식이 비어 있으면 무한 반복
  	.......
  }
  ```



- 반복 후 작업

  for 문의 작업문이 실행된 후 '반복 후 작업문'이 실행된다.

  ``` java
  for(i=0; i<10; i+=2) {		// i가 0,2,4,6,8로 변하면서 5번 반복
    ........
  }
  ```

  반복 후 작업문'에는 콤마(,)로 분리하여 여러 문장을 나열할 수 있다.  
  예를 들면 다음과 같다. 이 코드는 i 값을 증가시키고 증가된 i 값을 화면에 출력한다.

  ```java
  for(i=0; i<10; i++, System.out.println(i)) {
  	........
  }
  ```

  

- 작업문

  작업문은 for 문이 반복되는 동안 반복 실행된다. 작업문이 하나의 문장일 경우 중괄호({})가 필요 없지만 여러 개의 문장으로 구성되는 경우 반드시 중괄호로 묶어야 한다.



> for 문 활용

- 반복문에 변수 선언

  다음과 같이 변수 i를 for 문 블록 내에서만 사용되는 지역 변수로 선언하여 사용할 수 있다.  
  이 때 변수 i는 for 문 밖에서는 사용할 수 없다.

  ```java
  for (int i=0; i<10; i++) // 변수 i는 for 문 밖에서 사용 불가
  	System.out.print(i);
  ```



- 1에서 100까지의 합 구하기

  ```java
  int sum = 0;
  for(int i=1; i<=100; i++)		// 1에서 100까지 반복
  	sum += i;
  
  int sum = 0;
  for(int i=100; i>=1; i--)		// 100에서 1까지 반복
    sum += i;
  
  int i, sum;
  for(i=1, sum=0; i<=100; i++)	// sum 변수를 0으로 초기화
    sum += i;
  ```



> while 문

![](./img/chapter3/ex2.jpg)

while 문은 반복 횟수를 알 수 없는 경우에 적합하다. while문의 조건식은 for 문의 경우와 동일하며, true인 동안 작업문의 실행을 반복하고, false가 되면 while 문을 벗어난다.  
for 문과 달리, while문에 조건식이 없으면 컴파일 오류가 발생한다.  
while 문을 사용하는 경우, 조건식에 사용되는 변수를 while 문 실행 전에 초기화하는 것을 잊지 말아야 한다. 그리고 반복이 진행되면서 조건식이  false가 되어 반복문을 빠져 나올 수 있도록 설계되어야 한다. 그렇지 않으면 무한 반복에 빠지게 된다.



> do-while문

![](./img/chapter3/ex3.jpg)

do-while 문의 조건식은 while 문과 동일하며 조건식이 없으면 컴파일 오류가 발생한다. 다른 반복문과는 달리,  do-while 문은 작업문 실행 후 조건식을 검사하므로 작업문이 최초 한 번은 반드시 실행된다.



> 중첩 반복

반복문 안에 다른 반복문을 만들 수 있다. 이것을 중첩 반복(nested loop)이라 한다.  
반복은 몇 번이고 중첩 가능하지만, 너무 깊은 중첩 반복은 프로그램 구조를 복잡하게 하므로 2중 또는 3중 중첩 이상하지 않는 것이 바람직하다.



## continue 문과  break 문

반복문 내에 continue 문이나 break 문을 이용하면 반복의 흐름을 바꾸거나 반복에서 벗어나게 할 수 있다.  
break 문은 현재 반복문을 벗어나게 하며, continue 문은 즉시 다음 반복으로 넘어간다.



> continue 문

continue 문은 반복문을 빠져나가지 않으면서 즉시 다음 반복으로 넘어가고자할 때 사용된다.

```java
continue;
```

아래 그림은 각 반복문에서 continue 문에 의해 실행 경로가 변경되는 것을 보여준다.

![](./img/chapter3/ex4.jpg)



> break 문

break 문은 하나의 반복문을 즉시 벗어날 때 사용하며 다음과 같이 사용한다.

```java
break;
```

중첩 반복의 경우 안쪽 반복문에서 break 문이 실행되면, 안쪽 반복문만 벗어나며 바깥 쪽 반복문 내에서 실행이 유지된다.



## 배열

> 배열이란?

배열(array)은 인덱스(index)와 인덱스에 대응하는 데이터들로 이루어진 연속적인 자료 구조로서, 같은 종류의 데이터들이 순차적으로 저장된다.  
아래 그림은 10개의 정수 값을 저장하고 합할 때, 10개의 변수를 사용한 경우와 자바의 배열을 사용한 경우를 대조하여 보여준다.

![](./img/chapter3/ex5.jpg)

배열을 사용하는 큰 이유 중 하나는 반복문의 활용에 있다. 배열을 사용하면 다음과 같이 for 문으로 10개의 정수 합을 간단히 구할 수 있다.

```java
for(sum=0, n=0; n<10; n++)
	sum += i[n];
```



> 배열 선언 및 생성

자바에서 배열의 생성은 C/C++와 달리 다음 두 단계로 이루어진다.

- 배열에 대한 레퍼런스 변수 선언
- 배열 생성 - 배열의 저장 공간 할당

아래 그림은 5개의 정수 값을 저장하는 배열을 만드는 코드로, 배열에 대한 레퍼런스 변수를 선언하는 단계와, 데이터를 저장할 배열 공간을 할당받는 단계로 구분된다.

![](./img/chapter3/ex6.jpg)

- 배열에 대한 레퍼런스 변수 선언

  다음은 배열 선언문으로 레퍼런스 변수 intArray를 선언한다.

  ```java
  int intArray[];
  ```

  이 선언만으로 배열 공간이 할당되지 않으며, 위 그림과 같이 레퍼런스 변수 intArray만 생성된다.  
  intArray는 배열 공간에 대한 주소 값(레퍼런스 값)을 가지며 그 자체가 배열은 아니다. 아직 정수를 저장할 배열 공간이 생성되지 않았으므로 intArray 값은 null이다.  
  자바에서는 배열의 주소를 레퍼런스라고 부르며, 배열에 대한 주소 값을 가지는 변수를 레퍼런스 변수라고 부른다.  
  배열의 타입은 배열을 구성하는 원소의 타입이며, 배열의 레퍼런스 변수는 다음 두 가지 방법으로 선언할 수 있다.

  ```java
  int intArray[];
  int [] intArray;
  ```

- 배열 선언 시 []에 크기를 지정하면 안 됨

  배열 선언 시 [] 안에 배열의 크기를 지정해서는 안 된다. 다음 문장은 컴파일 오류이다.

  ```java
  int intArray[10];		// 컴파일 오류. 배열의 크기를 지정할 수 없음
  ```

- 배열 생성

  배열 생성은 데이터를 저장할 배열 공간을 할당받는 과정이다. 반드시 new 연산자를 이용하여 배열을 생성하며 [] 안에 생성할 원소 개수를 지정한다.  
  다음 코드는 정수 5개의 배열 공간을 할당받고 이 배열에 대한 레퍼런스 값(주소 값)을  intArray에 저장한다.

  ```java
  intArray = new int[5];
  ```

- 배열의 선언과 동시에 생성

  다음과 같이 배열의 선언과 생성을 동시에 할 수 있다.

  ```java
  int intArray[] = new int[5];
  ```

- 배열 초기화

  배열 선언문에서 {}에 원소를 나열하면 초기화 된 배열을 만들 수 있다.  
  배열을 초기화하는 예를 들면 다음과 같으며 실행 결과는 아래 그림과 같은 배열이 생긴다.

  ```java
  int intArray[] = {4, 3, 2, 1, 0};
  double doubleArray[] = {0.01, 0.02, 0.03, 0.04};
  ```

  IntArray 배열의 크기는 자동으로 5가 되며, doubleArray 배열의 크기는 자동으로 4가 된다. 생성되는 배열의 원소 개수는 {}에 나열된 값의 개수로 정해지므로 []에 크기를 주어선 안 된다.

  ![](./img/chapter3/ex7.jpg)

  

> 배열 인덱스와 배열 원소 접근

배열의 인덱스는 정수만 가능하다. 인덱스는 0부터 시작하며 마지막 원소의 인덱스는 (배열 크기 -1)이다.  
배열의 원소를 접근하려면 반드시 배열이 생성(공간 할당)되어 있어야 한다. 배열이 생성되어 있지 않는 상태에서 배열을 사용하면 배열이 초기화가 되지 않았따는 컴파일 오류가 발생하거나, 실행시간 오류가 발생한다.



> 레퍼런스 치환과 배열 공유

자바에서는 레퍼런스 변수와 배열 공간이 분리되어 있기 때문에, 다수의 레퍼런스 변수가 하나의 배열 공간을 가리키는 배열 공유가 쉽게 이루어진다.  
다음 코드와 함께 아래 그림을 보면서 배열이 공유되는 것을 알아보자.

```java
int intArray[] = new int[5];
int myArray[] = intArray;		// 레퍼런스 치환. myArray는 intArray와 동일한 배열 참조
```

앞의 코드에서 두 번째 라인은 레퍼런스 변수 myArray를 생성하고 intArray 변수의 값을 myArray에 치환하는 코드이다.  
이 치환으로 intArray 배열이 복사되는 것이 아니라, 레퍼런스 즉 배열에 대한 주소만 복사된다.  
그 결과 myArray는 intArray와 동일한 레퍼런스 값을 가지게 되어  myArray는  intArray의 배열을 공유하게 되고, myArray로  intArray의 배열 원소를 마음대로 접근할 수 있다.

아래 그림의 윗부분은 intArray가 참조하는 배열을 myArray도 참조하고 있음을 보여준다. intArray와 myArray가 같은 배열을 참조하고 있기 때문에, 그림의 아랫부분의 myArray[1]=6;에 의해 먼저 기록된 값 2가 6으로 변경되는 것을 보여준다.

![](./img/chapter3/ex8.jpg)

- 배열의 크기, length 필드

  자바는 배열을 객체로 다룬다. 배열이 생성되면 아래 그림과 같이 객체가 생성된다. 이 객체에는 배열의 저장 공간과 함께 배열의 크기 값을 가진 length 필드가 존재한다.

  ![](./img/chapter3/ex9.jpg)

  length 필드를 이용하면 배열의 크기를 다음과 같이 간단히 알아낼 수 있다.

  ```java
  int intArray [] = new int[5];
  int size = intArray.length;		// size는 5
  ```

  배열 객체에  length 필드가 있기 때문에, 프로그램에서 배열의 크기를 따로 관리할 필요가 없다. 배열의 크기만큼 반복할 때  length 필드는 매우 유용하다. 다음은 intArray 배열의 모든 값을 출력하는 코드이다.

  ```java
  for(int i=0; i<intArray.length; i++)		// intArray 배열 크기(5)만큼 반복한다.
  	System.out.println(intArray[i]);
  ```

- 배열의 for-each 문

  기존의  for 문을 변형하여, 배열이나 나열(enumeration)의 크기만큼 루프를 돌면서 각 원소를 순차적으로 접근하는데 유용하게 만든 for 문을 for-each 문(오라클에서는  advanced for라고 부름)이라고 부르며, 구조는 아래 그림과 같다.

  ![](./img/chapter3/ex10.jpg)

  배열  n에 들어 있는 모든 정수를 더하는 코드를  for-each 문으로 작성하면 다음과 같다.

  ```java
  int [] n = { 1,2,3,4,5 };
  int sum = 0;
  for (int k : n) { // n.length번 반복. k는 n[0], ..., n[4]로 번갈아 반복
  	sum += k;
  }
  System.out.println("합은" + sum);
  ```

  앞의 for-each 문은  k=n[0], n[1], n[2], n[3], n[4] 값으로 바꾸면서, 배열  n의 크기만큼 반복한다. 그러므로 sum의 결과는  15가 된다.  
  또 다른 예를 들어보자. 문자열 배열에 있는 모든 문자열을 for-each 문으로 출력하는 코드와 실행 결과는 다음과 같다.

  ```java
  String name[] = { "사과", "배", "바나나", "체리", "딸기", "포도"} ;
  for (String s : names) { // 반복할 때마다 s는 names[0], ..., names[5]로 설정
  	System.out.print(s + " ";)
  }
  ```

  배열뿐만 아니라 나열 타입(enum)에 대해서도 다음과 같이 for-each 문이 사용된다.

  ```java
  enum week = {월, 화, 수, 목, 금, 토, 일}
  for (Week day : Week.values()) // 반복될 때마다 day는 월, 화, 수, 목, 금, 토, 일로 설정
  	System.out.print(day + "요일");
  ```

  앞의 코드는 enum 타입 Week를 선언한다. Week 타입은 월, 화, 수, 목, 금, 토, 일의 7개의 값 중 하나만 가지도록 선언되었기 때문에,  Week 타입의 객체 day는 이 7개의 값외 다른 값을 가질 수 없다.



## 다차원 배열

자바의 다차원 배열은 C/C++와 달리 독특한 구조를 가지기 때문에 주의하여 학습하기 바란다.



> 2차원 배열

- 2차원 배열의 선언과 생성

  1차원 배열과 마찬가지로 2차원 배열에서도 레퍼런스 변수 선언 후 배열을 생성한다.  
  2차원 배열의 레퍼런스 변수를 선언하는 방법은 다음 두 가지가 있다.

  ```java
  int intArray [][];
  char charArray [][];
  double doubleArray [][];
  ```

  또는

  ```java
  int [][] intArray;
  char [][] charArray;
  double [][] doubleArray;
  ```

  이제, 2차원 배열의 저장 공간은 다음과 같이  new 연산자를 이용하여 생성하며, 첫 번째 []는 행의 개수를, 두 번째 []는 열의 개수를 나타낸다.

  ```java
  intArray = new int [2][5];					// 2행 5열의 2차원 배열 생성
  charArray = new char [5][5];				// 5행 5열의 2차원 배열 생성
  doubleArray = new double [5][2];		// 5행 2열의 2차원 배열 생성
  ```

  아래 그림은 new int ``[2][5]``에 의해 생성된  2 * 5의 2차원 배열 구조를 보여준다. 2차원 배열에서는 행의 각 원소는 1차원 배열에 대한 레퍼런스가 된다.

  ![](./img/chapter3/ex11.jpg)

  위 그림에서 2차원 배열의 length 의미를 살펴보면 다음과 같다.

  - i.length       ->  2차원 배열의 행의 개수, 2
  - i[0].length   ->  0번째 행에 있는 열의 개수, 5
  - i[1].length   ->  1번째 행에 있는 열의 개수, 5

  2차원 배열도 다음과 같이 레퍼런스 변수 선언과 배열 생성을 동시에 할 수 있다.

  ```java
  int intArray [][] = new int [2][5];
  char charArray [][] = new char [5][5];
  double doubleArray [][] = new double [5][2];
  ```

- 2차원 배열의 초기화

  다음과 같이 2차원 배열을 선언할 때 각 원소를 초기화할 수 있다. 그러면 자동으로 원소 개수만한 배열 공간이 할당되고, 원소 값으로 초기화된다.

  ```java
  int intArray [][] = { {0,1,2}, {3,4,5,}, {6,7,8}};				// 3x3 배열 생성
  char charArray [][] = { {'a', 'b', 'c'}, {'d', 'e', 'f'}};		// 2x3 배열 생성
  double doubleArray [][] = {{0.01, 0.02}, {0.03, 0.04}};				// 2x2 배열 생성
  ```



> 비정방형 배열

지금까지 공부한 배열은 모두 정방형 배열이다. 정방형 배열은 각 행의 열 개수가 모두 동일한 배열을 말하며,  
비정방형 배열은 행마다 열의 개수가 서로 다른 배열을 말한다.  
아래 그림은 모든 행의 열의 개수가 동일한 4 x 4의 정방형 배열을 보여주며,

![](./img/chapter3/ex12.jpg)

아래 그림은 행마다 열의 개수가 다른 비정방형 배열을 보여준다.

![](./img/chapter3/ex13.jpg)

비정방형 배열은 다음 코드로 작성한다. 위 그림은 이 과정을 보여준다.

```java
int i [][];			// 2차원 배열의 레퍼런스 변수 i 선언
i = new int[4][];		// 각 행을 가리키는 레퍼런스 배열 생성
i[0] = new int [1];		// 첫째 행에 1개 크기의 배열 생성
i[1] = new int [2];		// 둘째 행에 2개 크기의 배열 생성
i[2] = new int [3];		// 셋째 행에 3개 크기의 배열 생성
i[3] = new int [4];		// 넷째 행에 4개 크기의 배열 생성
```

여기서  length 필드의 의미를 살펴보자.

- i.length	->	2차원 배열의 행의 개수, 4
- i[0].length    ->        0번째 행의 열의 개수, 1
- i[1].length    ->        1번째 행의 열의 개수, 2
- i[2].length     ->        2번째 행의 열의 개수, 3
- I[3].length     ->        3번째 행의 열의 개수, 4

어떤 메소드가 배열을 매개변수로 받을 때, 배열이 정방형인지 비정방형인지는 표시되지 않기 때문에 항상  length 필드를 사용하여 각 행의 열의 개수를 파악하여야 한다.  
배열 생성 시에 초기화를 통해 비정방형 배열을 생성할 수도 있다. 다음 코드는 위 그림의 비정방형 배열을 생성하고 순서대로 각 원소에 정수 0, 1, 2, ..., 9값을 저장하는 코드이다.

```java
int intArray[][] = { {0}, {1,2}, {3,4.5}, {6,7,8,9} };
```



## 메소드에서 배열 리턴

메스드가 배열을 리턴하는 경우에 대해 알아보자.  
메소드에서 어떤 배열이든지 리턴하면, 배열 공간 전체가 아니라 배열에 대한 레퍼런스만 리턴된다.  
아래 그림은 int[] 배열을 리턴하는  makArray() 메소드 코드이다.

![](./img/chapter3/ex14.jpg)

메소드는 레퍼런스만 리턴하기 때문에, 리턴 타입을 선언할 때 [] 안에 배열의 크기를 지정하지 않는다. 또한 리턴하는 배열의 타입이 리턴받는 레퍼런스 변수의 타입과 일치해야 한다.  
makeArray() 메소드로부터 배열을 리턴받는 코드를 작성해보자.

```java
int [] intArray;		// makeArray()의 리턴 타입과 동일한 타입 선언
intArray = makeArray();		// makeArray() 메소드가 리턴하는 배열 받음
```

이 코드의 실행 결과는 아래 그림과 같으며, intArray는  makeArray()가 만들어 리턴한 배열을 가리키게 되어, 다음과 같이 intArray로 배열 원소에 접근 가능하다.

```java
intArray[0] = 5;			intArray[1] = 6;			intArray[2] = 7;			intArray[3] = 8;
```

![](./img/chapter3/ex15.jpg)

2차원 배열을 리턴하는 메소드와 배열을 리턴받는 코드는 다음과 같이 작성할 수 있다. 메소드의 리턴 타입에 주목하기 바란다.

```java
int [][] make2DArray() {
  return new int [3][4];		// 2차원 배열 생성 및 리턴
}
int [][] int2Array = make2DArray();		// 2차원 배열 리턴 받기(레퍼런스만)
```



## main() 메소드

