# 트랜잭션 개요

데이터베이스 시스템 환경에서 흔히 볼 수 있는 몇 가지 응용의 예를 살펴보자.

```sql
예 1: 전체 사원의 급여를 6% 인상

사원이 500명 재직하고 있는 회사에서 모든 사원의 급여를 6% 인상하는 연산을 데이터베이스의 EMPLOYEE 릴레이션에서 수행한다.

UPDATE		EMPLOYEE
SET			SALARY = SALARY * 1.06;
```

이때 500명 전원의 급여가 수정되거나 한 명의 급여도 갱신되지 않도록 DBMS가 보장해야 한다.  
예를 들어, 아래 그림과 같이 320번째 사원까지 수정한 상태에서 컴퓨터 시스템이 다운된 후에 재기동되었을 때 DBMS는 어떻게 대응해야 하는가?  
위의 수정 연산을 처음부터 다시 수행한다면 320번째까지의 직원의 급여는 두 번 인상되고 321번째 직원부터는 정상적으로 한 번만 인상되는 결과를 가져오므로 이렇게 해서는 안 된다.

DBMS는 항상 현재의 데이터베이스 상태만 유지하므로 각 투플이 수정된 시점을 알 수 없다.  
따라서 DBMS가 추가로 정보를 유지하지 않는다면 DBMS가 재기동된 후에 어느 직원의 투플까지 수정되었는가를 알 수 없다.  
이를 위해 DBMS가 유지하는 __로그(log)__ 에 관해서는 뒤에서 자세하게 논의한다.

![](./image/9-1/ex1.jpg)

```sql
예 2 : 계좌 이체

은행 고객은 자신의 계좌에서 다른 계좌로 송금할 수 있따. 정미림은 자신의 계좌에서 100,000원을 인출하여 안명석의 계좌로 이체하려고 한다.
고객들의 계좌 정보가 ACCOUNT 릴레이션에 들어 있다.

UPDATE		ACCOUNT
SET			BALANCE = BALANCE - 100000
WHERE		CUST_NAME = '정미림';

UPDATE		ACCOUNT
SET			BALANCE = BALANCE + 100000
WHERE		CUST_NAME = '안명석';
```

ACCOUNT 릴레이션에서 정미림의 투플과 안명석의 투플은 서로 상이하므로 하나의 UPDATE문으로 계좌 이체를 표현할 수 없다. 즉 WHERE절에서

CUST_NAME = '정미림' __AND__ CUST_NAME = '안명석'

과 같이 표현하면 이 조건을 만족하는 투플이 하나도 없으며, WHERE절에서

CUST_NAME = '정미림' __OR__ CUST_NAME = '안명석'

과 같이 표현하면 WHERE절을 만족하는 두 개의 투플에 대해 SET절에서 명시한 대로 잔액이 모두 100,000원 증가하거나 100,000원 감소한다.

따라서 위와 같이 두 개의 UPDATE문을 사용하여, 하나의 UPDATE문에서는 정미림의 잔액을 100,000원 감소시키고,  
또 다른 UPDATE문에서는 안명석의 잔액을 100,000원 증가시켜야 한다. 물론 두 UPDATE문의 순서는 중요하지 않다.  
컴퓨터 시스템은 언제든지 다운될 수 있다. 만약 첫 번째 UPDATE문을 수행한 후에 두 번째 UPDATE문을 수행하기 전에 컴퓨터 시스템이 다운되면 재기동한 후에 DBMS는 어떻게 대응해야 하는가?  
위의 두 UPDATE문을 처음부터 다시 수행한다면 정미림의 계좌에서는 100,000원이 두 번 빠져나가게 되므로 총 200,000원이 인출되고,  
안명석의 계좌에는 100,000원만 증가하므로 정미림의 입장에서는 100,000원을 손해보는 것이다.  
만일 DBMS가 아무런 작업을 하지 않는다면 정미림의 계좌에서는 100,000원이 빠져나갔지만 안명석의 계좌에는 100,000원이 증가되지 않았기 때문에 이 또한 안 된다.

위의 두 개의 UPDATE문은 둘 다 완전하게 수행되거나 한 UPDATE문도 수행되어서는 안 되도록, 즉 하나의 __트랜잭션(단위)__처럼 DBMS가 보장해야 한다.  
DBMS는 사용자가 입력하는 SQL문들 중에서 어떤 것들을 하나의 트랜잭션으로 취급해야 하는지 알 수 없다.  
기본적으로 각각의 SQL문이 하나의 트랜잭션으로 취급된다. 따라서 두 개 이상의 SQL문들을 하나의 트랜잭션으로 취급하려면  
사용자가 이를 명시적으로 표시해야 한다. 또한 성공적인 계좌 이체 트랜잭션의 결과는 데이터베이스에 지속적으로 반영되어야 한다.

![](./image/9-1/exampleNumber3-1.jpg)

![](./image/9-1/exampleNumber3-2.jpg)



SQL문 (1)은 키보드로부터 입력받은 항공기편과 날짜를 WHERE절에 사용하여, 고객이 원하는 항공기편에 대해 현재까지 팔린 좌석 수와  
그 항공기의 총 좌석 수를 검색하여 고급 프로그래밍 언어의 변수 temp1과 temp2에 각각 배정한다.  
고급프로그래밍 언어의 if문에서 그 항공기에 빈 좌석이 남아 있는가를 검사하고, 빈 좌석이 남아 있지 않으면 예약을 할 수 없으므로  
"빈 좌석이 없습니다"는 메세지를 모니터에 보여주고 프로그램의 수행을 중단한다.  
이 경우에는 아직 데이터베이스를 갱신하지 않았으므로 데이터베이스의 일관성에 전혀 영향을 주지 않는다.

빈 좌석이 남아 있는 경우에는 SQL문 (2)와 같이 UPDATE문을 사용하여 그 항공기의 팔린 좌석 수를 1만큼 증가시키고,  
SQL문 (3)과 같이 INSERT문을 사용하여 고객의 인적 사항을 항공사의 데이터베이스에 입력한다.  
그리고 "예약이 완료되었습니다"는 메시지를 모니터에 보여주고 프로그램의 수행을 성공적으로 종료한다.

만일 SQL문 (2)를 수행하고 SQL문 (3)을 수행하기 전에 컴퓨터 시스템이 다운된다면 재기동한 후에 DBMS는 어떻게 대응해야 하는가?  
DBMS가 위의 트랜잭션을 처음부터 다시 수행한다면 팔린 좌석수는 또 1만큼 증가하여 총 2개의 좌석이 팔린 것으로 데이터베이스에 기록되지만  
한 명의 고객만 예약한 것이므로 이렇게 해서는 안된다.

DBMS가 아무런 후속 조치를 취하지 않는다면 팔린 좌석 수는 1만큼 증가했지만 고객의 정보가 입력되지 않았으므로 예약한 고객이 그 항공기에 탑승할 수 없다.  
따라서 항공사 입장에서는 좌석 1개에 고객을 태우지 못하게 되므로 수입이 줄어들고, 고객은 항공기를 타지 못하게 되므로 일정에 큰 차질이 생길 수 있으므로 이렇게 해서는 안된다.

위의 세 개의 SQL문이 모두 완전하게 수행되거나 하나도 수행되어서는 안되도록, 즉 하나의 트랜잭션(단위)처럼 DBMS가 취급해야 한다.  
계좌 이체 예에서 설명한 바와 같이 DBMS는 각 SQL문의 의미를 알 수 없으므로 하나의 트랜잭션으로 취급해야 하는 SQL문들의 범위를 사용자가 명시적으로 표시해야 한다.



## 트랜잭션의 특성

트랜잭션은 데이터베이스 시스템에서 매우 중요한 개념이다.  
트랜잭션은 아래와 같은 네 가지 특성을 만족해야 한다. 네 가지 특성을 나타내는 영어 단어들의 첫 글자를 모아서 __ACID__ 특성이라고도 한다.

- 원자성(__A__tomicity)

  원자성은 한 트랜잭션 내의 모든 연산들이 완전히 수행되거나 전혀 수행되지 않음(all or nothing)을 의미한다.  
  즉 한 트랜잭션의 모든 연산이 데이터베이스에 완전히 반영되거나 전혀 반영되지 않아야 한다.  
  시스템이 다운되는 경우에 DBMS의 회복 모듈은 부분적으로 데이터베이스를 갱신한 트랜잭션의 영향을 취소함으로써 트랜잭션의 원자성을 보장한다.  
  또한 완료된 트랜잭션이 갱신한 사항은 트랜잭션의 영향을 재수행함으로써 트랜잭션의 원자성을 보장한다.  

  ```sql
  예 1 : 계좌 이체
  정미림 계좌에서 안명석 계좌로 100,000원을 송금하는 경우에 정미림 계좌에서 100,000원이 빠지고 안명석 계좌에 100,000원이 증가하는 것이 모두 데이터베이스에 반영되거나,
  정미림 계좌에서도 100,000원이 빠지지 않고 안명석 계좌에도 100,000원이 증가되지 않도록 보장해야 한다.
  만일 정미림 계좌에서 100,000원이 빠져나간 직후에 시스템이 다운되면 어떻게 하겠는가?
  이런 경우에는 컴퓨터 시스템이 재기동된 후에 DBMS의 회복 모듈이 정미림 계좌에서 빠져나간 100,000원을 정미림 계좌에 다시 증가시킴으로써 트랜잭션이 수행되지 않은 상태로 되돌린다.
  안명석 계좌를 수정하기 전에 시스템이 다운되었으므로 안명석 계좌에는 변화가 없다.
  만일 두 번째 UPDATE문까지 수행한 후에 시스템이 다운되었다면, 컴퓨터 시스템이 재기동된후에 DBMS의 회복 모듈은 정미림 계좌에서 100,000원이 줄어들고,
  안명석 계좌에서 100,000원이 증가된 것이 데이터베이스에 반영하는 것을 보장한다.
  
  		UPDATE	ACCOUNT
  		SET		BALANCE = BALANCE - 100000
  		WHERE	CUST_NAME = '정미림';
  		-------------------------------------------------> 시스템 다운
  		UPDATE ACCOUNT
  		SET		BALANCE = BALANCE + 100000
  		WHERE	CUST_NAME = '안명석';
  ```

  ```
  예 2 : 
  ```

  

- 일관성(__C__onsistency)

- 고립성(__I__solation)

- 지속성(__D__urability)
