# 뷰



## 목차

- [뷰의 개요](#뷰의-개요)
- [뷰의 정의](#뷰의-정의)
- [뷰의 장점](#뷰의-장점)
- 뷰의 갱신



## 뷰의 개요

ANSI/SPARC 3단계 아키텍처에서 외부 뷰는 특정 사용자가 보는 데이터베이스의 구조라고 설명하였다.  
관계 데이터베이스에서 뷰라는 용어는 한 사용자의 전체 외부 뷰 대신에 하나의 __가상 릴레이션(virtual relation)__ 을 의미하는 데 사용된다.  
가상 릴레이션이란 실제로 투플을 갖지 않은 릴레이션이라는 뜻이다. 뷰는 기존의 __기본 릴레이션(base relation, 실제 릴레이션)__이나 또 다른 뷰에 대한 SELECT문의 형태로 정의된다.  
기본 릴레이션의 투플들은 데이터베이스에 물리적으로 저장된다. 관계 데이터베이스에서의 뷰는 자체적으로 디스크에 저장된 투플들을 갖고 있지 않지만  
사용자가 질의할 수 있는 릴레이션의 하나이다. 즉 한 사용자는 여러 개의 릴레이션과 뷰를 사용할 수 있다.

뷰는 기본 릴레이션이 나타날 수 있는 곳은 어디든지 사용될 수 있다.  
사용자에게 뷰는 기본 릴레이션과 같은 방법으로 조작할 수 있는 정상적인 릴레이션처럼 보인다.  
어떤 릴레이션으로부터 데이터를 검색하는 것과 동일한 방법으로 뷰를 통해서 데이터를 검색할 수 있다.  
뷰의 전체 내용을 검색하거나 특정 애트리뷰트와 투플들을 검색할 수 있다. 어떤 뷰에 대해서는 갱신 연산도 수행할 수 있다.  
뷰에 대한 어떤 연산도 뷰의 정의에 사용된 기본 릴레이션에 대한 연산으로 변환되어 수행된다.

뷰는 릴레이션으로부터 데이터를 검색하거나 갱신할 수 있는 __동적인 창(dynamic window)__ 의 역할을 한다.  
사용자는 이 창을 통해서 기본 릴레이션에 저장된 데이터를 볼 수 있다.  
기본 릴레이션의 투플들에 대한 갱신은 그 기본 릴레이션으로부터 유도된 뷰에 즉시 반영된다.  
뷰의 내용은 뷰를 참조하는 질의를 수행할 때마다 달라질 수 있다. 창문을 통해서 밖에 햇빛이 비치거나, 비가 오거나,  
눈이 오는 등 시시각각 변화하는 모습을 볼 수 있듯이 뷰를 통해서 기본 릴레이션의 현재 내용을 볼 수 있다.

이에 반해서 어느 시점에 SELECT문의 결과를 기본 릴레이션의 형태로 저장해놓은 것을 __스냅숏(snapshot)__이라고 부른다.  
일부 관계 DBMS들에서는 스냅숏을 구체화된 뷰(materialized view)라고 부른다.  
스냅숏은 사진을 찍은 것과 같아서 스냅숏을 정의하는 시점의 기본 릴레이션의 내용이 스냅숏에 반영된다.  
데이터베이스는 항상 현재의 상태만을 나타내므로 스냅숏을 정의한 이후에 기본 릴레이션이 갱신되면 이는 스냅숏에 반영되지 않으므로 주기적으로 내용을 __새롭게(refresh)__ 해야 한다.  
어떤 시점의 조직체의 현황, 예를 들어 몇년 몇월 시점에 근무하던 사원들의 정보, 재고 정보 등이 스냅숏으로 정의될 수 있다.

뷰를 사용하면 여러 사용자가 여러 방식으로 데이터를 볼 수 있다.  
데이터베이스가 공유 자원이므로 데이터베이스에 저장된 데이터에 관해 각 사용자에게 서로 다른 뷰를 제공하는 것이 유용하다.  
뷰는 하나의 기본 릴레이션을 사용자마다 서로 다르게 볼 수 있도록 한다.  
아래 그림에서 뷰1은 기본 릴레이션1 위에서 정의되었고, 뷰2는 기본 릴레이션2 위에서 정의되었으며, 뷰3은 기본 릴레이션2와 기본 릴레이션3을 사용하여 정의되었다.  
뷰는 또 다른 뷰를 참조할 수 있다. 아래 그림에서 뷰4는 뷰2와 기본 릴레이션3 위에서 정의되었다.

![](./image/8-1/ex1.jpg)



## 뷰의 정의

뷰를 정의하는 SQL문의 구문은 다음과 같다.

```sql
CREATE VIEW 뷰이름 [(애트리뷰트(들))]
AS SELECT문
[WITH CHECK OPTION];
```

CREATE VIEW 다음에 뷰의 이름을 지정한다. 뷰의 이름 다음에 애트리뷰트들을 생략하면  
뷰를 정의하는 데 사용된 SELECT문의 SELECT절에 열거된 애트리뷰트들의 이름과 동일한 애트리뷰트들이 뷰에 포함된다.  
뷰를 정의할 때 기본 릴레이션에서 사용된 애트리뷰트들의 이름 대신에 다른 이름을 부여할 수 있다.  
또한 기본 릴레이션의 애트리뷰트들의 순서와 다르게 명시해도 무방하다.

뷰를 정의하는 SELECT절에 산술식 또는 집단 함수에 사용된 애트리뷰트가 있는 경우,  
뷰의 정의에 조인이 포함되어 있고 두 개 이상의 다른 릴레이션으로부터 가져온 애트리뷰트들의 이름이 같아서  
뷰에서 두 개 이상의 애트리뷰트의 이름이 같게 되는 경우에는 뷰를 정의할 때 모든 애트리뷰트들의 이름을 지정해야 한다.

키워드 AS 다음에 뷰를 정의하는 SELECT문이 위치한다. 여러 단계로 중첩된 SELECT문, 여러 릴레이션을 참조하는 SELECT문도 가능하다.  
WITH CHECK OPTION은 뷰에 투플을 삽입할 때의 조건을 명시한다. 데이터베이스에는 뷰를 정의한 SELECT문이 저장된다.

뷰를 정의하려면 뷰를 만들 수 있는 권한을 데이터베이스 관리자로부터 받아야 하며 뷰 정의에서 참조되는 릴레이션이나 뷰에 대해 적절한 사용권한을 갖고 있어야 한다.

오라클과 같은 관계 DBMS에서는 뷰의 이름과 기본 릴레이션의 이름이 같을 수 없다.  
뷰를 정의하는 SELECT문에는 ORDER BY절이 포함될 수 없다. 그러나 사용자가 뷰로부터 데이터를 검색하는 SELECT문에는 물론 ORDER BY절을 명시할 수 있다.

```
예1: 한 릴레이션 위에서 뷰를 정의
4장의 그림 4.8의 EMPLOYEE 릴레이션에 대해서 "3번 부서에 근무하는 사원들의 사원번호, 사원이름, 직책으로 이루어진 뷰"를 정의해보자.
아래의 뷰의 정의에는 뷰의 애트리뷰트들을 별도로 명시했기 때문에 뷰에는 EMPNO, EMPNAME, TITLE의 세 애트리뷰트가 포함된다.

CREATE VIEW EMP_DNO3 (ENO, ENAME, TITLE)
AS SELECT EMPNO, EMPNAME, TITLE
FROM EMPLOYEE
WHERE DNO = 3;

앞서 설명한 바와 같이 EMP_DNO3에는 실제로 투플들이 저장되어 있지는 않지만 뷰 EMP_DNO3을 통해서 기본 릴레이션 EMPLOYEE를 접근하면
아래 그림과 같이 파란색 음영으로 표시한 부분만 접근할 수 있다. 뷰의 정의에 부합되는 투플(4293, '정용순', '과장', 3011 3000000, 2)이 기본 릴레이션에 삽입되면 뷰를 통해서 그 투플을 접근할 수 있다.
```

![](./image/8-1/ex2.jpg)



```sql
예2 : 두 릴레이션 위에서 뷰를 정의
4장의 그림 4.8의 EMPLOYEE와 DEPARTMENT 릴레이션에 대해서 "기획부에 근무하는 사원들의 이름, 직책, 급여로 이루어진 뷰"를 정의해보자.
아래의 뷰의 정의에는 뷰의 애트리뷰트들을 별도로 명시하지 않았기 때문에 뷰에 속하는 애트리뷰트들의 이름은 기본 릴레이션의 애트리뷰트들의 이름과 같다.
즉 뷰에는 EMPNAME, TITLE, SALARY의 세 애트리뷰트가 포함된다.

CREATE VIEW EMP_PLANNING
AS SELECT E.EMPNAME, E.TITLE, E.SALARY
FROM EMPLOYEE E, DEPARTMENT D
WHERE E.DNO = D.DEPTNO
	AND .DEPTNAME = '기획';
```

뷰를 사용하여 데이터를 접근할 때 관계 DBMS는 일반적으로 아래의 과정들을 거친다.

- 시스템 카탈로그로부터 뷰의 정의, 즉 SELECT문을 검색한다.
- 기본 릴레이션에 대한 뷰의 접근 권한을 검사한다.
- 뷰에 대한 질의를 기본 릴레이션에 대한 동등한 질의로 변환한다.  
  다시 말해서, 뷰를 통한 검색이나 수정은 기본 릴레이션을 통해서 수행된다.  
  예를 들어, 예1의 EMP_DNO3 뷰에 대하여 아래와 같은 SELECT문을 수행하면 기본 릴레이션 EMPLOYEE에 대한 질의로 변환되어 수행된다.  
  뷰에 대해 SELECT절에 ' * ' 를 명시했어도 기본 릴레이션에 대한 SELECT절에서는 뷰의 정의에 사용된 세 애트리뷰트들만 열거된다.  
  FROM절의 EMP_DNO은 EMPLOYEE로 바뀐다. 뷰에 대한 WEHRE절에 TITLE = '사원' 이외에, 뷰를 정의할 때에 사용된 조건은 DNO = 3 이 AND로 연결된다.

```sql
SELECT *				→		SELECT EMPNO, EMPNAME, TITLE
FROM EMP_ENO3			→		FROM EMPLOYEE
WHERE TITLE = '사원';			   WHERE TITLE = '사원'
										AND DNO = 3;
```

뷰를 생성한 후에 뷰가 더 이상 필요 없거나 뷰의 생성자가 뷰의 정의에서 참조된 기본 릴레이션에 대한 SELECT 권한을 잃으면 뷰를 삭제한다.  
뷰가 삭제될 때 이 뷰가 기반으로 하는 기본 릴레이션은 아무런 영향을 받지 않는다. 뷰를 제거하는 SQL의 구문은

DROP VIEW 뷰이름;

이다. 뷰의 생성자 또는 적절한 권한을 가진 사용자만이 뷰를 제거할 수 있다. 삭제된 뷰를 기반으로 하는 뷰나 기타  어플리케이션들은 무효화된다.



## 뷰의 장점

