# ER 모델

ER 모델은 데이터베이스 설계를 용이하게 하기 위해서 P.P Chen이 1976년에 제안하였다.  
이 모델을 제안하게 된 주요 동기는 의미적으로 풍부한 데이터 모델을 제공하고, 개념들을 그래픽하게 나타낼 수 있으며,  
네트워크 데이터 모델, 관계 데이터 모델, 엔티티 집합 모델의 좋은 특성들을 결합하기 위한 것이다.  
Chen이 ER 모델을 제안한 후에 많은 학자들이 이 모델을 강화시켰다.  
현재는 __EER(Enhanced Entity Relationship)__ 모델이 데이터베이스 설계 과정에 널리 사용되고 있다.

ER 모델은 물리적인 데이터베이스 설계의 효율성에 관심을 두지 않으면서 한 조직의 개념적 스키마를 설명하기 위해 사용된다.  
ER 모델은 개념적 설계를 위한 인기 있는 모델로서, 높은 수준으로 추상화하며, 이해하기 쉬우며,  
구문들의 표현력이 뛰어나고 사람들이 어플리케이션에 대해 생각하는 방식과 가깝다.  
ER 모델은 초기의 고수준(개념적) 데이터베이스 설계를 표현하는 데 편리하다.

ER 모델은 실세계를 엔티티, 애트리뷰트, 엔티티들 간의 관계로 표현한다.  
ER 다이어그램은 엔티티 타입, 관계 타입, 이들의 애트리뷰트들을 그래픽하게 표현한 것이다.  
ER 다이어그램은 나중에 데이터베이스가 실제로 구현되는 다른 모델로 표현된 논리적 스키마로 바뀐다.  
ER 모델은 쉽게 관계 데이터 모델로 사상된다. 즉 ER 모델의 여러 구성요소들이 릴레이션들로 쉽게 변환된다.

기본적인 구문으로는 엔티티, 관계, 애트리뷰트가 있고, 기타 구문으로는 카디날리티 비율, 참여 제약조건 등이 있다.  
ER 모델에서 여러 유형의 무결성 제약조건들을 표현할 수 있다.  
모든 제약조건을 ER 모델에서 표현할 수 있는 것은 아니지만 응용 도메인과 실세계의 관점에서 제약조건들은 훌륭한 데이터베이스 설계를 결정하는 데 중요한 역할을 한다.  
이들 중의 일부는 엔티티 타입과 관계 타입을 릴레이션들로 변환할 때 SQL로 표현된다.

ER 모델은 적은 노력으로 쉽게 배울 수 있고, 전문가가 아니어도 이해하기 쉬우며, 자연어보다는 좀 더 정형적이고, 구현에 독립적이어서 기술적으로 덜 상세하므로 데이터베이스 설계자들이 최종 사용자들과 의사소통을 하는 데 적합하다.  
일반적으로 그림은 문장들로 서술한 것보다 의미 전달이 용이하다.

ER 모델을 기반으로 만들어진 다수의 CASE 도구(예: ERWin, DataArchitect, PowerBuilder 등)들이 있다.  
대부분의 DBMS 제조업체들은 이런 CASE 도구들을 지원한다.  
CASE 도구들의 장점은 데이터베이스 설계 시간과 비용을 감소시키고, 데이터베이스 설계 방법론을 표준화하며,  
CASE 도구를 사용하여 개발된 어플리케이션 시스템의 유지 보수를 용이하게 한다는 것이다.

전문적인 데이터베이스 설계자는 10개 이상의 엔티티 타입과 50개 이상의 애트리뷰트들을 포함하는 데이터베이스 설계에 CASE 도구와 자동적인 구현 생성기들을 사용한다.  
이런 도구들은 ER 설계를 자동적으로 오라클, 사이베이스 등의 데이터 정의어로 변환하고, 어떤 도구는 XML로 변환한다.  
이런 도구들은 이 책에서 사용한 표기법과 다소 다른 표기법을 사용한다.  
이런 도구들이 사용하는 표기법은 ER 다이어그램을 그래픽하게 나타내는 데 더 적합하다.

ER 모델링은 현재는 데이터베이스 설계에서 다소 구형 그래픽 표기법이다.  
대규모모델에는 잘 적용되지 않을 수 있다.  
현재, 대규모 기업의 데이터베이스 설계에는 __UML(Unified Modeling Language)__ 을 사용하는 경우가 많다.  
ER에서 UML로 직접 또는 간접적으로 사상할 수 있다.

ER 모델링을 가르치는 이유는 역사적이고 교육적인 효과가 높다는 것이다.  
개념적 모델링을 가르치는데 종이와 연필만 있으면 된다. 이에 반해서 UML은 방대하고 복잡한 설계 언어이다.  
UML 기반의 CASE 도구들을 대학교의 데이터베이스 교육에 도입하는 데는 어려운 점이 있으며 수업 시간에 다루는 간단한 설계 예들은 이런 도구들을 필요로 하지 않는다.  

## 목차

- 엔티티
- 엔티티 타입
- 애트리뷰트
- 약한 엔티티 타입
- 관계와 관계 타입
- ER 스키마를 작성하기 위한 지침
- 데이터베이스 설계 과정
- ER 모델의 또 다른 표기법



## 엔티티

하나의 엔티티는 사람, 장소, 사물, 사건 등과 같이 독립적으로 존재하면서 고유하게 식별이 가능한 실세계의 객체이다.  
예를 들어, 사원번호가 2106이고 이름이 김창섭인 사원, 학번이 20021033이고 이름이 홍길동인 학생, 과목 코드가 CS372인 데이터베이스 등이다.  
비록 엔티티는 사원처럼 실체가 있는 것도 있지만 생각이나 개념과 같이 추상적인 것도 있다.  
예를 들어, 프로젝트 번호가 P101인 프로젝트, 학과 번호가 D315인 학과는 개념적으로 존재하는 엔티티이다.  



## 엔티티 타입

엔티티들은 엔티티 타입(또는 엔티티 집합)들로 분류된다.  
엔티티 집합은 동일한 애트리뷰트들을 가진 엔티티들의 모임이다.  
예를 들어, 한 회사의 모든 사원들은 EMPLOYEE라는 엔티티 집합을 이루고, 모든 부서들은 DEPARTMENT라고 부르는 엔티티 집합에 속한다.  
하나의 엔티티는 한 개 이상의 엔티티 집합에 속할 수 있다.  
예를 들어, 어떤 사원은 EMPLOYEE와 MANAGER라는 두 엔티티 집합에 속할 수 있다.  
그러므로 엔티티 집합은 항상 서로 상이하지는 않다.

엔티티 타입은 동일한 애트리뷰트들을 가진 엔티티들의 틀이다.  
엔티티 타입은 관계 모델의 릴레이션의 내포에 해당하고, 엔티티 집합은 관계 모델의 릴레이션의 외연에 해당한다.  
엔티티 집합과 엔티티 타입을 엄격하게 구분할 필요는 없다. 문맥을 보고 판단하기 바란다.  
앞서 설명한 바와 같이 데이터베이스는 한 조직에서 서로 연관된 정보의 모임이므로 데이터베이스는 엔티티 집합들의 모임으로 이루어진다.  
또한 데이터베이스는 엔티티 집합들 간의 관계들에 관한 정보도 포함한다.

ER 다이어그램에서 엔티티 타입은 직사각형으로 나타낸다.  
일반적으로 엔티티 타입의 이름은 엔티티 타입의 의미를 잘 나타내는 단수형으로 명시한다.

엔티티 타입에는 두 가지 종류가 있다.  
__강한 엔티티 타입(정규 엔티티 타입)__ 은 독자적으로 존재하며 엔티티 타입 내에서  
자신의 키 애트리뷰트를 사용하여 고유하게 엔티티들을 식별할 수 있는 엔티티 타입을 의미한다.  
이에 반해서 __약한 엔티티 타입__ 은 키를 형성하기에 충분한 애트리뷰트들을 갖지 못한 엔티티 타입이다.  
이 엔티티 타입이 존재하려면 __소유 엔티티 타입__ 이 있어야만 한다.  
소유 엔티티 타입의 키 애트리뷰트를 결합해야만 고유하게 약한 엔티티 타입의 엔티티들을 식별할 수 있다.  
ER 스키마에서 대부분의 엔티티 타입은 정규 엔티티 타입이다.



## 애트리뷰트

하나의 엔티티는 연관된 애트리뷰트들의 집합으로 설명된다.  
예를 들어, 사원 엔티티는 사원번호, 이름, 직책, 급여 등의 애트리뷰트를 갖고,  
책은 저자, 제목, 출판사, 발간연도 등의 애트리뷰트를 갖는다.  
고객 엔티티는 이름, 나이, 주소, 성별, 신장, 몸무게 등의 애트리뷰트를 갖지만  
신장, 몸무게 등이 기업에 필요가 없는 경우에는 데이터베이스에 저장할 필요가 없다.  
각 엔티티를 기술하는 애트리뷰트 값들은 데이터베이스에 궁극적으로 저장되는 데이터의 중요한 부분이 된다.

각 객체는 애트리뷰트들과 어떤 시점의 애트리뷰트들의 값으로 설명된다.  
하지만 종종 애트리뷰트의 현재 값에만 관심을 가지므로 객체에 관한 정보에서 시간을 제외하는 것이 편리하다.  
그러나 어떤 응용 소프트웨어에서는 시간이 매우 중요하다.  
예를 들어, 인사과에서는 회사의 모든 사원에 대해 급여가 변화된 이력(history)과 직급이 변화된 이력을 알고 싶을 수 있다.  
이와 같은 시간 데이터를 저장하는 여러 가지 방법이 있지만 이를 자세하게 알 필요는 없다.

각 애트리뷰트가 가질 수 있는 값들의 집합이 있다.  
한 애트리뷰트의 도메인은 그 애트리뷰트가 가질 수 있는 모든 가능한 값들의 집합을 의미한다.  
예를 들어, 사원번호는 1000부터 9999까지의 값을 갖고, 사원의 나이는 20부터 60 사이의 값을 가질 수 있다.  
여러 애트리뷰트가 동일한 도메인을 공유할 수 있다. 예를 들어, 사원번호와 부서번호가 네 자리 정수를 가질 수 있다.

한 엔티티 타입 내의 엔티티들은 서로 식별이 가능해야 한다.  
키 애트리뷰트는 한 애트리뷰트 또는 애트리뷰트들의 모임으로서 한 엔티티 타입 내에서 각 엔티티를 고유하게 식별한다.  
데이터 의미에 따라 키의 정의가 달라질 수 있다. 한 엔티티 타입에 여러 개의 후보 키가 존재할 수 있다.  
개념적 설계 과정에서 후보 키 중 하나를 엔티티 타입의 기본 키로 선정한다.  
대체 키(보조 키)는 기본 키가 아닌 후보 키를 말한다. ER 다이어그램에서 기본 키에 속하는 애트리뷰트는 밑줄을 그어 표시한다.  
ER 다이어그램에서는 기본 키와 대체 키를 구분하지 않는다.

키로 사용하기에 적합한 애트리뷰트가 엔티티 타입에 없을 경우에는 때로 엔티티 식별을 쉽게 하기 위해서 인위적으로 기본 키 애트리뷰트를 엔티티 타입에 추가하기도 한다.  
예를 들어, STUDENT 엔티티 타입의 각 엔티티를 식별하기 위해서 학생이름, 주소, 생년월일 애트리뷰트들을 사용할 수도 있지만 각 학생 엔티티를 쉽게 식별하기 위해서 학번 애트리뷰트를 추가하는 것이 편리하다.

애트리뷰트는 요구사항 명세에서 명사나 형용사로 표현된다.  
엔티티와 애트리뷰트의 차이점은 엔티티는 독립적인 의미를 갖는 데 반해서 애트리뷰트는 독립적인 의미를 갖지 않는다는 것이다.  
ER 다이어그램에서 애트리뷰트는 타원형으로 나타낸다. 애트리뷰트와 엔티티 타입은 실선으로 연결한다.

애트리뷰트는 아래와 같이 여러 가지 유형으로 구분한다.  

- __단순 애트리뷰트(simple attribute)__: 단순 애트리뷰트는 더 이상 다른 애트리뷰트로 나눌 수 없는 애트리뷰트이다.  
  단순 애트리뷰트는 ER 다이어그램에서 실선 타원으로 표현한다.  
  아래 그림에서는 CUSTOMER 엔티티 타입에는 Address, Name, ID 등 세 개의 애트리뷰트가 있는데, 이 애트리뷰트들은 모두 단순 애트리뷰트이다.  
  ID 애트리뷰트에는 밑줄이 표시되었으므로 키 애트리뷰트이다.  
  ER 다이어그램에서 대부분의 애트리뷰트는 단순 애트리뷰트이다.

  ![](./image/5-2/ex1.jpg)

- __복합 애트리뷰트(composite attribute)__: 복합 애트리뷰트는 두 개 이상의 애트리뷰트로 이루어진 애트리뷰트이다.  
  동일한 엔티티 타입에 속하는 애트리뷰트들 중에서 밀접하게 연관된 것을 모아놓은 것이다.  
  아래 그림에서 애트리뷰트 Address는 City(시), Ku(구), Dong(동), Zipcode(우편번호)로 나눌 수 있으므로 복합 애트리뷰트이다.  
  여러 지역에 분점을 가진 대형 백화점이 각 분점에서 상품을 구입하는 고객들의 거주 지역을  
  세밀한 수준에서 분석하기 위해서는 주소를 시, 구, 동으로 구분하는 것이 필요할 수 있다.  
  주소 전체를 하나의 단순 애트리뷰트로 지정하면 하나의 문자열로 저장되므로 고객들의 거주 지역에 따른 소비 패턴을 분석하는 것이 매우 어렵게 된다.  
  신문에 세일 광고물을 끼워서 가정에 배달하는 경우에, 해당 분점을 자주 방문하는 고객들의 주요 거주 지역을 쉽게 파악할 수 있다면 상대적으로 저렴한 비용으로 광고 효과가 높은 지역을 선별하여 광고할 수 있다.  
  물론 Address의 각 구성요소를 구분해서 활용하지 않고 단순히 카드 사용 내역서 등을 발송하는 목적으로만 사용한다면,  
  Address를 여러 개의 애트리뷰트들로 나눌 필요는 없다.

  ![](./image/5-2/ex2.jpg)

- 

