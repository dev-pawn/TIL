# ER 모델

ER 모델은 데이터베이스 설계를 용이하게 하기 위해서 P.P Chen이 1976년에 제안하였다.  
이 모델을 제안하게 된 주요 동기는 의미적으로 풍부한 데이터 모델을 제공하고, 개념들을 그래픽하게 나타낼 수 있으며,  
네트워크 데이터 모델, 관계 데이터 모델, 엔티티 집합 모델의 좋은 특성들을 결합하기 위한 것이다.  
Chen이 ER 모델을 제안한 후에 많은 학자들이 이 모델을 강화시켰다.  
현재는 __EER(Enhanced Entity Relationship)__ 모델이 데이터베이스 설계 과정에 널리 사용되고 있다.

ER 모델은 물리적인 데이터베이스 설계의 효율성에 관심을 두지 않으면서 한 조직의 개념적 스키마를 설명하기 위해 사용된다.  
ER 모델은 개념적 설계를 위한 인기 있는 모델로서, 높은 수준으로 추상화하며, 이해하기 쉬우며,  
구문들의 표현력이 뛰어나고 사람들이 어플리케이션에 대해 생각하는 방식과 가깝다.  
ER 모델은 초기의 고수준(개념적) 데이터베이스 설계를 표현하는 데 편리하다.

ER 모델은 실세계를 엔티티, 애트리뷰트, 엔티티들 간의 관계로 표현한다.  
ER 다이어그램은 엔티티 타입, 관계 타입, 이들의 애트리뷰트들을 그래픽하게 표현한 것이다.  
ER 다이어그램은 나중에 데이터베이스가 실제로 구현되는 다른 모델로 표현된 논리적 스키마로 바뀐다.  
ER 모델은 쉽게 관계 데이터 모델로 사상된다. 즉 ER 모델의 여러 구성요소들이 릴레이션들로 쉽게 변환된다.

기본적인 구문으로는 엔티티, 관계, 애트리뷰트가 있고, 기타 구문으로는 카디날리티 비율, 참여 제약조건 등이 있다.  
ER 모델에서 여러 유형의 무결성 제약조건들을 표현할 수 있다.  
모든 제약조건을 ER 모델에서 표현할 수 있는 것은 아니지만 응용 도메인과 실세계의 관점에서 제약조건들은 훌륭한 데이터베이스 설계를 결정하는 데 중요한 역할을 한다.  
이들 중의 일부는 엔티티 타입과 관계 타입을 릴레이션들로 변환할 때 SQL로 표현된다.

ER 모델은 적은 노력으로 쉽게 배울 수 있고, 전문가가 아니어도 이해하기 쉬우며, 자연어보다는 좀 더 정형적이고, 구현에 독립적이어서 기술적으로 덜 상세하므로 데이터베이스 설계자들이 최종 사용자들과 의사소통을 하는 데 적합하다.  
일반적으로 그림은 문장들로 서술한 것보다 의미 전달이 용이하다.

ER 모델을 기반으로 만들어진 다수의 CASE 도구(예: ERWin, DataArchitect, PowerBuilder 등)들이 있다.  
대부분의 DBMS 제조업체들은 이런 CASE 도구들을 지원한다.  
CASE 도구들의 장점은 데이터베이스 설계 시간과 비용을 감소시키고, 데이터베이스 설계 방법론을 표준화하며,  
CASE 도구를 사용하여 개발된 어플리케이션 시스템의 유지 보수를 용이하게 한다는 것이다.

전문적인 데이터베이스 설계자는 10개 이상의 엔티티 타입과 50개 이상의 애트리뷰트들을 포함하는 데이터베이스 설계에 CASE 도구와 자동적인 구현 생성기들을 사용한다.  
이런 도구들은 ER 설계를 자동적으로 오라클, 사이베이스 등의 데이터 정의어로 변환하고, 어떤 도구는 XML로 변환한다.  
이런 도구들은 이 책에서 사용한 표기법과 다소 다른 표기법을 사용한다.  
이런 도구들이 사용하는 표기법은 ER 다이어그램을 그래픽하게 나타내는 데 더 적합하다.

ER 모델링은 현재는 데이터베이스 설계에서 다소 구형 그래픽 표기법이다.  
대규모모델에는 잘 적용되지 않을 수 있다.  
현재, 대규모 기업의 데이터베이스 설계에는 __UML(Unified Modeling Language)__ 을 사용하는 경우가 많다.  
ER에서 UML로 직접 또는 간접적으로 사상할 수 있다.

ER 모델링을 가르치는 이유는 역사적이고 교육적인 효과가 높다는 것이다.  
개념적 모델링을 가르치는데 종이와 연필만 있으면 된다. 이에 반해서 UML은 방대하고 복잡한 설계 언어이다.  
UML 기반의 CASE 도구들을 대학교의 데이터베이스 교육에 도입하는 데는 어려운 점이 있으며 수업 시간에 다루는 간단한 설계 예들은 이런 도구들을 필요로 하지 않는다.  

## 목차

- [엔티티](#엔티티)
- [엔티티 타입](#엔티티-타입)
- [애트리뷰트](#애트리뷰트)
- [약한 엔티티 타입](#약한-엔티티-타입)
- [관계와 관계 타입](#관계와-관계-타입)
- [ER 스키마를 작성하기 위한 지침](#er-스키마를-작성하기-위한-지침)
- [데이터베이스 설계 과정](#데이터베이스-설계-과정)
- [ER 모델의 또 다른 표기법](#er-모델의-또-다른-표기법)



## 엔티티

하나의 엔티티는 사람, 장소, 사물, 사건 등과 같이 독립적으로 존재하면서 고유하게 식별이 가능한 실세계의 객체이다.  
예를 들어, 사원번호가 2106이고 이름이 김창섭인 사원, 학번이 20021033이고 이름이 홍길동인 학생, 과목 코드가 CS372인 데이터베이스 등이다.  
비록 엔티티는 사원처럼 실체가 있는 것도 있지만 생각이나 개념과 같이 추상적인 것도 있다.  
예를 들어, 프로젝트 번호가 P101인 프로젝트, 학과 번호가 D315인 학과는 개념적으로 존재하는 엔티티이다.  



## 엔티티 타입

엔티티들은 엔티티 타입(또는 엔티티 집합)들로 분류된다.  
엔티티 집합은 동일한 애트리뷰트들을 가진 엔티티들의 모임이다.  
예를 들어, 한 회사의 모든 사원들은 EMPLOYEE라는 엔티티 집합을 이루고, 모든 부서들은 DEPARTMENT라고 부르는 엔티티 집합에 속한다.  
하나의 엔티티는 한 개 이상의 엔티티 집합에 속할 수 있다.  
예를 들어, 어떤 사원은 EMPLOYEE와 MANAGER라는 두 엔티티 집합에 속할 수 있다.  
그러므로 엔티티 집합은 항상 서로 상이하지는 않다.

엔티티 타입은 동일한 애트리뷰트들을 가진 엔티티들의 틀이다.  
엔티티 타입은 관계 모델의 릴레이션의 내포에 해당하고, 엔티티 집합은 관계 모델의 릴레이션의 외연에 해당한다.  
엔티티 집합과 엔티티 타입을 엄격하게 구분할 필요는 없다. 문맥을 보고 판단하기 바란다.  
앞서 설명한 바와 같이 데이터베이스는 한 조직에서 서로 연관된 정보의 모임이므로 데이터베이스는 엔티티 집합들의 모임으로 이루어진다.  
또한 데이터베이스는 엔티티 집합들 간의 관계들에 관한 정보도 포함한다.

ER 다이어그램에서 엔티티 타입은 직사각형으로 나타낸다.  
일반적으로 엔티티 타입의 이름은 엔티티 타입의 의미를 잘 나타내는 단수형으로 명시한다.

엔티티 타입에는 두 가지 종류가 있다.  
__강한 엔티티 타입(정규 엔티티 타입)__ 은 독자적으로 존재하며 엔티티 타입 내에서  
자신의 키 애트리뷰트를 사용하여 고유하게 엔티티들을 식별할 수 있는 엔티티 타입을 의미한다.  
이에 반해서 __약한 엔티티 타입__ 은 키를 형성하기에 충분한 애트리뷰트들을 갖지 못한 엔티티 타입이다.  
이 엔티티 타입이 존재하려면 __소유 엔티티 타입__ 이 있어야만 한다.  
소유 엔티티 타입의 키 애트리뷰트를 결합해야만 고유하게 약한 엔티티 타입의 엔티티들을 식별할 수 있다.  
ER 스키마에서 대부분의 엔티티 타입은 정규 엔티티 타입이다.



## 애트리뷰트

하나의 엔티티는 연관된 애트리뷰트들의 집합으로 설명된다.  
예를 들어, 사원 엔티티는 사원번호, 이름, 직책, 급여 등의 애트리뷰트를 갖고,  
책은 저자, 제목, 출판사, 발간연도 등의 애트리뷰트를 갖는다.  
고객 엔티티는 이름, 나이, 주소, 성별, 신장, 몸무게 등의 애트리뷰트를 갖지만  
신장, 몸무게 등이 기업에 필요가 없는 경우에는 데이터베이스에 저장할 필요가 없다.  
각 엔티티를 기술하는 애트리뷰트 값들은 데이터베이스에 궁극적으로 저장되는 데이터의 중요한 부분이 된다.

각 객체는 애트리뷰트들과 어떤 시점의 애트리뷰트들의 값으로 설명된다.  
하지만 종종 애트리뷰트의 현재 값에만 관심을 가지므로 객체에 관한 정보에서 시간을 제외하는 것이 편리하다.  
그러나 어떤 응용 소프트웨어에서는 시간이 매우 중요하다.  
예를 들어, 인사과에서는 회사의 모든 사원에 대해 급여가 변화된 이력(history)과 직급이 변화된 이력을 알고 싶을 수 있다.  
이와 같은 시간 데이터를 저장하는 여러 가지 방법이 있지만 이를 자세하게 알 필요는 없다.

각 애트리뷰트가 가질 수 있는 값들의 집합이 있다.  
한 애트리뷰트의 도메인은 그 애트리뷰트가 가질 수 있는 모든 가능한 값들의 집합을 의미한다.  
예를 들어, 사원번호는 1000부터 9999까지의 값을 갖고, 사원의 나이는 20부터 60 사이의 값을 가질 수 있다.  
여러 애트리뷰트가 동일한 도메인을 공유할 수 있다. 예를 들어, 사원번호와 부서번호가 네 자리 정수를 가질 수 있다.

한 엔티티 타입 내의 엔티티들은 서로 식별이 가능해야 한다.  
키 애트리뷰트는 한 애트리뷰트 또는 애트리뷰트들의 모임으로서 한 엔티티 타입 내에서 각 엔티티를 고유하게 식별한다.  
데이터 의미에 따라 키의 정의가 달라질 수 있다. 한 엔티티 타입에 여러 개의 후보 키가 존재할 수 있다.  
개념적 설계 과정에서 후보 키 중 하나를 엔티티 타입의 기본 키로 선정한다.  
대체 키(보조 키)는 기본 키가 아닌 후보 키를 말한다. ER 다이어그램에서 기본 키에 속하는 애트리뷰트는 밑줄을 그어 표시한다.  
ER 다이어그램에서는 기본 키와 대체 키를 구분하지 않는다.

키로 사용하기에 적합한 애트리뷰트가 엔티티 타입에 없을 경우에는 때로 엔티티 식별을 쉽게 하기 위해서 인위적으로 기본 키 애트리뷰트를 엔티티 타입에 추가하기도 한다.  
예를 들어, STUDENT 엔티티 타입의 각 엔티티를 식별하기 위해서 학생이름, 주소, 생년월일 애트리뷰트들을 사용할 수도 있지만 각 학생 엔티티를 쉽게 식별하기 위해서 학번 애트리뷰트를 추가하는 것이 편리하다.

애트리뷰트는 요구사항 명세에서 명사나 형용사로 표현된다.  
엔티티와 애트리뷰트의 차이점은 엔티티는 독립적인 의미를 갖는 데 반해서 애트리뷰트는 독립적인 의미를 갖지 않는다는 것이다.  
ER 다이어그램에서 애트리뷰트는 타원형으로 나타낸다. 애트리뷰트와 엔티티 타입은 실선으로 연결한다.

애트리뷰트는 아래와 같이 여러 가지 유형으로 구분한다.  

- __단순 애트리뷰트(simple attribute)__: 단순 애트리뷰트는 더 이상 다른 애트리뷰트로 나눌 수 없는 애트리뷰트이다.  
  단순 애트리뷰트는 ER 다이어그램에서 실선 타원으로 표현한다.  
  아래 그림에서는 CUSTOMER 엔티티 타입에는 Address, Name, ID 등 세 개의 애트리뷰트가 있는데, 이 애트리뷰트들은 모두 단순 애트리뷰트이다.  
  ID 애트리뷰트에는 밑줄이 표시되었으므로 키 애트리뷰트이다.  
  ER 다이어그램에서 대부분의 애트리뷰트는 단순 애트리뷰트이다.

  ![](./image/5-2/ex1.jpg)

- __복합 애트리뷰트(composite attribute)__: 복합 애트리뷰트는 두 개 이상의 애트리뷰트로 이루어진 애트리뷰트이다.  
  동일한 엔티티 타입에 속하는 애트리뷰트들 중에서 밀접하게 연관된 것을 모아놓은 것이다.  
  아래 그림에서 애트리뷰트 Address는 City(시), Ku(구), Dong(동), Zipcode(우편번호)로 나눌 수 있으므로 복합 애트리뷰트이다.  
  여러 지역에 분점을 가진 대형 백화점이 각 분점에서 상품을 구입하는 고객들의 거주 지역을  
  세밀한 수준에서 분석하기 위해서는 주소를 시, 구, 동으로 구분하는 것이 필요할 수 있다.  
  주소 전체를 하나의 단순 애트리뷰트로 지정하면 하나의 문자열로 저장되므로 고객들의 거주 지역에 따른 소비 패턴을 분석하는 것이 매우 어렵게 된다.  
  신문에 세일 광고물을 끼워서 가정에 배달하는 경우에, 해당 분점을 자주 방문하는 고객들의 주요 거주 지역을 쉽게 파악할 수 있다면 상대적으로 저렴한 비용으로 광고 효과가 높은 지역을 선별하여 광고할 수 있다.  
  물론 Address의 각 구성요소를 구분해서 활용하지 않고 단순히 카드 사용 내역서 등을 발송하는 목적으로만 사용한다면,  
  Address를 여러 개의 애트리뷰트들로 나눌 필요는 없다.

  ![](./image/5-2/ex2.jpg)

- __단일 값 애트리뷰트(single-valued attribute)__: 단일 값 애트리뷰트는 각 엔티티마다 정확하게 하나의 값을 갖는 애트리뷰트이다.  
  다시 말해서, 값들의 집합이나 리스트를 갖지 않는 애트리뷰트이다.  
  단일 값 애트리뷰트는 ER 다이어그램에서 단순 애트리뷰트와 동일하게 표현된다.  
  예를 들어, 사원번호 애트리뷰트는 어떤 사원도 두 개 이상의 사원번호를 갖지 않으므로 단일 값 애트리뷰트이다.  
  ER 다이어그램에서 대부분의 애트리뷰트는 단일 값 애트리뷰트이다.

- __다치 애트리뷰트(multi-valued attribute)__: 다치 애트리뷰트는 각 엔티티마다 여러 개의 값을 가질 수 있는 애트리뷰트이다.  
  예를 들어, 사원은 여러 개의 취미를 가질 수 있으므로 사원 엔티티 타입에 취미 애트리뷰트가 있다면 다치 애트리뷰트로 지정해야 한다.  
  다치 애트리뷰트는 ER 다이어그램에서 이중선 타원으로 표현한다.

  ![](./image/5-2/ex3.jpg)

- __저장된 애트리뷰트(stored attribute)__: 저장된 애트리뷰트는 다른 애트리뷰트와 독립적으로 존재하는 애트리뷰트이다.  
  저장된 애트리뷰트도 ER 다이어그램에서 단순 애트리뷰트와 동일하게 표현된다.  
  ER 다이어그램에서 대부분의 애트리뷰트는 저장된 애트리뷰트이다.  
  예를 들어, 사원 엔티티 타입에서 사원이름, 급여는 다른 애트리뷰트와 독립적으로 존재한다.

- __유도된 애트리뷰트(derived attribute)__: 유도된 애트리뷰트는 다른 애트리뷰트의 값으로부터 얻어진 애트리뷰트이다.  
  예를 들어 , Age(나이) 애트리뷰트는 주민등록번호 애트리뷰트로부터 유도될 수 있는 애트리뷰트이다.  
  유도된 애트리뷰트는 반드시 필요한 애트리뷰트가 아니고 데이터의 불일치를 유발할 수 있으므로,  
  관계 데이터베이스에서 릴레이션의 애트리뷰트로 포함시키지 않는 것이 좋다.  
  Age 이외에도 합, 평균, 개수, 등이 유도된 애트리뷰트에 해당된다.  
  유도된 애트리뷰트는 ER 다이어그램에서 점선 타원으로 표현한다.

  ![](./image/5-2/ex4.jpg)



## 약한 엔티티 타입

어떤 경우에는 엔티티 타입 내의 엔티티들이 자체적으로 갖고 있는 애트리뷰트들의 값에 의해서 고유하게 식별이 안 된다.  
예를 들어, 회사에서 어떤 사원의 부양가족 이름은 다른 사원의 부양가족의 이름과 같을 수 있다.  
한 가지 해결 방안은 회사의 사원들의 모든 부양가족에 대해서 고유한 번호를 부여하는 것이다.  
이런 고유한 번호는 데이터베이스 처리에 사용되지 않을 수 있다.

또 다른 해결 방안은 부양가족이 속한 사원의 번호를 부양가족의 이름과 결합하여 부양가족의 키로 정하는 것이다.  
한 사원의 부양가족의 이름은 모두 다를 것이므로, 사원번호와 부양가족의 이름을 결합하면 모든 사원들의 부양가족들을 고유하게 식별할 수 있다.  
부양가족의 이름처럼 한 사원에 속한 부양가족 내에서는 서로 다르지만  
회사의 모든 사원들의 부양가족들 전체에서는 같은 경우가 생길 수 있는 애트리뷰트를 __부분 키(partial key)__ 라고 부른다. 
이처럼 자체적으로 키를 보유하지 못한 엔티티를 __약한 엔티티 타입(weak entity type)__ 이라고 부른다.  
즉 약한 엔티티 타입은 엔티티들을 고유하게 식별하기 위해서 다른 엔티티 타입으로부터 키 애트리뷰트를 가져오는 엔티티 타입이다.  
이때 약한 엔티티 타입에게 키 애트리뷰트를 제공하는 엔티티 타입을 __소유 엔티티 타입(owner entity type)__ 또는 __식별 엔티티 타입(identifying entity type)__ 이라고 부른다.  
약한 엔티티 타입은 소유 엔티티 타입이 존재하지 않으면 존재할 수 없는 엔티티 타입이다.  
ER 다이어그램에서 약한 엔티티 타입은 이중선 직사각형으로 표기한다. 약한 엔티티 타입의 부분 키는 점선 밑줄을 그어 표시한다.

기본 키를 가진 엔티티를 __강한 엔티티 타입(strong entity type)__ 또는 __정규 엔티티 타입(regular entity type)__ 이라고 부른다.  
마찬가지로 관계에도 약한 관계와 강한 관계가 있다.  
강한 관계는 강한 엔티티들 사이의 관계이고, 강한 엔티티 타입과 약한 엔티티 타입을 연결하는 관계는 약한 관계이다.  
약한 엔티티는 다른 엔티티의 존재에 의존하므로 종속되는 엔티티라고도 부른다.  
이를 __의존 종속성(existence dependence)__ 이라고 한다.  
만일 E가 약한 엔티티 타입이면 E에 하나 이상의 키를 제공하는 엔티티 타입 F들은 관계 타입 R에 의해서 E와 연관되어야 한다.

![](./image/5-2/ex5.jpg)

```
위의 ER 다이어그램은 정규 엔티티 타입 EMPLOYEE와 약한 엔티티 타입 DEPENDENT를 보여준다.
회사에서 사원들의 부양가족들에게 의료보험 해택을 제공하기 위해서 EMPLOYEE 엔티티 타입과 DEPENDENT 엔티티 타입을 POLICY(보험) 관계 타입으로 연결하였다.
약한 엔티티 타입 DEPENDENT의 부분키 Depname에는 점선 밑줄을 그어 표시하였다.
DEPENDENT 엔티티는 대응되는 EMPLOYEE 엔티티의 존재 여부에 의존한다.
EMPLOYEE 엔티티 타입은 DEPENDENT 엔티티 타입의 소유 엔티티 타입이다.
정규 엔티티 타입과 약한 엔티티 타입을 연결하는 POLICY(보험) 관계 타입은 이중선 다이아몬드로 표시한다. POLICY 관계 타입은 약한 관계 타입이다.
```



## 관계와 관계 타입

