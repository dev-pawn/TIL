#  라우팅 프로토콜과의 한판



## 목차

- [RIP라는 라우팅 프로토콜에 대한 이야기](#rip라는-라우팅-프로토콜에-대한-이야기)
- [RIP와 함께 춤을?](#rip와-함께-춤을-)
- [Distance-Vector 라우팅 알고리즘에서의 문제점과 해결책](#distance-vector-라우팅-알고리즘에서의-문제점과-해결책)
- [IGRP 라우팅 프로토콜](#igrp-라우팅-프로토콜)
- [OSPF 라우팅 프로토콜](#ospf-라우팅-프로토콜)



## RIP라는 라우팅 프로토콜에 대한 이야기

여기에서는 다이내믹 라우팅 프로토콜에 대해서 알아보겠습니다. 전에도 한번 설명을 드렸지만 다이내믹 라우팅 프로토콜은 운영자가 일일이 경로를 지정하지 않아도 라우터가 똑똑하게 알아서 길을 찾아가는 프로토콜입니다.

우선 이렇게 똑똑한 다이내믹 프로토콜 중에서 가장 구성이 쉬우면서도 가장 단순한 라우팅 프로토콜인 RIP에 대해서 알아보겠습니다.

먼저 RIP(Routing Information Protocol)를 짧은 질문과 대답을 가지고 간단하게 정리해 보도록 하겠습니다.

![](./img/2-1/ex1.jpg)

![](./img/2-1/ex2.jpg)

이 정도만 RIP에 대해서 알고 있다면 아마 RIP에 대해서는 자신감이 생길 겁니다. 몇 가지는 이미 설명을 드린 내용이고 나머지 설명드리지 않은 부분은 앞으로 진도를 나가면서 하나씩 설명하겠습니다.

RIP는 말씀드린 것처럼 단순하기는 하지만 그래도 옛날부터 많은 사랑을 받아온 명실상부한 스탠다드(Standard), 즉 표준 라우팅 프로토콜입니다.  
초보자가 라우터를 컨피규레이션 (설정, Configuration)한다면 RIP가 아마 가장 편리할 겁니다. RIP는 또 라우터의 메모리를 적게 사용하는 장점도 있습니다. 정말 좋은 프로토콜입니다.

하지만 RIP의 경우는 몇 가지 단점도 가지고 있습니다.

우선 RIP가 목적지까지의 최적 경로를 찾아가는 방법을 알아봐야 합니다. RIP의 경우는 최적의 경로를 찾는 방법이 가장 단순합니다. 즉 라우터를 몇 번 거쳐서 목적지에 도착하는가를 보는 것입니다. 다시 말하면 목적지까지 가는 데 네트워크를 몇 번 거쳐야 하는가입니다. 이것은 조금 어려운 용어로 말씀드리면 '홉 카운트(Hop Count)'라고 하는데, RIP는 가장 낮은 홉 카운트가 가장 좋은 경로라는 결정하게 됩니다.

이렇게 홉 카운트만 가지고 경로를 선택하다 보니 실수도 많이 하게 됩니다. 예를 들어 다음 그림을 보기 바랍니다.

![](./img/2-1/ex3.jpg)

그림에서 1번 PC에서 2번 PC로 가는 데이터가 있을 때 라우터 A에 RIP 라우팅 프로토콜이 돌고 있다면 라우터 A는 화살표대로 라우터 B쪽으로 데이터를 보냅니다. 왜냐하면 라우터 B쪽으로 보내는 것이 홉 카운트가 더 적기 때문입니다.  
라우터 C쪽으로 보내면 라우터 C와 라우터 D, 그리고 라우터 B를 거쳐야 목적지인 2번 PC에 도착할 수 있기 때문입니다. 하지만 각 라우터간의 회선 속도를 보기 바랍니다.

데이터가 라우터 B쪽으로 가게 되면 28.8Kbps라는 엄청나게 느린 속도로 날아가게 됩니다. 하지만 라우터 C 방향으로 가면 비록 라우터는 위쪽보다 많이 거치게 되어도 속도가 T1 (1.544Mbps)이기 때문에 훨씬 빨리 날아갈 수 있습니다. 즉 사실은 라우터 A는 2번 PC로 가는 패킷을 라우터 C쪽으로 보내는 게 훨씬 빨리 보낼 수 있는 겁니다.

그래도 RIP는 계속 위로 데이터를 보냅니다.

이게 바로 RIP의 단점입니다. 즉 경로 선택을 오로지 홉 카운트에 의존하기 때문에 속도나 회선의 신뢰도, 그리고 회선의 로드 등을 확인해 볼 수 없는 겁니다. 따라서 그냥 라우터를 적게 거치는 것은 좋은 경로로 선택해 버립니다.

또 RIP의 경우 자신의 라우터에서 15개 이상의 라우터를 거치는 목적지의 경우는 Unreachable(갈 수 없음)로 정의하고 데이터를 보내지 못하기 때문에 커다란 네트워크상에서 사용하기는 무리가 있습니다.

그럼에도 불구하고 아직도 많은 곳에서 RIP를 사용하는 이유는 소규모 네트워크 상에서는 효율성이 좋고, 라우터의 메모리를 적게 차지하며, 게다가 구성이 간편하기 때문입니다. 참, 그리고 모든 라우터에서 지원하는 표준 라우티 프로토콜이라는 것도 한 가지 이유가 될 겁니다.

여러분도 사용해보실 기회가 있을 겁니다.



> 알고 갑시다!

다이내믹 프로토콜 중의 하나인 RIP(Routing information Protocol)는 구성이 간편하고 표준 라우팅 프로토콜이어서 많은 곳에서 사용되고 있다. 그러나 경로 선택을 오직 홉 카운트로만 한다든지, 데이터를 최대 라우팅할 수 있는 거리가 짧다는 단점 때문에 커다란 네트워크보다는 소규모 네트워크에서 많이 사용된다.  
RIP에서 몇 가지 더 알아야 할 사항은 앞에서도 설명했던 업데이트 주기이다. RIP의 경우는 매 30초마다 이웃한 라우터들과 라우팅 정보를 교환한다. 경로에 이상이 있는 건 아닌지 또 뭔가 새로 생긴 경로는 없는지를 확인한다.



> 질문 있어요! QnA

Q 질문이 있는데요. 사람들이 라우터를 구성하면서 '백투백(Back-to-Back)'이라고 하던데, 어떤 구성을 이야기하는지, 그리고 왜 이런 구성을 하는지 알고 싶어요.

A 네, 라우터를 실습실에서 구성하다 보면 가장 먼저 떠오르는 고민이 바로 전용선 구간입니다.

원래 환경에서는 전화국에 요청해서 전용선을 설치하고 서로 라우터를 연결하면 되지만, 실습실에 전용선을 설치할수는 없어서 만드는 구성이 바로 Back-to-Back 구성입니다. 즉 라우터와 라우터를 서로 직접 연결하면서 마치 전용선 구간에서 연결한 것처럼 만드는 기술입니다.

아시겠지만 원래 전용선을 연결하기 위해서는 라우터 뒤에 모뎀 장비인 DSU/CSU가 붙고 그 뒤에 전용선을 연결합니다. 하지만 Back-to-Back 구성에서는 라우터 대 라우터를 V.35 케이블만 가지고 서로 연결하는 것입니다. 그림을 보면 금방 이해가 될 겁니다.

![](./img/2-1/ex4.jpg)

![](./img/2-1/ex5.jpg)

그림에서 위의 그림이 실제 구성입니다. 즉 라우터의 시리얼 인터페이스에 V.35 케이블을 연결하고 한쪽 끝은 DSU/CSU에 연결합니다. DSU/CSU는 전용선에 연결하게 되는 겁니다. 상대편도 마찬가지로 구성됩니다.

이러한 실제 구성에서 라우터는 DTE 장비가 되고. DSU/CSU는 DCE 장비가 되기 때문에 이때 라우터에 사용하는 V.35 케이블은 DTE 케이블입니다. V.35 케이블을 실제 보았을 때 DTE 케이블은 핀이 밖으로 나와있는 숫놈이고, DCE 케이블은 숫놈을 꽂을 수 있게 되어있는 암놈이니까 금방 알아보실 수 있을 겁니다.

![](./img/2-1/ex6.jpg)

그러나 실습 환경에서는 중간에 DSU를 놓고 또 전용선을 연결하는 이러한 실제 구성이 불가능하기 때문에 전용선과 DSU/CSU를 생략하고 직접 라우터 대 라우터를 V.35 케이블을 이용해서 연결합니다.

이때 중요한 것은 라우터 A나 라우터 B 둘 중 하나가 반드시 DCE로 동작해야 한다는 것입니다. 즉 둘 다 DTE가 아니라 하나는 DTE, 그리고 나머지 하나는 DCE로 동작해야 한다는 것입니다.

그림에서는 라우터 A가 DTE로 동작하고 라우터 B가 DCE로 동작하게 되어 있습니다. (케이블이 서로 다르다는 것을 알 수 있습니다.) 이때 어느 쪽 라우터가 DCE이고, 어느 쪽 라우터가 DTE인지를 알아보는 방법은 물론 케이블을 보면 알겠지만 라우터에서 명령으로도 확인이 가능한데, 그 명령은 다음과 같습니다.

![](./img/2-1/ex7.jpg)

여기서 interface는 인터페이스의 종류를 이야기합니다. 그리고 interface-number는 인터페이스별 번호입니다. 예를 들어볼까요?

![](./img/2-1/ex8.jpg)

위에서처럼 show controller 명령을 수행해서 DTE와 DCE를 확인합니다. 일단 DTE, DCE를 확인한 후 DCE 케이블이 연결되어 있는 라우터의 인터페이스 구성 모드로 들어가서 구성 파일에 다음 구성을 추가합니다.

![](./img/2-1/ex9.jpg)

예를 들어 라우터 B의 시리얼 0 인터페이스에 연결된 케이블이 V.35 DCE 케이블인 경우 라우터 B의 시리얼 0 인터페이스 구성 모드로 들어가서 Clockrate를 세팅해 주는 겁니다. DCE 장비는 클록을 제공해야 하기 때문에 이렇게 Clockrate 값을 넣어주는 겁니다.

여기서 세팅해주는 Clockrate 값은 바로 두 라우터 간의 회선 속도가 됩니다. 따라서 앞에서처럼 56000이라고 세팅한 경우에는 56Kbps의 속도로 두 라우터가 연결되었다고 생각하면 됩니다.

일단 두 라우터가 이처럼 Back-to-Back 구성으로 연결되고 나면 이제부터는 전용선으로 연결된 구성과 똑같이 사용할 수 있습니다. 따라서 라우터의 실습 환경에서는 꼭 필요한 구성입니다.

이제 Back-to-Back에 대해서 이해가 가시죠? 실은 저도 지금 Back-to-Back 구성으로 라우터를 세팅하고 여러분께 설명드리고 있는 겁니다.



## RIP와 함께 춤을?

자, 이번에는 본격적으로 RIP에 대해서 알아보겠습니다. 일반적인 성격은 앞에서 알아보았고 이번에는 RIP를 이용해서 라우터를 구성할 때의 명령어 형식과 실제 예를 통한 RIP 라우팅의 구현, 그리고 구현한 다음에 잘 돌아가는지를 무엇으로 확인해 보나 하는 것들을 공부해 보겠습니다.

먼저 RIP에 대한 명령어 형식입니다. 명령어를 알아야 RIP를 동작시킬 수 있겠죠?

![](./img/2-1/ex10.jpg)

이 두 가지 명령이 전부입니다. 정말 쉽겠죠?

먼저 첫 번째 줄에 있는 router rip란 명령은 프롬프트를 보셔서 아시겠지만 '일반 구성 모드(Router(config)#)'에서 내리는 명령입니다. 이 명령은 이제부터 RIP 라우팅을 사용하겠다는 뜻입니다. 그러니까 RIP 라우팅 프로토콜을 쓰시려면 꼭 넣어줘야 하는 명령입니다.

두 번째 명령은 항상 'router 구성 모드'에서 내려줘야 하는 명령입니다. 즉 이 명령을 하기 전에는 반드시 router rip라는 명령을 먼저 내려준 후 Router(config-router)# 모드로 들어와서 내리는 명령입니다. 이 명령은 RIP 라우팅에 참가하는 네트워크를 지정해 주기 위해서 사용하는 명령입니다.  
여기서 network-number가 바로 RIP로 라우팅해 줄 네트워크가 됩니다.

이때 주의하셔야 할 사항이 있습니다. RIP와 같은 라우팅 프로토콜은 네트워크 넘버를 입력할 때 서브넷 마스크는 입력하지 않습니다. 즉 RIP는 Classful하게 모든 네트워크를 인식한다는 것입니다. 예를 들어 내가 사용하는 라우터에 이더넷 0에 배정한 네트워크가 150.150.100.0 255.255.255.0이라고 가정해 보겠습니다.  
서브넷 마스크는 완전히 이해하고 계시겠지만 150.150.100.0/24는 클래스 B를 서브넷 마스크해서 클래스 C처럼 쓰고 있는 겁니다. 이때 라우팅 프로토콜은 RIP를 쓴다고 가정하고 앞에서 배운 대로 명령을 입력하겠습니다.

![](./img/2-1/ex11.jpg)

하지만 이렇게 입력을 해도 RIP에서는 네트워크를 150.150.0.0으로 인식해 버립니다. 따라서 show running-config을 수행해 보면 다음과 같이 보이게 됩니다.

![](./img/2-1/ex12.jpg)

자, 이렇게 되면 어떤 문제가 발생할까요? 네, 맞습니다. 이렇게 되면 RIP를 수행하고 싶은 곳은 150.150.100.0뿐인데, 150.150.0.0으로 모든 네트워크가 들어가서 원하지 않는 네트워크까지 RIP가 수행하게 되는 것입니다.

명령어 형식은 대충 배웠으니까 이번에는 실습을 통한 RIP 구성을 한번 해볼까 합니다.

예를 들어 본사는 서울에, 그리고 지사는 부산에 있는 어떤 회사가 있다고 가정해보겠습니다. 이 회사의 본사에는 PC와 서버를 합쳐서 약 200대 정도의 장비가 있고 부산 지사에는 약 150명 정도가 PC를 쓰고 있다고 가정하겠습니다.

자, 여러분이 이제 이 두 사무실 간에 네트워크를 설치해 주기 위해서 라우터 앞에 앉았습니다. 그리고 일단 여기서는 인터넷에 대한 접속은 없다고 가정하겠습니다. 단순히 두 사무실 간에 네트워크를 연결하는 겁니다.

자, 이때 준비물은 뭐가 있을까요?

그림을 보면서 설명을 드리겠습니다. 일단 두 사무실의 내부에는 네트워크가 되어 있다는 가정하에 두 사무실을 연결하기 위한 라우터 2대(라우터 A와 라우터 B)와 DSU 또는 CSU 2대가 필요합니다.(그림에서 DSU/CSU 부분은 생략되었습니다.)

![](./img/2-1/ex13.jpg)

여기서 보이는 것처럼 서울 본사와 부산 지사의 네트워크를 구축하기 위해서는 총 3개의 네트워크가 필요합니다. 즉 서울 내부 네트워크, 부산 내부 네트워크, 그리고 마지막으로 시리얼 라인(WAN 구간)에 대한 네트워크입니다. 이렇게 네트워크를 나누는 것은 각 구간별로 서로 다른 네트워크가 있어야 하기 때문입니다.

또 한 가지 여기서 여러분이 아셔야 할 것은 시리얼 구간, 즉 전용선 구간에도 하나의 네트워크가 소모된다는 것입니다. 따라서 이 구간에는 지금처럼 서브넷 마스크 255.255.255.0을 사용하는 것은 IP 주소를 낭비하게 되는 것입니다. 만약 공인 IP 주소를 사용한다면 더욱 더 문제가 됩니다.  
하지만 여기선 이 부분에 대한 이야기는 일단 건너뛰도록 하겠습니다. 나중에 VLSM(Variable Length Subnet Mask)을 설명하면서 설명드리도록 하겠습니다. 우선은 모두 같은 서브넷 마스크를 사용하기로 했다고 가정하겠습니다.

라우터를 구성하기 전에 항상 위 그림과 같은 구성도를 만드는 것이 중요합니다. 라우터를 구성하다 보면 구성이 잘 생각나지 않거나 아니면 엉뚱한 IP 주소를 잘못 입력하는 경우가 있기 때문에 항상 그림을 먼저 그리고 라우터를 구성하는 버릇을 들이기 바랍니다.

구성도에는 라우터의 이름과 어떤 식으로 서로 연결되어 있는지에 대한 내용, 그리고 IP 주소가 들어가면 됩니다. 서울, 부산 네트워크의 경우는 최대 인원이 250명을 넘지 않기 때문에 각 네트워크에 클래스 C 하나씩을 배정했습니다.

자, 이제 라우터 구성을 직접 보면서 설명드리겠습니다. 라우터 구성에서 중요한 부분만 써보면 아래와 같습니다.

![](./img/2-1/ex14.jpg)

이 부분이 본사 라우터의 이더넷 부분입니다. 즉 이 회사의 본사는 203.140.100.2~203.240.100.254까지의 IP 주소를 사용하겠죠?(203.240.100.1은 라우터에 이미 부여했고, 203.240.100.255는 브로드캐스트 주소입니다.)

![](./img/2-1/ex15.jpg)

이 부분이 본사 라우터의 시리얼, 즉 부산과 접속되는 인터페이스 입니다. 여기서도 보이지만 이더넷과 시리얼 인터페이스는 서로 다른 네트워크여야 한다는 것을 항상 잊지 말기 바랍니다.

![](./img/2-1/ex16.jpg)

이 부분이 RIP에 대한 구성입니다. 정말 간단하죠?

RIP 라우팅에 참여하는 네트워크를 넣어준다고 했으니까 여기서는 본사 라우터의 이더넷 부분(203.240.100.0)과 시리얼 부분(203.240.150.0)을 포함시키면 됩니다. 현재 보이는 것처럼 네트워크는 Classful하게 들어가기 때문에 따로 서브넷 마스크를 입력하지 않도록 되어 있습니다.

이렇게만 하면 본사 라우터의 모든 구성은 끝나게 됩니다.

자, 그럼 전체 라우터의 구성을 한번 볼까요?

![](./img/2-1/ex17.jpg)

![](./img/2-1/ex18.jpg)

이제는 라우터의 구성만 보셔도 아시겠죠? 이렇게 점점 라우터의 구성과 친해지는 것이 중요합니다.

자, 이제 서울 본사 라우터의 구성은 마무리되었습니다. 과연 제대로 구성되었는지 한번 확인해 보고 싶으시죠? 몇 가지 명령이 있습니다.

먼저 show ip protocol이란 명령이 있습니다.

![](./img/2-1/ex19.jpg)

위와 같이 라우터의 프리빌리지드 모드(운영자 모드)에서 show ip protocol이란 명령을 내리면 현재 IP에서 동작하고 있는 라우팅 프로토콜이 보입니다. 우리가 서울 본사에 있는 라우터에 RIP를 동작시켰기 때문에 맨 윗 줄에 Routing Protocol is "rip"라는 말이 보입니다.  
그 다음에는 라우팅 정보를 얼마 만에 한 번씩 업데이트하는가를 보여줍니다. RIP는 매 30초에 한 번씩 업데이트가 발생하는데, 지금 마지막으로 업데이트한 지 15초가 지났다고 나옵니다. 그러니까 앞으로 15초만 더 있으면 한 번 더 업데이트되겠네요.

이때 만약 어떤 곳으로부터 30초 동안에 업데이트 정보를 받지 못했다면 어떻게 될까요? RIP 환경에서 라우터는 180초 동안은 상대측으로부터 정보를 받지 못해도 느긋하게 기다립니다.  
즉 RIP 업데이트가 6번 들어오지 않을 때까지는 기다려주는 겁니다. 이 시간을 'Invalid Time'이라고 합니다(Invalid after 180 seconds). 그런데 180초가 지나도 상대에서 업데이트가 들어오지 않게 되면 라우터는 Hold Down 상태로 들어갑니다.  
이때부터 라우터는 상대편이 다운됐을거라고 생각하게 되고 'possibly down'이라는 메시지를 라우팅 테이블에서 보여줍니다.

그리고도 1분 동안 상대로부터 연락이 없으면 라우터는 이 경로가 죽었다고 생각하고 라우팅 테이블에서 이 경로에 대한 정보를 지워버리게 되는데, 그 시간이 바로 'Flush Time'입니다(flushed after 240).

그 다음에 보이는 Default version control: send version 1, receive any version이란 말은 RIP의 버전에 대한 정보를 보여주고 있습니다. 즉 RIP의 여러 가지 단점을 보완해서 새로 나온 RIP가 RIP version 2인데, 현재 우리는 RIP 버전 1을 사용하고 있다는 것을 보여주고 있습니다.  
아무튼 RIP 버전 1에서 보낸 정보는 어떤 버전이든지 받아볼 수 있지만, RIP 버전 2에서 보낸 정보는 오직 RIP 버전 2에서만 이해할 수 있다는 것을 알려주고 있습니다.

그 다음에 보이는

![](./img/2-1/ex20.jpg)

은 현재 라우터에서 RIP가 적용되고 있는 네트워크를 보여줍니다. 우리가 이더넷 0쪽과 시리얼 0쪽에 RIP를 적용했으니까 이렇게 보이는 겁니다.

그럼 라우팅 정보는 어디로부터 얻어오고 있을까요? 거기에 대한 정보를 보여주는 것이 바로 아래에 나와있는 내용입니다. 즉 다음과 같습니다.

![](./img/2-1/ex21.jpg)

여기서 203.240.150.2가 바로 라우팅 정보를 읽어오는 곳입니다. 여기가 어딘지는 아시죠? 바로 부산 라우터의 시리얼 부분입니다.

맨 마지막 줄에 Distance, 즉 거리가 120이라고 되어 있네요. 이것을 'Administrative Distance'라고 합니다. 즉 라우팅 정보에 대한 신뢰성 정도라고 생각하면 됩니다. 이 디스턴스 값이 작으면 작을수록 라우터는 그 경로를 신뢰합니다.  
참고로 스태틱 라우팅 정보는 디스턴스 값이 1입니다. 따라서 같은 목적지에 대해서 RIP로 찾아낸 길과 스태틱으로 찾아낸 길, 이렇게 2개의 길이 존재한다면 라우터는 스태틱으로 찾아낸 길쪽으로 데이터를 내보내게 됩니다. 디스턴스가 작을수록 더 신뢰하기 때문입니다.

자, 이번에는 라우팅 테이블을 한번 확인해 볼까요? 라우팅 테이블을 보려면 show ip route라는 명령이 사용됩니다.

![](./img/2-1/ex22.jpg)

라우팅 테이블이 보입니다. 바로 맨 마지막 3줄이 라우팅 테이블입니다.

![](./img/2-1/ex23.jpg)

여기에서 맨 앞에 있는 R은 RIP로 찾아낸 길을 뜻합니다. 그 다음에 나오는 203.240.200.0은 목적지 네트워크입니다. 즉 찾아낸 목적지를 뜻합니다. 이때 뒤에 나오는 /24의 의미는 255.255.255.0, 즉 서브넷 마스크를 이진수로 바꾸었을 때 1의 숫자를 의미하고 120은 RIP의 디스턴스 값을 나타냅니다.  
그 뒤에 나오는 1은 코스트를 의미하는데, RIP에서는 코스트가 홉카운트니까 1홉 떨어져서 목적지가 있다는 의미로 해석하면 될 것 같네요.

![](./img/2-1/ex24.jpg)

이것은 앞에 있는 C가 의미하듯이 라우터에 붙어 있는 네트워크라는 것을 알려줍니다. (C는 connect를 의미하니까요.)

이번에는 RIP가 동작하는 라우터에서 디버그 명령으로 실제 라우팅 업데이트가 일어나는 것을 한번 살펴보겠습니다. 디버그 명령은 굉장히 유용한 명령이면서도 섣불리 사용하면 라우터에 치명적인 영향을 줄 수 있기 때문에 사용 시에는 각별한 주의가 필요합니다.

또한 디버그 명령을 사용하려면 될 수 있는 한 콘솔에서 명령을 내려주는 것이 좋습니다. 물론 텔넷에서도 디버그 명령을 내릴 수 있지만, 텔넷에서 디버그 명령을 내리는 경우는 terminal monitor라는 명령을 주어야만 텔넷 화면에서 디버그의 결과를 볼 수 있습니다. 꼭 기억해 두기 바랍니다.

또 디버그 명령에서 가장 중요한 것 하나는 디버그 명령 후 결과치를 보고 나서는 반드시 디버그 명령을 꺼줘야 한다는 겁니다.  
디버그를 시작하고 나면 계속 모니터에 여러 가지 내용을 뿌려주기 때문에 라우터에 부담이 너무 많이 가게 되고, 잘못하면 라우터가 다운될 수도 있기 때문에 디버그는 가능한 조금만 사용해야 하고 또 보고난 뒤에는 반드시 꺼줘야 합니다.

디버그를 꺼주는 명령으로는

![](./img/2-1/ex25.jpg)

이 있습니다. 이 두 명령 중 하나를 내리고 나면 모든 디버그가 멈추게 됩니다. (물론 이 명령을 내리고도 잠깐 동안은 디버그 화면이 계속 보입니다. 이것은 시간차라고 생각하면 됩니다. 하지만 곧 멈추니 너무 걱정하지 마세요.)

그런데 막상 디버그를 실시하게 되면 계속 화면에 디버그의 결과가 나오기 때문에 위에서 말씀드린 디버그를 끄는 명령을 사용하기가 굉장히 어렵습니다. (막 화면이 지나가니까 정신이 없어집니다.)  
따라서 디버그를 꺼줄 때는 빨리 끄는 것이 중요한데 이때 사용하는 명령이

![](./img/2-1/ex26.jpg)

입니다. u al은 undebug all을 줄여서 사용하는 명령입니다. 아마 이것을 알아두면 많은 도움이 될 겁니다.

디버그 명령은 한마디로 라우터에서 자기네들끼리 어떤 정보를 주고받는지를 우리가 잠깐 들여다보는 명령입니다. 즉 아래 명령처럼 디버그하고 IP RIP라고 하면 IP RIP에서 라우터끼리 서로 통신하는 것을 보여줍니다.  
명령어를 주는 방식은 그냥 프리빌리지드 모드(운영자 모드)에서 debug ip rip라고 해주면 됩니다. 그럼 명령을 내리는 시점에서부터 라우터에서 rip에 대해서 주고받은 내용을 보여주기 시작합니다. (물론 IP 중에서죠.) 직접 한번 볼까요?

![](./img/2-1/ex27.jpg)

여기서 보면

![](./img/2-1/ex28.jpg)

은 라우팅 업데이트를 05시 25분 34초에 RIP 버전 1로 이더넷 0쪽으로 보냈습니다. 그 다음을 다시 보면

![](./img/2-1/ex29.jpg)

정확히 30초 후에 다시 라우팅 업데이트가 일어난 것을 알 수 있습니다. 즉 라우팅 업데이트는 30초에 한 번씩이라는 걸 알 수 있죠? 나머지도 자세히 비교해 보면 마찬가지라는 것을 알 수 있습니다. 또한 RIP의 송신과 수신에 RIP 버전 1이 사용되고 있다는 것도 알 수 있습니다.

자, 이렇게 해서 RIP에 대한 구성을 완성했습니다. 어떠세요? 그렇게 어렵진 않죠? 사실 RIP의 장점 중 하나가 바로 구성이 단순하다는 것입니다.

그럼 이제 부산 지사의 라우터 구성은 여러분이 직접 할 수 있죠? 한번 해보세요. 제가 부산으로 출장을 보내 드리겠습니다. 그리고 아래에 나온 부산 라우터 구성과 비교해 보세요.

![](./img/2-1/ex30.jpg)

![](./img/2-1/ex31.jpg)



> 알고 갑시다!

구성이 간단한 RIP 라우팅 프로토콜을 이용한 라우터의 구성은 RIP 라우팅을 시작하는 명령 Router RIP와 이 명령 뒤에 오는 network 명령을 이용한다.  
RIP 구성을 마친 후에 라우터에서 RIP를 확인해 보는 명령은 show ip protocol이 있고, 라우팅 테이블을 보고 싶으면 show ip route 명령을 사용하면 된다. 또 디버그를 사용할 때는 가능한 콘솔 화면에서 하고 텔넷에서 할 때는 terminal monitor란 명령이 필요하다. 그리고 더 중요한 건 디버그는 반드시 조금만 보고 꺼줘라. 디버그를 끄는 명령은 u ai이다.



라우터의 구성은 여러분이 보시는 대로 그렇게 어렵지 않습니다. 사실 라우터를 구성하다 보면 우리가 책에서 접하지 못한 여러 상황을 만나게 됩니다. 예를 들어 전용선의 문제로 라우터를 동작하지 못하는 경우나 서로 다른 제품의 라우터 연결 시에 발생하는 문제는 여러분이 엔지니어가 되어서 직접 겪어봐야 해결할 수 있는 것들입니다.

다만 제가 드리고 싶은 말씀은 이런 상황에서 라우터 구성에 대한 확신마저도 없다면 오히려 제대로 구성한 라우터의 구성을 바꾸어서 더 큰 실수를 할 수도 있다는 것입니다. (바로 제 경험담입니다.) 여러분은 이제 라우터의 구성에 대한 확신을 가지셨을 테니 혹시 문제가 발생한다고 해도 전혀 당황하지 않으실 거라고 믿습니다.

이번에는 여러분이 직접 RIP를 이용해서 구성을 해보겠습니다. 아래 그림은 여러분이 그동안 많이 보아온 그림입니다. 여기에서 PC A와 PC B간에 있는 라우터를 RIP로 구성해서 두 PC가 통신이 되도록 해보는 겁니다.

![](./img/2-1/ex32.jpg)

먼저 라우터 C의 구성에 대한 주요 부분입니다.

![](./img/2-1/ex33.jpg)

즉 Ethernet 0 인터페이스에 IP 주소를 구성대로 할당하고 RIP를 활성화한 후 RIP가 수행될 네트워크를 넣었습니다.

다음은 라우터 A입니다.

![](./img/2-1/ex34.jpg)

라우터 A는 조금 다르네요. 특별히 다른 것은 아니지만 우선 시리얼 인터페이스쪽을 보면 clockrate가 세팅되어 있는 것이 보일 겁니다. 이제 이것이 왜 있는 줄 아시겠죠? 네, 맞습니다. 바로 백투백(Back-to-Back)구성 때문에 들어간 겁니다.  
그리고 Fast Ethernet0/0과 serial 2/0, 2/1을 세팅하고 이들 네트워크를 모두 RIP 네트워크로 정의했습니다. 역시 어렵지 않죠?

다음은 라우터 B입니다.

![](./img/2-1/ex35.jpg)

![](./img/2-1/ex36.jpg)

여기 세팅에서는 한 가지 다른 점이 있습니다. 앞에서도 말씀드렸지만 Ethernet 0 인터페이스의 세팅을 보면 Ethernet 0에 세팅된 네트워크는 172.70.100.0/24 네트워크로 172.70.0.0을 서브네팅해서 사용했습니다.  
그런데 밑에 구성된 RIP 네트워크 세팅에서는 172.70.100.0이 아니라 172.70.0.0으로 Classful하게 들어갔습니다. 이게 바로 RIP의 한계입니다.

일단 모든 라우터에 구성을 마쳤으면 검증을 시작해보겠습니다.

라우터 C에서 172.70.100.0 네트워크에 접속되는가를 보려면 간단히 핑 테스트를 해보면 되지만, 우선은 라우팅 테이블에 172.70.100.0이 있는지를 확인하겠습니다.

![](./img/2-1/ex37.jpg)

위와 같이 172.70.0.0 네트워크가 라우터 C의 시리얼 0 인터페이스를 통해서 연결되어 있음을 보여줍니다. 일단 라우터 C에서 172.70.0.0 네트워크가 보이니까 이번에는 라우터 B에서 150.150.0.0 네트워크가 보이는지를 확인하면 됩니다. 그럼 라우터 B에 가서 명령을 내립니다.

![](./img/2-1/ex38.jpg)

![](./img/2-1/ex39.jpg)

이제 두 라우터에서 양쪽 네트워크를 인식하고 있는 것을 알았습니다. 핑은 해보나마나 당연히 되겠죠? 그래도 한번 해볼까요?

![](./img/2-1/ex40.jpg)

RIP로의 구성이 끝났습니다. 여러분도 RIP가 그리 어려운 프로토콜이 아니란 것을 이제 아시겠죠?



> 네트워크 플러스+

### 같은 길을 두 사람이 알고 있다면 누구 말을 들어야 하지?

### - Administrative Distance

앞에서도 잠깐 다룬 이야기입니다. 만약 우리가 한 라우터에 라우팅 프로토콜을 2개 이상 사용해야 한다면 어떤 상황이 일어날까요?

라우팅 프로토콜이 뮈냐구요? 라우팅 테이블을 만들고 유지하는 프로토콜, 즉 Static Routing Protocol, RIP, IGRP, OSPF, EIGRP 같은 거 말입니다.

네? 한 라우터에서 뭐하러 라우팅 프로토콜을 2개씩이나 쓰냐구요?

근데 그럴 일이 생깁니다. 라우터 구성을 하다 보면 말입니다. 왜냐하면 내 라우터의 양쪽에 다른 라우터가 연결되어 있다고 가정할 때 왼쪽에 있는 라우터는 RIP를 쓰고 오른쪽에 있는 라우터는 IGRP를 쓴다면 내 라우터는 중간에 있으니까 둘 다 써야만 합니다.  
즉 내 양옆에 있는 사람이 한 명은 영어를 쓰고 한 명은 중국말을 하면 저는 중간에서 영어도 쓰고 중국말도 써야 서로가 대화를 할 수 있는 것처럼 말입니다.

아무튼 이런 상황이 되어서 우리가 한 라우터에 2개 이상의 라우팅 프로토콜을 쓰게 되었다고 가정을 해보겠습니다.

이런 경우에 내가 어떤 경로, 즉 길에 대한 정보를 얻으려고 보니까 RIP를 쓰는 라우터도 그 길에 대한 정보를 알고 있고, 또 IGRP를 쓰는 라우터도 그 길을 알고 있는 겁니다. 즉 내가 일본 가는 경로를 물어보니까 미국 사람도 설명을 해주고 중국 사람도 설명을 해주는데, 설명이 서로 다른 겁니다. 그렇다면 나는 어떤 사람의 말을 믿어야 할까요?

라우터로 다시 돌아가서 말씀드리면 어떤 경로 정보를 RIP와 IGRP에서 동시에 받는다면 어떤 라우팅 프로토콜에서 온 정보를 이용해서 경로를 찾을까 하는 것입니다.

이에 대한 답은 바로 Administrative Distance 값입니다. 아래 그림에 시스코 라우터에서의 DIstance(디스턴스) 값이 나와 있습니다.

![](./img/2-1/ex41.jpg)

역시 뭐니뭐니해도 가장 작은 값 0을 가진 것은 그 라우터가 직접 가지고 있는 인터페이스입니다. 예를 들어 라우터 C의 경우 Ethernet 0 인터페이스나 serial 0 인터페이스 등이 여기에 속합니다.  
이런 인터페이스는 우리가 show ip route에서 보았을 때 c로 보입니다.

![](./img/2-1/ex42.jpg)

또 하나 디스턴스 값이 0이 되는 것이 있는데, 그것은 인터페이스를 이용해서 스태틱 라우트 명령을 준 경우입니다. 우리가 일반적으로 사용하는 스태틱 라우트 명령은

![](./img/2-1/ex43.jpg)

와 같이 맨 뒤에 어디를 통해서 갈 것인가를 IP 주소를 입력해서 정의합니다. 이렇게 정의한 스태틱 라우트 명령은 디스턴스 값이 1이 되지만, 예를 들어

![](./img/2-1/ex44.jpg)

이라고 인터페이스를 입력하는 경우는 디스턴스 값이 0이 되어야 된다는 것입니다. 이때 입력하는 인터페이스는 자신의 인터페이스가 됩니다.

그 다음으로 우리가 눈여겨 보아야 할 것은 BGP, IGRP, RIP, OSPF, EGRP 등입니다. 이것들은 가능한 외워두면 도움이 될 겁니다.

지금까지 알아본 것과 같이 각 라우팅 프로토콜별로 이러한 디스턴스 값이 있는데, 이 값이 작으면 작을수록 신뢰성이 더 높습니다. 따라서 2개의 라우티 프로토콜 중에서 디스턴스 값이 작은 쪽의 말을 듣게 됩니다.  
현재 우리 라우터에 돌아가고 있는 프로토콜에 대한 디스턴스 값은 show ip protocol을 하면 보인다는 것을 이제는 다 아실 겁니다.

이제 Administrative Distance에 대해서 이해가 되시죠? 복잡한 네트워크 구성에서는 이 개념을 이해하는 것이 중요합니다. 생각하지 못한 많은 문제를 찾아낼 수 있는 건 이처럼 기본에 충실한 것이기 때문입니다.



## DIstance-Vector 라우팅 알고리즘에서의 문제점과 해결책

이번에는 디스턴스 벡터 알고리즘의 문제점에 대한 고찰을 해볼까 합니다. 미리 말씀드리지만, 그렇다고 디스턴스 벡터 알고리즘이 문제점만 있는 것은 아닙니다. 장점도 많지만 여기에서는 문제점만을 집중적으로 알아보려는 것입니다.  
그리고 마지막에서 그 해결책에 대한 것들도 함께 알아보겠습니다.

디스턴스 벡터의 문제점이라면 가장 먼저 떠오르는 것은 바로 '시간'입니다. 즉 한 번 배운 라우팅 테이블을 계속 전달하기 때문에 업데이트가 모든 네트워크에 전달되는 시간(이것을 보통 '컨버전스 타임(Convergence Time)'이라고 합니다.)이 많이 걸린다는 것입니다. 따라서 이것 때문에 우리가 흔히 이야기하는 루핑이 발생할 수 있습니다.

![](./img/2-1/ex45.jpg)

먼저 위 그림을 보겠습니다. 라우터 A는 왼쪽 네트워크로부터 라우팅 테이블의 업데이트를 받았습니다. 즉 왼쪽에 연결된 네트워크의 링크에 변화가 감지된 것입니다. 그럼 이제부터 라우터 A는 자신의 라우팅 테이블을 변경하기 위한 작업을 시작합니다.  
새로운 링크가 생겼다면 그것을 넣고, 만약 어떤 네트워크가 끊어졌다면 그 네트워크를 라우팅 테이블에서 지울 것입니다.

이런 작업을 통해서 라우터 A는 새로운 라우팅 테이블을 만들게 됩니다. 그리고 라우팅 업데이트 시간이 왔습니다. RIP에서는 30초에 1번 라우팅 테이블을 업데이트한다고 배운 것을 기억할 겁니다. 마찬가지로 디스턴스 벡터(DIstance-Vector) 알고리즘은 업데이트 주기를 가지고 있습니다.

예를 들어 이 주기가 30초라고 가정하면 라우터 A는 30초 후에 변경된 라우팅 테이블을 라우터 B에 보내고 라우터 B는 다시 30초 후에 라우터 C에 이 정보를 보내주는 것입니다. 따라서 라우터 C는 라우터 A가 라우팅 테이블 변화를 인지한 지 60초 후에야 비로소 네트워크의 변화를 인지할 수 있게 되는 것입니다.

만약 라우터 C 뒤에 또 다른 라우터가 있다면 어떨까요? 그렇습니다. 라우터가 네트워크 변화를 인지하는 데 많은 시간이 걸린다는 것을 이제 여러분도 직접 느끼셨을 겁니다.

이번에는 좀 더 구체적인 예를 들어서 설명해 보겠습니다.

![](./img/2-1/ex46.jpg)

위 그림은 각 라우터별로 현재 가지고 있는 라우팅 테이블을 보여주고 있습니다. 물론 라우팅 테이블이 정확히 이렇게 생기진 않았습니다. 개념적으로 이해하기 바랍니다.  
맨 앞에 있는 것이 목적지 네트워크이고, 그 다음은 어디를 통해서 갈 것인가를 알려주는 테이블입니다. 그리고 맨 마지막이 홉 카운트 정보입니다. RIP의 라우팅 테이블과 유사하죠?

아무튼 이 상태에서는 모든 라우팅 테이블이 정상적입니다. 라우터 A, B, C 모두 동일한 정보를 가지고 있습니다. 이때 라우터 A에 연결되어 있는 5.1.0.0 네트워크에 문제가 발생했습니다. 즉 5.1.0.0 네트워크가 다운되었습니다.

![](./img/2-1/ex47.jpg)

라우터 A는 즉시 자신의 라우팅 테이블에 5.1.0.0이 다운이라고 업데이트를 합니다. 하지만 아직 업데이트 주기가 되지 않았기 때문에 라우터 B나 라우터 C는 이 정보를 알지 못합니다. 이때 라우터 B가 라우팅 테이블을 업데이트했습니다.

여기에는 아래 그림에서 보는 것처럼 5.1.0.0 네트워크 정보도 들어 있습니다. 네트워크 5.1.0.0에 대한 라우팅 정보를 라우터 B로부터 받은 라우터 A는 5.1.0.0 네트워크를 라우터 B를 통해서 갈 수 있다고 생각하고 자신의 라우팅 테이블을 바꿉니다.  
즉 5.1.0.0 네트워크는 라우터 B로 갈 수 있는데 홉 카운트는 2라구요. 이제부터 정말 말도 안 되는 일이 벌어지고 있는 겁니다.

![](./img/2-1/ex48.jpg)

이번에는 라우터 B가 라우터 A로부터 온 네트워크 5.1.0.0에 대한 정보를 보니 홉 카운트가 2로 바뀐 것을 알았습니다. 어차피 라우터 B는 라우터 A를 거쳐서 5.1.0.0 네트워크를 가야 하기 때문에 자신의 홉 카운트를 3으로 바꾸게 됩니다. (어처구니 없죠?) 그렇게 되니 라우터 B의 뒤에 있는 라우터 C는 5.1.0.0 네트워크에 대한 자신의 홉 카운트를 4로 바꾸게 되는 겁니다.

![](./img/2-1/ex49.jpg)

이런 식으로 라우팅 테이블은 계속 루핑을 돌기 시작하는데, 결국 죽어있는 네트워크로 향하는 데이터는 빙글빙글 돌기만 할 뿐 목적지에 도착하지 못하기 때문에 네트워크에 엄청난 트래픽이 발생할 뿐 아니라 라우팅 테이블이 꼬이게 되어 제대로 된 라우팅을 수행할 수 없게 됩니다.

이처럼 라우팅에 루핑이 발생하는 이유는 한 라우터가 라우팅 정보에 대한 모든 정보를 가지고 있지 못하고, 또 이웃 라우터로부터의 업데이트가 느리게 이루어지기 때문입니다.

따라서 이런 문제를 방지하기 위한 대책이 필요한데, 여기서는 그 대책에 대해서 한번 알아볼까합니다.

맨 먼저 Maximum Hop Count를 이용한 방법입니다. RIP 라우팅 프로토콜의 경우는 최대 홉 카운트를 15로 규정하고 15를 넘어가는 라우팅 경로에 대해서는 unreachable로 간주합니다.  
그리고 flush time이 지난 후에는 라우팅 테이블에서 아예 삭제해 버립니다. 이렇게 최대 홉 카운트를 정해놓으면 라우팅의 루핑이 발생하더라도 16까지 이르게 되면 멈출 수 있습니다. 그러나 RIP의 최대 홉 카운트 제한은 15홉을 넘어서는 경로에 대해서는 아예 도달할 수 없기 때문에 요즘처럼 네트워크 규모가 커질 경우 치명적인 약점을 드러내게 됩니다.

이번에는 Hold Down Timer를 이용한 루핑 방지법입니다.

아래 그림에서 라우터 E에 붙어있는 네트워크 A가 다운되었다고 가정해보겠습니다. 라우터 E는 네트워크 A가 다운되었다는 것을 라우터 A에 알렸습니다. 그러면 라우터 A는 네트워크 A에 대한 Hold Down 타이머를 시작합니다.  
만약 이때 라우터 B가 라우팅 테이블을 업데이트하면서 라우터 A에 네트워크 A를 자신을 통해서 갈 수 있는데, 홉 카운트 4라고 이야기한다면 라우터 A는 이 정보를 무시합니다.

![](./img/2-1/ex50.jpg)

즉 Hold Down 타이머가 동작하고 있는 동안에는 외부에서 해당 네트워크에 대한 라우팅 경로 정보를 받았을 때 원래 가지고 있던 메트릭 값(목적지까지의 거리에 대한 값으로, RIP의 경우는 Hop 카운트가 됩니다.)보다 큰 값이 들어오면 무조건 무시합니다.  
그리고 Hold Down 카운터가 종료되거나 목적지에 대한 새로운 경로가 지금 가지고 있던 메트릭과 같거나 좋은 경로가 들어올 때만 이웃 라우터로부터의 업데이트를 받아들입니다.

아래 그림에서 네트워크에 A에 대해서 라우터 A는 홉 카운트 1을 가지고 있었습니다. 이때 아직 Hold Down 타이머가 끝나지 않은 상태에서 라우터 B가 네트워크 A에 대한 더 나쁜 홉 카운트(여기서는 4)를 가지고 업데이트를 했습니다.  
이렇게 되면 라우터 A는 라우터 B의 업데이트를 무시합니다. 아까 배운 규칙, 메트릭 값이 원래 값과 같거나 더 좋지도 않을 뿐만 아니라 Hold Down 타이머가 종료되지도 않았기 때문입니다.

라우터 A가 라우터 B와 라우터 D쪽으로 업데이트를 하게 되면 이제 라우터 B와 D도 네트워크 A에 대해서 Hold Down 타이머를 작동시킵니다.

![](./img/2-1/ex51.jpg)

이번에는 라우터 B와 D도 네트워크 A에 대해서 Hold Down 타이머가 걸렸습니다. 이때 라우터 C가 라우터 B나 라우터 D에 네트워크 A를 홉 카운트 3으로 갈 수 있다고 업데이트를 해도 이들 라우터는 이 업데이트를 무시합니다.  
홉 카운트 3은 그들이 가지고 있는 네트워크 A에 대한 메트릭 값과 같거나 좋은 값이 아니기 때문입니다. 이로써 Hold Down 타임 동안 네트워크의 모든 라우터들은 네트워크 A가 다운된 것을 인식하는 것입니다.  
이러다가 네트워크 A가 살아나게 되면 라우터 A는 라우터 B와 D에 홉 카운트 1로 네트워크 A에 갈 수 있다고 알리게 되고 라우터 B와 D는 Hold Down 타이머를 풀고 업데이트를 받아들이는 것입니다.

어떠세요? Hold Down 타이머가 이해가세요? 조금 어렵게 느꼈을지도 모르겠습니다. 한마디로 Hold Down 타이머는 어떤 경로가 죽었다고 판단하면 이 경로에 대한 상태를 바로 바꾸지 않고 일정 시간이 지난 다음에 바꾸겠다는 것입니다.  
이 일정 시간은 바로 모든 라우터들이 그 경로가 죽었다는 것을 인식하는 정도라고 생각하면 됩니다.

이번에는 스플릿 호라이즌(Split Horizon)입니다. 이건 또 뭐죠?

지금 배우실 스플릿 호라이즌은 아주 중요한 개념입니다. 네트워크를 설계할 때마다 약방의 감초처럼 나오는 말입니다. 따라서 아무리 말이 이상하고 처음 들어본다고 하더라도 스플릿 호라이즌만큼은 꼭 알아두기 바랍니다.

![](./img/2-1/ex52.jpg)

스플릿 호라이즌은 한마디로 말하면 라우팅 정보가 들어온 곳으로는 같은 정보를 내보낼 수 없다는 것입니다.  
즉 위 그림에서 라우터 A는 네트워크 A에 대한 정보를 다시 라우터 E쪽으로는 내보낼 수 없다는 것입니다. 이러한 스플릿 호라이즌이 뜻하는 바는 만약 하나의 라우터가 어느 네트워크 정보를 인접한 라우터에서 받았다면, 그 인접한 라우터가 그 네트워크에 더 가까이 있을 것이 분명하며, 이러한 정보를 다른 라우터들로부터 더 이상 받을 필요가 없다는 것입니다.

여기에서 라우터 A가 모든 라우팅 업데이트를 라우터 E쪽으로 보내지 않는 것은 아닙니다. 다만 네트워크 A에 대한 라우팅 정보만 보내지 않는 것입니다.  
스플릿 호라이즌에 대해서 또 하나 알아두셔야 할 점은 스플릿 호라이즌은 두 라우터 간의 루핑만을 막기 위해서 만들어진 기술이라는 것입니다.  
따라서 전체 라우터 네트워크의 루핑을 스플릿 호라이즌을 가지고 막는 것은 어렵습니다.

이번에는 라우트 포이즈닝(Route Poisoning)에 대해서 알아보도록 하겠습니다. 라우트 포이즈닝은 뭔가 '극약 처방' 같은 느낌이 나는 말입니다. 여기서 포이즈닝이란, 라우팅 테이블에 극약 처방을 한다는 것입니다.  
아래 그림을 보면 네트워크 A가 다운되자 라우터가 네트워크 A에 대한 메트릭 값을 16으로 바꾸었습니다. 즉 사용할 수 없는 값으로 만들어버린 겁니다. 그 대신 라우팅 테이블에서 지워버리지는 않았습니다.

이때 라우터 A에서 네트워크 A에 대한 업데이트 정보가 들어와도 라우터 E는 그것을 무시합니다. 그리고 나서 라우터 E는 네트워크 A에 대한 메트릭 값을 16으로 해서 내보내는 겁니다. 따라서 라우터 A는 이제부터는 네트워크 A에 대한 메트릭을 16으로 갖게 됩니다.  
이런 식으로 다운된 네트워크를 먼저 무한대치로 바꾸어 버리는 방식이 바로 라우트 포이즈닝이라고 생각하면 됩니다. 이렇게 되면 라우팅 테이블에서 지워버렸다가 잘못된 라우팅 정보를 받는 일을 미리 막을 수 있는 효과가 있습니다.

![](./img/2-1/ex53.jpg)

마지막으로 포이즌 리버스(Poison Reverse)에 대해서 알아보겠습니다. 포이즌 리버스는 스플릿 호라이즌을 약간 변형했다고 생각하면 이해가 쉬울 겁니다.  
또 다른 명칭으로는 '포이즌 리버스 업데이트를 사용한 스플릿 호라이즌(Split horizon with poison reverse update)'이라고도 표기하는 이 방식은 스플릿 호라이즌처럼 라우팅 정보를 보내온 쪽으로 알려주지 않는 것이 아니라 라우팅 정보를 되돌려 보내기는 하되 이 값을 무한대 값으로 쓰는 방식입니다.  
왜 이런 방법을 쓸까 한번 생각해 볼까요?

홉 개수가 무한대라는 뜻은 앞서 다루었듯이 경로를 사용할 수 없다는 것이라서 라우터는 이 경로에 대한 라우팅 업데이트를 무시하는 것이 됩니다.  
따라서 경로의 정보를 아주 없애는 것보다 무한대 홉 값을 포함해서 라우팅 업데이트를 실시한다면 다른 모든 라우터들은 실수로 잘못된 경로 정보를 사용하는 경우를 크게 줄일 수 있기 때문입니다.

![](./img/2-1/ex54.jpg)

하지만 여기서 중요한 것은 스플릿 호라이즌은 포이즌 리버스 기능이 첨가되든지 또는 안 되든지 라우팅 루프를 자기 라우터랑 붙어있는 인접 라우터에서만 방지할 수 있다는 것입니다. 따라서 어느 하나만의 루핑 방지 방법을 사용하는 것이 아니라 여기에 있는 여러 가지 방식을 적절하게 활용하는 것이 중요합니다.

아무튼 시험에서도 꼭 이 부분에 대한 문제가 한두 문제씩은 고정 출연(?)하고 또 제대로 이해해 놓지 않으면 계속 골치가 아픈 부분이므로 여기 나와있는 몇 가지 루핑 방지법에 대해서는 특징을 확실히 알아두기 바랍니다.  
특히 스플릿 호라이즌이라는 것을 확실히 알아두기 바랍니다. 꼭 쓸모가 있으실 겁니다.

자, 그럼 여기까지의 결론을 알아볼까요? 디스턴스 벡터 알고리즘은 쉽고, 간편하고, 또 라우팅 테이블을 적게 사용하는 등 여러 가지 장점이 있지만, 루핑이 발생하기 쉽다는 단점을 가지고 있습니다.  
그래서 사용되는 루핑 방지법이 있는데, 라우팅 메트릭스를 제한하는 방식입니다. RIP의 경우 최대 홉 카운트를 15까지로 제한(16부터는 Unreachable입니다.)하면서 무한의 루핑을 방지하지만, 커다란 네트워크에서는 거리 제한이 있는 약점이 있습니다.  
또한 한 번 다운된 경로에 대해서는 일정 시간 동안 라우팅 업데이트를 받지 않는 홀드 다운이나, 라우팅 정보를 받은 쪽으로는 같은 라우팅 정보를 보내지 않는 스플릿 호라이즌, 그리고 이를 응용한 포이즌 리버스 등 여러 가지 루핑 방지법이 있는데, 이들을 적절히 잘 활용해야 합니다. 여기까지입니다.



> 질문 있어요! QnA

Q 라우터에서 VLSM이라는 말이 많이 나오고, 또 요즘 라우팅 프로토콜은 VLSM이 지원되어야한다고 말하는데, 도대체 VLSM이 뭐고 또 왜 필요한지 알려주세요.

A 네, VLSM(Variable Length Subnet Mask)은 쉽게 말씀드리자면 라우터의 각 인터페이스별로 서브넷 마스크가 전부 제각각인 경우를 말합니다. 즉 여러 종류의 서브넷 마스크를 VLSM이라고 합니다.

그런데 라우팅 프로토콜이 VLSM을 지원하는가, 지원하지 않는가는 요즘 들어 우리가 인터넷을 많이 사용하게 되면서 더욱 더 강조되기 시작했습니다.

왜냐하면 전에는 우리가 인터넷을 사용하지 않아 주로 비공인 IP 주소를 많이 사용했기 때문에 IP 주소를 아껴서 쓸 필요가 없었습니다. 그러니까 대부분은 서브넷 마스크를 그리 중요하게 생각하지 않고 디폴트 서브넷 마스크를 많이 사용하곤 했습니다.

그런데 인터넷을 사용하면서부터 IP 주소가 모자라기 시작하니까 서브넷 마스크의 중요성이 점점 커진 겁니다. 그래서 이더넷쪽 서브넷 마스크와 시리얼쪽 서브넷 마스크를 서로 같게 하지 않게 된 겁니다.  
물론 여러 개의 이더넷이 있는 라우터에서는 같은 이더넷이라도 네트워크의 크기에 따라서 서브넷이 서로 달라지기 시작한 겁니다. 즉 하나의 라우터에 여러 개의 서브넷 마스크가 존재하기 시작한 겁니다.

이렇게 VLSM을 사용하게 되면 IP 주소를 효율적으로 사용할 수 있기 때문입니다.

불행히도 RIP나 IGRP 라우팅 프로토콜은 VLSM을 지원하지 못합니다. 아마도 인터넷시대 이전에 나온 프로토콜이라 그런 모양입니다. 아무튼 이 두 프로토콜은 라우팅 테이블을 서로 주고받을 때 뒤에 붙는 서브넷 마스크를 인식하지 못하기 때문에 당연히 VLSM을 이해 못하는 겁니다.  
따라서 라우터에 VLSM을 세팅하는 경우에는 RIP나 IGRP 라우팅은 사용하지 않아야 합니다. 이 경우에는 스태틱 라우팅 프로토콜이나 EIGRP나 OSPF 같은 라우팅 프로토콜을 권고합니다.

![](./img/2-1/ex55.jpg)

![](./img/2-1/ex56.jpg)

위의 구성을 잠깐 볼까요? 구성에서 Serial 0 인터페이스와 FastEthernet 0 인터페이스의 서브넷 마스크가 다르게 되어 있죠? 이렇게 서로 다른 서브넷 마스크를 가지는 것을 VLSM이라고 합니다.  
그리고 아래 OSPF 구성 세팅을 보면 서브넷 마스크 정보가 뒤에 붙어다니고 있음을 알 수 있습니다. (0.0.07, 0.0.0.255하는 것들이 서브넷 마스크 정보입니다.)

아직은 OSPF를 배우지 않았으니까 그냥 이런 게 있구나라고 생각하고 넘어가도록 하겠습니다.



> 알고 갑시다!

<b>자, 그럼 VLSM에 대한 결론을 내려볼까요?</b>  
VLSM(Variable Length Mask)은 IP 주소의 효율적 이용을 위해 한 라우터에 접속되는 네트워크마다 서로 다른 서브넷 마스크를 줄 수 있도록 만든 규칙이다.  
그런데 RIP나 IGRP는 라우팅 테이블을 서로 주고받을 때 서브넷 마스크 정보를 포함하지 않기 때문에 모두 디폴트 서브넷 마스크만 사용해서 VLSM을 지원하지 못한다. 만약 VLSM을 사용하려면 EIGRP나 OSPF를 사용하면 된다.



## IGRP 라우팅 프로토콜

