# 라우터, 그 속으로 전진!



## 목차

- 네트워크 접근 제어 엑세스 리스트(Access List)
- 엑세스 리스트에서 이것만 알면 다 안다!
- 스탠더드 엑세스 리스트의 시작
- 스탠더드 엑세스 리스트의 예제
- 텔넷포트(VTY Port)에서의 엑세스 리스트
- 익스텐디드 엑세스 리스트(Extended Access List)
- 라우터의 장애 대비 HSRP
- IP 주소의 변환 NAT(Network Address Translation)



## 네트워크 접근 제어 엑세스 리스트(Access List)

여기에서는 우리가 라우터를 할 때 꼭 알아두어야 하는, 그러나 왜 그런지 부담스럽고 조금은 어려운 듯한, 그러나 알고 보면 별로 안 어려운 '엑세스 리스트(Access List)'라는 명령에 대해서 알아보기로 하겠습니다.

그럼 엑세스 리스트란 무엇을 뜻할까요?

엑세스 리스트란 한마디로 말해서 네트워크에 엑세스, 즉 접근을 하게 해줄까, 말까를 미리 정해놓은 리스트라고 생각하면 됩니다. 즉 어떤 녀석에게는 어디만 보여주고, 또 어떤 녀석에게는 어디만 쓰게 해야겠다 하고 정해 놓은 표를 의미합니다.

이러한 엑세스 리스트는 주로 보안을 위해서 사용되고 있습니다. 요즘 들어서는 그 중요성을 모두 인식하는 추세여서 점점 많이 사용되고 있습니다. 물론 라우터에 세팅이 됩니다. 그러니까 당연히 라우터가 볼 수 있는 한계, 즉 네트워크 계층까지만 관리가 되겠죠?  
하지만 요즘은 라우터도 네트워크 계층만 보는 것이 아니라 애플리케이션 계층까지 관리하는 여러 가지 기능이 나와있기 때문에 꼭 네트워크 계층까지만이라고 단정할 수는 없습니다. 그냥 일반적으로는 그렇다는 겁니다.

어떤 분들은 라우터의 엑세스 리스트가 있는데, 왜 파이어월(방화벽) 같은 보안 장비를 따로 두는지 궁금해 합니다.

정확히 말하자면 우리가 배울 라우터의 엑세스 리스트는 모든 침입자를 완벽하게 막아낼 수는 없습니다. 또 관리 자체도 쉽지가 않습니다. 즉 피지컬 계층에서 애플리케이션 계층까지를 완벽하게 말아줄 수 있고 많은 보안 기능을 가지고 있는 전문 보안 서버가 필요하게 된 겁니다.

그런데 요즘은 라우터에도 이러한 파이어월용 소프트웨어를 같이 넣어서 운용할 수 있으니까 혹시 라우터만 가지고 계신 분은 한번 알아보셔도 좋을 것 같습니다.

엑세스 리스트는 앞으로 라우터의 실제 구성할 때뿐만 아니라 여러 가지 자격 시험에서도 빈번히 출제되는 문제이기도 합니다. 혹시 시스코 자격증을 준비하는 분이라면 이번 기회에 꼭 이해해 두기 바랍니다.

자, 그럼 엑세스 리스트를 시작합니다.

엑세스 리스트는 앞에서 말씀드린 대로 라우터의 문지기라고 생각하면 쉽습니다. 이런 엑세스 리스트도 종류가 있습니다. 크게 두 가지라고 볼 수 있는데, 첫 번째가 스탠더드 엑세스 리스트(Standard Access List)라고 또 하나가 있는데, 이것은 자주 쓰이지는 않지만 가끔 시험에 나오곤 합니다.  
이것은 유저 네임(User Name)과 패스워드에 따라 통제가 가능한 엑세스 리스트입니다.

여기에서는 스탠더드 엑세스 리스트(Standard Access List)와 익스텐디드 엑세스 리스트(Extended Access List)까지만 알아보도록 하겠습니다.

자, 스탠더드 엑세스 리스트의 가장 큰 특징은 출입 통제를 할 때 출발지 주소만 참고한다는 겁니다. 즉 스텐더드 엑세스 리스트는 출발지 주소만 가지고 제어를 합니다. 이것이 어디서 왔는가를 본 다음, 통과 여부를 결정하는 것입니다.

하지만 익스텐디드 엑세스 리스트는 출발지도 보고, 목적지도 보고, 또 프로토콜도 보고, 사용 포트 번호도 보고 아무튼 온갖 것을 다 본 다음에 통과 여부를 결정합니다.

라우터 엑세스 리스트를 많이 해본 사람들도 스텐더드 엑세스 리스트를 세팅할 때 출발지 주소를 보는지, 목적지 주소를 보는지 혼동한다거나, 아니면 익스텐디드 엑세스 리스트를 세팅할 때 출발지가 먼저 오는지, 목적지가 먼저 오는지를 가지고 혼동할 때가 있는데, 여러분은 잘 기억해 두기 바랍니다.  
그리고 또 하나 알아두셔야 할 것 한 가지! 이것은 시험에 나오니까 혹시 자격증 공부하는 분은 꼭 알아두기 바랍니다.

만약 엑세스 리스트에 걸려서 못 들어가는 경우 라우터에 어떤 메시지가 나타날까요? 그건 'Host Unreachable'이란 말이 나온다는 겁니다. 나중에도 설명할 기회가 있겠지만 일단은 답이랃로 알아두는 것이 좋습니다.



> 알고 갑시다!

라우터에서 네트워크에 대한 보안을 위해 사용되는 것이 바로 엑세스 리스트라는 것인데, 엑세스 리스트에는 스탠더드 엑세스 리스트와 익스텐디드 엑세스 리스트가 있다(다이내믹 엑세스 리스트도 있지만 여기에서는 일단 생략).   
스탠더드 엑세스 리스트는 무조건 출발지 주소만 보고 결정을 하고, 익스텐디드 엑세스 리스트는 있는 조건은 다 따진다.



## 엑세스 리스트에서 이것만 알면 다 안다!

이번에는 엑세스 리스트에서 가장 중요한, 즉 엑세스 리스트의 노른자를 배워보도록 하겠습니다. 사람들이 엑세스 리스트를 하면서 어렵다고 하는 이유도, 그리고 엑세스 리스트에서 자꾸 에러가 걸리는 이유도 사실은 이 규칙을 완전하게 이해하고 있지 못하기 때문입니다.

또 알고 있다고 하더라도 잊어버리기 쉬우므로, 이번에 정말 완벽하게 이 규칙을 자신의 것으로 만들기를 바랍니다.

엑세스 리스트에서 가장 중요한, 잊어버리면 안 되는 4가지 규칙을 이제부터 하나하나 알아보기로 하겠습니다.

![](./img/2-2/ex1.jpg)

만약 4개의 엑세스 리스트가 있다면 맨 윗줄이 수행되고 그 다음 줄로 내려온다는 겁니다.

별거 아닌 것 같지만 중요합니다. 앞으로 예를 들어 설명을 드리겠습니다. 아무튼 지금은 그냥 외우세요.

![](./img/2-2/ex2.jpg)

엑세스 리스트는 맨 마지막 줄에는 항상 모든 것을 막아버리는 deny all이 들어있다고 생각하고 있습니다. 그러니까 어떤 엑세스 리스트의 항목에도 해당하지 않는 주소가 있다면, 그 주소는 맨 마지막 줄까지 내려온 후 deny all에 걸려서 모두 막혀버리는 겁니다.

따라서 2번 규칙을 까먹고 엑세스 리스트를 구성하는 경우는 막고 싶지 않는 것들도 실수로 모두 막혀버리는 아주 불행한 사태가 발생하는 겁니다. 조심, 조심, 또 조심하셔야 합니다.

![](./img/2-2/ex3.jpg)

예를 한번 들어 볼까요? 지금 여러분은 어렵게 배운 라우터의 엑세스 리스트를 만들어 나가고 있습니다. 여러분이 있는 곳은 라우터의 구성 모드입니다.

![](./img/2-2/ex4.jpg)

아직 여기 있는 엑세스 리스트가 무엇을 의미하는지는 모르셔도 됩니다. 대충 익스텐디드 엑세스 리스트(Extended Access List)가 이렇게 생겼구나라고만 알아두기 바랍니다.

자, 여기 보이는 것처럼 열심히 어려운 엑세스 리스트를 구성했습니다. 그런데 모든 구성을 마치고 나와서 가만히 생각해보니까 엑세스 리스트의 명령어 중 위에서 두 번째가 잘못된 거였습니다.  
즉 IP 주소가 201.222.11.7이어야 하는데 그만 205.222.11.7로 잘못 입력하게 된 겁니다. 그럼 고쳐야겠죠? 그래서 다시 구성 모드로 들어갔습니다.  
명령어를 지울 때는 명령어 앞에 no를 붙이면 된다고 했으니까 이렇게 먼저 잘못 내린 명령을 no를 이용해서 지운 다음에 다시 제대로 된 명령어를 입력했습니다.

![](./img/2-2/ex5.jpg)

대부분의 경우 구성을 변경할 때는 이런 방식을 사용하는 것이 맞습니다. 그러나 엑세스 리스트에서 이런 방식을 사용하게 되면 그동안에 입력되었던 나머지 모든 엑세스 리스트는 지워지게 됩니다. 이렇게 하고 나서 show running-config를 보게 되면,

![](./img/2-2/ex6.jpg)

위에서처럼 맨 마지막에 입력한 한 줄의 엑세스 리스트만 남게 됩니다. 그러니 항상 주의하셔야합니다. 절대 잊지 마세요. 아주 큰 낭패를 볼 수도 있습니다.

![](./img/2-2/ex7.jpg)

엑세스 리스트가 정의되어 있지 않은 인터페이스는 엑세스 리스트를 거치지 않고 바로 통과되기 때문에 당연히 permit any가 되는 겁니다.

이것은 2번 규칙과 혼돈하면 안 됩니다. 2번은 엑세스 리스트는 정의되었지만, 자기가 속할 엑세스 리스트가 없는 것이고, 4번은 아예 자기 네트워크에는 엑세스 리스트도 정의되어 있지 않은 경우이기 때문입니다.



> 알고 갑시다!

엑세스 리스트를 움직이는 4가지 규칙이 있는데, 첫 번째는 윗줄부터 아래로 차례로 수행된다는 것,  
두 번째는 엑세스 리스트의 맨 마지막에는 deny all이 생략되어 있다는 것, 세 번째는 엑세스 리스트에서 중간에 있는 엑세스 리스트를 지우려고 하면 모든 엑세스 리스트가 다 지워진다는 것, 네 번째는 인터페이스에 엑세스 리스트 명령이 없으면 그건 permit all이라는 것이다.

4가지의 엑세스 리스트 규칙은 엑세스 리스트 사용 시에 아주 중요한 거니까 모두 외워야 하고 못 외우면 잘 보이는 곳에 메모해 두세요!



> 네트워크 플러스+

### 네트워크의 혼잡, 컨제션에 대한 이야기

오늘은 혼잡에 대해서 좀 알아보도록 하겠습니다.

보통은 Congestion('컨제션'이라고 하죠.)이라고 이야기하는데, 이것이 바로 네트워크에서 가장 조심해야 할 것 중의 하나입니다.

자, 그럼 컨제션, 즉 혼잡이란 무엇일까요?

말 그대로 네트워크에서 혼잡이 발생하는 겁니다. 도로에서 길이 꽉 막히는 것처럼 말입니다. 그럼 혼잡이 왜 생기냐구요? 그것은 아마도 도로에서 차가 길에 꽉 막히는 이유와 똑같을 겁니다.

그러니까 도로의 용량보다 차가 갑자기 많이 밀릴 때 도로의 혼잡이 발생하는 것처럼 네트워크에서도 네트워크의 전체 대역폭(Bandwidth라고 하죠.)보다 그 네트워크를 지나는 데이터가 많이 몰리게 되면 바로 컨제션이 발생합니다.  
사실 네트워크상에서 컨제션은 발생할 수밖에 없는 필연적인 것인지도 모릅니다. 마치 도로에서도 출퇴근 시간에는 길이 막히는 것처럼 말입니다.

네트워크상에서는 'Bursty(버스티) 트래픽'이라고 하는 것이 있는데, 이것은 데이터가 갑자기 폭주하는 것을 말합니다.

그러다가 한순간에는 데이터가 거의 없다가 또 갑자기 많이 들어오다가 하는 겁니다. 이런 버스트 트래픽 때문에 당연히 컨제션이 발생합니다. 문제는 상습적인 컨제션이 발생하는 것입니다. 네트워크상에서 계속, 언제나, 항상, 늘 컨제션이 발생하면 그것이 문제가 되는 겁니다.

아무튼 이렇게 네트워크상에서 발생하는 컨제션은 이떻게든 해결을 해줘야 하는데, 이것이 바로 '컨제션 매니지먼트'라고 합니다.

그럼 어떻게 이런 네트워크상의 컨제션을 해결해 주는지를 한번 알아보도록 하겠습니다. 위에서 말씀드린 대로 네트워크상에서 분명히 발생하는 혼잡은 관리만 제대로 해주면 어느 정도 방지할 수가 있습니다.  
물론 완전하게 혼잡을 막으려면 돈을 많이 들여서 대역폭을 높이면 되겠죠?

이때 네트워크 관리를 하는 여러분은 어떤 식으로 이 문제를 조금이라도 해결할 수 있을까요? 그게 바로 혼잡 제어입니다. 여기에서는 이런 혼잡을 제어하기 위한 방법을 하나씩 알아보기로 하겠습니다.

첫 번째는 사용자의 애플리케이션에 대한 필터링을 하는 겁니다.

즉 모든 사용자와 모든 애플리케이션을 다 통과시키면 네트워크의 트래픽이 너무 증가하니까 골라서 통과시키는 겁니다. 그럼 불필요한 것들은 아예 네트워크에 들어올 수 없게 되는 겁니다. 이렇게 불필요한 것들을 막아내기 위해서는 엑세스 리스트란 것이 사용됩니다.

두 번째는 브로드캐스트를 막아주는 겁니다.

말씀드린 대로 브로드캐스트는 꼭 필요하면서도 네트워크에 트래픽을 너무 많이 가중시키기 때문에 불필요한 부분에서는 이것을 막아주는 게 중요합니다. 하지만 아주 잘 막아야겠죠? 아무거나 막았다가는 아주 예상치 못한 결과를 얻을 수도 있기 때문입니다.

예를 들어 라우팅 업데이트 같은 정보도 브로드캐스트가 있는데, 이것을 막았을 때는 라우터는 경로가 끊어졌다고 생각하게 됩니다. 실제는 살아있는데도 말입니다.

세 번째는 타이머를 맞추는 겁니다.

즉 일정 시간마다 한 번씩 일어나는 일을 제대로 조정해줌으로써(시간 간격을 늘인다든지) 네트워크의 트래픽을 줄이는 겁니다.

이때 일정 시간마다 일어나는 대부분의 일은 브로드캐스트입니다.

네 번째는 라우팅 테이블의 관리입니다.

라우팅 정보와 교환 역시 트래픽을 발생시킵니다. 따라서 요녀석들 일부를 스태틱으로 조정해주면 트래픽이 줄어들게 되는거죠.

마지막은 트래픽의 우선순위를 매기는 겁니다.

그래서 중요한 트래픽은 우선 처리해주고 느려도 되는 트래픽은 뒤로 빼는 겁니다. 그렇다고 네트워크 관리자 트래픽에만 우선순위를 높게 매기면 안 되겠죠? 아무튼 이렇게 많은 기법이 혼잡 관리를 위해 필요합니다.



## 스탠더드 엑세스 리스트의 시작

이제부터는 슬슬 스탠더드 엑세스 리스트에 대해서 알아보도록 하겠습니다. 엑세스 리스트의 적용은 무엇보다도 개념의 이해가 중요합니다. 개념만 이해하고 나면 엑세스 리스트를 적용하는 것이 별게 아니라는 것을 아실 수 있을 겁니다.  
전에도 말씀드렸지만 엑세스 리스트가 어렵다고 하는 건 기본적인 개념을 제대로 이해하고 있지 못하기 때문일 거라고 생각합니다.

자, 그럼 우린 그림을 보면서 스탠더드 엑세스 리스트의 개념을 이해해 보겠습니다.

![](./img/2-2/ex8.jpg)

위 그림은 라우터 인터페이스의 Inbound쪽에 엑세스 리스트가 설정되었을 때를 보여줍니다. 나중에 구성에서 배우겠지만 엑세스 리스트는 인터페이스에 IN과 OUT으로 구성될 수 있는데, 여기에서는 엑세스 리스트를 IN에 걸었을 경우입니다.

맨 처음 라우터의 인터페이스로 패킷이 들어오면 라우터는 이 인터페이스에 엑세스 리스트가 설정되어 있는지를 먼저 확인합니다. 만약 이 인터페이스에 엑세스 리스트가 설정되어 있지 않다면 바로 통과입니다. 즉 패킷을 정해진 경로로 내보내면 됩니다.

그러나 이 인터페이스에 엑세스 리스트가 걸려있다면 그 엑세스 리스트에 있는 주소와 들어온 패킷의 출발지 주소를 비교해 보게 됩니다. 왜 그런지는 아시죠? 스탠더드 엑세스 리스트의 경우는 출발지 주소, 즉 Source Address를 가지고 엑세스 리스트를 만든다는 것을 설명드렸습니다.  
만약 엑세스 리스트에 정의된 주소와 패킷의 출발지 주소가 일치하면 그 엑세스 리스트를 수행하는 겁니다. 이때 엑세스 리스트의 조건이 Deny이면 패킷의 흐름을 막은 후 'host unreachable'd이라는 ICMP 메시지를 뿌려주고, 엑세스 리스트의 조건이 Permit이라면 패킷을 정해진 경로로 내보냅니다.

![](./img/2-2/ex9.jpg)

자, 그럼 지금부터는 스텐더드 엑세스 리스트를 본격적으로 구성에 적용해 보도록 하겠습니다. 스텐더드 엑세스 리스트는 전에도 말씀드린 대로 출발지 주소만 가지고 통과 여부를 결정한다고 했습니다.

그럼 명령어의 형식을 한번 알아볼까요? 2가지 명령이 있습니다.

![](./img/2-2/ex10.jpg)

일단 여기서 엑세스 리스트는 일반 구성 모드(Router(config)#)에서 내리는 명령이라는 것을 알 수 있습니다.

형식은 맨 앞에 access-list라고 쓰고, 그 다음에 엑세스 리스트 번호(access-list number)를 넣어줍니다.

이때 번호는 1에서 99사이의 숫자를 사용합니다. (1~99까지의 이 숫자는 중요합니다. 이렇게 엑세스 리스트는 종류에 따라서 access-list 번호가 정해져 있습니다. 시험에는 꼭 하나씩 나오고 있습니다.)

그 다음이 통과시킬 것인가, 말 것인가를 결정하는 permit과 deny 결정입니다.

그 뒤에는 출발지 주소 또는 출발지 네트워크를 넣습니다. 그리고 그 뒤는 와일드카드 마스크(wildcard mask)가 따라 나옵니다.  
여기서 출발지 주소 뒤에 오는 와일드카드 마스크는 생략이 가능하지만, 만약 생략했다면 그것은 와일드카드 마스크가 0.0.0.0인 경우입니다.

만약 출발지 주소를 적어넣지 않고 any라고 하면 모든 주소가 포함됩니다.

이렇게 엑세스 리스트 명령을 입력하고 나면 이제는 이 엑세스 리스트를 어떤 인터페이스에 적용할까를 결정해야 합니다. 이것 또한 중요한 작업입니다. 대부분의 경우 인터페이스 적용에 혼돈을 많이 하곤 합니다. 한번 볼까요?

![](./img/2-2/ex11.jpg)

위의 명령은 각 인터페이스에 내리는 명령입니다. 따라서 프롬프트가 인터페이스 구성 모드(Router(config-if)#)임을 알 수 있습니다. 즉 내가 만약 엑세스 리스트를 이더넷 인터페이스 0에 적용하고 싶다면 Router(config)#int e 0 명령을 먼저 입력해서 프롬프트를 Router(config-if)#으로 바꾸어주어야 합니다.

그 뒤에 나오는 access-list-number는 우리가 앞에서 엑세스 리스트에 부여했던 번호와 동일한 번호를 써줌으로써 엑세스 리스트 명령을 인터페이스에 연결해 주는 기능을 합니다.

그 뒤에 나오는 in, out은 엑세스 리스트를 인터페이스의 들어오는 쪽(in)에 부여할 것인가, 나오는 쪽(out)에 부여할 것인가를 결정합니다. (아까 그림에서 In과 Out에 대한 것 다 이해하셨죠?) 만약 이 값이 생략되었다면 그것은 out을 뜻합니다.  
즉 out이 디폴트가 되는 것입니다. in과 out은 실제 적용에서 혼동하는 경우가 많습니다. 여기서 그림을 한번 알아보도록 하겠습니다.

![](./img/2-2/ex12.jpg)
