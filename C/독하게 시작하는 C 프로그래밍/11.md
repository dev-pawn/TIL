# 메모리와 포인터

## 목차

- [메모리의 종류](#메모리의-종류)
- [포인터 변수의 선언 및 정의](#포인터-변수의-선언-및-정의)

### 메모리의 종류

메모리도 용도에 따라 스택(stack), 힙(heap), 데이터 영역(data section), 텍스트 영역(text section)등으로 나뉜다.

| 분류 | 특징 |
| --- | --- |
| Stack | 자동변수이고 지역변수인 변수가 사용하는 메모리 영역으로 임시 메모리의 성격을 가진다.  
크기가 작고(기본 1MB 수준) 관리(잘당 및 반환)가 자동으로 이루어지는 장점이 있다. |
| Heap | 동적 할당할 수 있는 자유 메모리 영역이며, 개발자 자신 스스로 직접 관리(수동)해야 한다.  
32비트 응용프로그램의 경우, 대략 1,xGB 정도를 사용할 수 있다.  
그러므로 대량의 메모리가 필요하거나 필요한 메모리의 크기를 미리 알 수 없을 때 사용한다. |
| (PE image[실행파일]) Text section | C 언어의 소스코드가 번역된 기계어가 저장된 메모리 영역이며, 기본적으로는 읽기 전용 메모리이다.  
만약 어떤 식으로든 이 영역의 메모리를 변조한다면 해킹이라고 할 수 있다. |
| (PE image[실행파일]) (Data section) Read only | 상수 형태로 기술하는 문자열(ex: “Hello”)이 저장된 메모리 영역이며, Text 영역처럼 읽기는 가능하나 쓰기는 허용되지 않는다. |
| (PE image[실행파일]) (Data section) Read/Write | 정적변수나 전역변수들이 사용하는 메모리 영역이며, 별도로 초기화 하지 않아도 0으로 초기화된다.  
관리는 자동이라서 힙 영역 메모리처럼 할당 및 해제를 신경 쓸 필요는 없다. |

여기서 PE는 Portable Executable의 약자이며, 우리가 빌드한 최종 결과로 얻을 수 있는 실행파일(.exe)의 형식을 의미한다.

### 포인터 변수의 선언 및 정의

&(주소연산자) : 메모리의 주소를 알려주는 단항 연산자

*(간접지정연산자) : 여기서 지정이라는 말은 임의 대상 메모리에 대한 길의와 해석방법 즉, 자료형을 지정한다는 의미이다.  
직접 지정이란 “0x0012FF60에서 네 바이트 메모리를 int형 변수로 본다.” 라고 확정하는 것이다.  
반면에 간접 지정이란 “변경될 수 있는 임의의 기준주소로 상대적인 위치(주소)를 식별하는 방식이다.  
이처럼 어떤 기준을 근거로 상대인 메모리의 위치를 설명하는 방법이 ‘간접지정'이다.

```c
#include <stdio.h>

int main(void)
{
	//int 형식 변수 선언 및 정의
	int x = 10;
	//변수 x를 가리키는 int형식에 대한 포인터 변수 선언 및 정의
	int *pnData = &x;

	printf("x : %d\n", x);

	//pnData 포인터 변수가 가리키는 대상 메모리를 int형 변수로
	//간접지정하고 20을 대입한다.
	//현재 가리키는 대상 메ㅔ모리는 변수 x의 메모리이므로 x의 값이 20이 된다.
	*pnData = 20;
	printf("x : %d\n", x);
	return 0;
}
```

실행결과

```c
x : 10
x : 20
```



### 포인터와 배열

배열의 이름은 **0번 요소의 주소**이며, 전체 배열을 대표하는 식별자이다.
 또한 앞에서 살펴본 포인터 변수는 주소를 저장하기 위한 변수이다.
 이 둘을 조합하면 다음과 같이 생각할 수 있다.
 **”배열의 이름이 주소이므로, 포인터 변수에 저장할 수 있다.”**
 즉,  int형 포인터에 int형 변수의 주소만 담을수 있는 것이 아니라, int형 배열의 이름도 담을 수 있다.

```c
#include <stdio.h>

int main(void)
{
	//int 배열 선언 및 정의. 배열의 이름은 연속된 각 요소들 중
	//전체를 대표하는 0번째 요소에 대한 '주소 상수'이다.
	int alist[5] = {0};
	//int에 대한 포인터 변수를 배열의 이름으로 정의한다.
	int *pnData = aList;

	//배열의 0번 요소의 값을 출력한다.
	printf("aList[0] : %d\\n", aList[0]);
	
	//포인터가 가리키고 있는 배열의 0번 요소의 값을 변경하고 출력한다.
	*pnData = 20;
	printf("aList[0] : %d\\n", aList[0]);
	return (0);
}
```

실행결과

```c
aList[0] : 0
aList[0] : 20
```

위 예제에서 int *pnData = aList; int 형 배열의 이름을 “int에 대한 포인터의 초깃값"으로 기술했다.
 이를 응용하면 pnData = &aList[1]; 이나 pnData = &aList[2]; 같은 코드도 성립함을 알 수 있다.
 그리고 위 코드를 int *pnData = &aList[0];  라고 수정해도 의미는 같다. 어차피 배열의 이름은 0번 요소의 주소에 부여한 식별자이다.
 그러므로 *pnData = 20; 에 의해 간접 지정되는 대상 메모리는 aList 배열의 0번 요소이다.
 또한 *(간접지정연산자)는 단항 연산자이며, **pnData라는 포인터에 저장된 주소의 메모리를 int형 변수로 보겠다는 의미이다.** 주소가 직접 기술된 형식이 아니라 “변수에 담긴 주소"를 통해 간접적인 방법으로 지정했으니 간접 지정이다.
