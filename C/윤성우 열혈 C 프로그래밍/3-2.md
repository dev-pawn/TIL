# 포인터의 포인터



## 목차

- [포인터의 포인터에 대한 이해](#포인터의-포인터에-대한-이해)
- 다중 포인터 변수와 포인터의 필요성



## 포인터의 포인터에 대한 이해

포인터의 포인터는 포인터 변수를 가리키는 또 다른 포인터 변수를 뜻하는 것으로서 흔히 __이중 포인터__ 또는 __더블 포인터__ 라고 부르며,  
다음과 같이 포인터 변수 선언에 사용되는 * 연사자를 두 개 이어서 선언한다.

```c
int ** dptr
```



> 포인터 변수를 가리키는 이중 포인터 변수(더블 포인터 변수)

포인터 변수는 종류에 상관없이 무조건 주소 값을 저장하는 변수이다. 다만 차이가 나는 것은 포인터 변수가 가리키는 값일 뿐이다.  
아래 코드를 보자.

```c
int main(void)
{
	double num = 3.14;
	double *ptr = &num;		// 변수 num의 주소 값 저장
	....
}
```

위의 코드에서 변수 num과 포인터 변수 ptr의 차이점과 공통점은  

- 공통점 = 둘 다 변수이다. 따라서 값의 저장이 가능하다.
- 차이점 = 저장하는 값의 종류(유형)이 다르다.

이렇듯 ptr도 메모리에 공간이 할당되는 변수이다. 따라서 이를 대상으로도 & 연산이 가능하며,  
이 때 반환되는 주소 값은 double형 더블 포인터 변수에 저장이 가능하다.  
때문에 싱글 포인터 변수 ptr을 대상으로 다음과 같은 문장의 구성이 가능하다.

```c
double ** dptr = &ptr;
```

그리고 위의 문장을 추가함으로써 포인터 변수 ptr과 dptr, 그리고 변수 num의 관계는 다음과 같이 표현이 된다.

```
dptr → ptr → num(3.14)
```

그리고 위 상태에서는 dptr을 대상으로 다음과 같은 방식으로 포인터 변수 ptr과 변수 num에 접근이 가능하다.

```
*dptr = ....;		// *dptr은 포인터 변수 ptr을 의미함
*(*dptr) = ....;	// *(*dptr)은 변수 num을 의미함
```

그리고 `*(*dptr)`에서 괄호는 생략이 가능하기 때문에 **dptr로 표현이 가능하며, 이것이 보다 일반적인 표현이다.  
이와 관련해서 예제를 살펴보자.



DoublePointerAccess.c

```c
#include <stdio.h>

int main(void)
{
	double num = 3.14;
    double *ptr = &num;
    double **dptr = &ptr;
    double *ptr2;
    
    printf("%9p %p \n", ptr, *dptr);
    printf("%9p %9g \n", num, **dptr);
    ptr2 = *dptr;		// ptr2 = ptr 과 같은 문장
    printf("%9g %9g \n", num, **dptr);
    return 0;
}
```



실행 결과

```C
0032FD00 0032FD00
	3.14     3.14
   10.99    10.99
```

 위 예제에서 변수 num에 접근하는 방법은 총 4가지가 존재한다.  
**dptr = 10.1;			// 변수 num에 10.1이 저장됨  
*ptr = 20.2;				// 변수 num에 20.2가 저장됨  
*ptr2 = 30.3;			 // 변수 num에 30.3이 저장됨  
num = 40.4;			  // 변수 num에 40.4가 저장됨



> 포인터 변수 대상의 Call-by-reference

 앞서 우리는 두 변수에 저장된 값을 서로 바꿔서 저장하는 함수를 다음과 같이 정의한 바 있다.

```c
void Swap(int * ptr1, int * ptr2)
{
	int temp = *ptr1;
    *ptr1 = *ptr2;
    *ptr2 = temp;
}
```

그렇다면 이번에는 두 싱글 포인터 변수에 저장된 값을 서로 바꿔서 저장하는 함수를 정의해보자.  
이와 관련해서 두 가지 예제를 제시할텐데 첫 번째 예제는 잘못된 예제로서 문제점을 찾아보자.



PointerSwapFail.c

```c
#include <stdio.h>

void SwapIntPtr(int *p1, int *p2)
{
	int * temp = p1;
    p1 = p2;
    p2 = temp;
}

int main(void)
{
    int num1 = 10, num2 = 20;
    int *ptr1, *ptr2;
    ptr1 = &num1, ptr2 = &num2;
    printf("*ptr1, *ptr2: %d %d \n", *ptr1, *ptr2);
    
    SwapIntPtr(ptr1, ptr2);
    printf("*ptr1, *ptr2: %d %d \n", *ptr1, *ptr2);
    return 0;
}
```



실행 결과

```
*ptr1, *ptr2: 10 20
*ptr1, *ptr2: 10 20
```



실행 결과를 보면 함수 SwapIntPtr이 두 포인터 변수가 가리키는 대상을 변경하지 못함을 알 수 있다.  
그 이유는 함수 인자로 전달되는 ptr1, ptr2와 p1, p2는 별개이기 때문이다.  
그렇다면 어떻게 해야 함수 내에서 ptr1 과 ptr2가 가리키는 대상을 바꿀 수 있을까? 이를 위해서는 함수 내에서 포인터 변수 ptr1과 ptr2에 직접 접근이 가능해야 한다.  
그래서 이 두 변수에 저장된 값을 서로 바꿔줘야 한다. 그게 가능하기 위해서는 int형 더블 포인터가 매개변수로 선언되어야 한다.  
이제 정상적인 예제를 살펴보도록 하자.



PointerSwapSuccess.c

```c
#include <stdio.h>

void SwapIntPtr(int **dp1, int **dp2)
{
    int *temp = *dp1;
    *dp1 = *dp2;
    *dp2 = temp;
}

int main(void)
{
	int num1 = 10, num2 = 20;
    int *ptr1, *ptr2;
    ptr1 = &num1, ptr2 = &num2;
    printf("*ptr1, *ptr2: %d %d \n", ptr1, ptr2);
    
    SwapIntPtr(&ptr1, &ptr2);		// ptr1과 ptr2의 주소 값 전달!
    printf("*ptr1, *ptr2: %d %d \n", ptr1, ptr2);
    return 0;
}
```



실행 결과

```
*ptr1, *ptr2: 10 20
*ptr1, *ptr2: 20 10
```



> 포인터 배열과 포인터 배열의 포인터 형

