# 변수와 연산자



## 목차

- [연산을 위한 연산자와 값의 저장을 위한 변수](#연산을-위한-연산자와-값의-저장을-위한-변수)
- [C언어의 다양한 연산자 소개](#C언어의-다양한-연산자-소개)
- [키보드로부터의 데이터 입력과 C언어의 키워드](#키보드로부터의-데이터-입력과-c언어의-키워드)



## 연산을 위한 연산자와 값의 저장을 위한 변수

> 덧셈 프로그램의 구현에 필요한 + 연산자

```c
#include <stdio.h>

int main(void){
    3 + 4;        //3과 4의 합을 명령함
    return 0;
}
```

위 예제는 문제없이 컴파일 된다. 이것은 즉 C언어가 + 기호를 지원한다는 뜻을 의미한다. 만약 + 기호를 지원하지 않았다면 컴파일 에러가 발생했을 것이다.  
이렇게 특정연산을 요구할 때 사용하는 약속된 기호를 가리켜 __연산자(operator)__라 한다.  
위 예제를 실행해보면 덧셈의 결과가 출력되지 않는 것을 알 수 있다. 이는 프로그램 내에 덧셈을 명령하는 문장은 있지만, 덧셈의 결과를 출력하는 문장은 존재하지 않기 때문이다.  



> 변수를 이용한 데이터의 저장

__변수란?__ 값을 저장할 수 있는 메모리 공간에 붙은 이름, 혹은 메모리 공간 자체를 가리켜 변수라 한다.

```c
int main(void){
    int num;    //num 이라는 이름의 변수선언
    ....
}
```

```c
int num;
```

이 문장을 구성하는 int와 num이 의미하는 바는 아래와 같다.

- int: 정수의 저장이 가능한 메모리 공간을 할당
- num: 할당한 메모리 공간의 이름을 num이라고 지정

따라서 변수 num을 선언한 다음에는 num이라는 이름을 이용해서 값을 저장하고 참조할 수 있다.

```c
int main(void){
    int num;            //num이라는 이름의 변수 선언
    num=20;             //변수 num에 20이라는 값 저장
    printf("%d", num);  //변수 num의 값을 참조
}
```

C언어에서 기호 = 는 대입을 뜻한다. 이 기호를 가리켜 __대입 연산자__라고 하며 대입 연산자의 오른편에 오는 값을 왼편에 오는 변수에 저장하는 형태로 사용한다.



> 변수의 다양한 선언 및 초기화 방법

선언된 변수에 처음 값을 저장하는 것을 가리켜 __초기화__라고 한다.  
초기화 이후에 저장된 값을 변경할 때는 그냥 __대입__ 또는 __대입연산__ 을 진행한다고 말한다.

```c
int main(void){
    int num;        //num이라는 이름의 변수 선언
    num=12;         //변수 num을 12로 초기화
    num=24;         //변수 num에 24를 대입
}
```

C언어에서는 변수를 __선언과 동시에 초기화__하는 것이 가능하다.

```c
int num=12;
```

위 문장을 실행하게 되면 변수 num이 메모리 공간에 할당되자마자 12로 초기화된다.  
그리고 아래와 같이 둘 이상의 변수를 동시에 선언하는 것도 가능하고, 동시에 선언 및 초기화하는 것도 가능하다.

```c
int num1, num2;            //두 개의 변수를 선언
int num3=30, num4=40;    //두 개의 변수를 선언 및 초기화
```



예제 VarDeclAndInit.c

```c
#include <stdio.h>

int main(void){
    int num1, num2;            //변수 num1, num2의 선언
    int num3=30, num4=40;      //변수 num3, num4의 선언 및 초기화
    
    printf("num1: %d, num2: %d \n, num1, num2");
    num1=10;        //변수 num1의 초기화
    num2=20;        //변수 num2의 초기화
    
    printf("num1: %d, num2: %d \n, num1, num2");
    printf("num3: %d, num4: %d \n, num3, num4");
    return 0;
}
```



실행 결과

```
num1: -858993460, num2: -858993460
num1: 10, num2: 20
num3: 30, num4: 40
```



위 예제는 변수의 선언 및 초기화 뿐만 아니라 다음 사실도 말해준다.

__변수를 선언만 하고 초기화하지 않으면 쓰레기 값이 저장된다.__

쓰레기 값이란 __아무런 의미가 없는 값__을 말한다.



> 변수선언 시 주의사항

1. __중괄호 내에 변수를 선언할 경우, 변수의 선언문은 중괄호의 앞부분에 위치해야 한다.__

예를 들어, 다음과 같은 코드는 컴파일 에러를 발생시킨다.  

```c
int main(void){
    int num1;
    num1=0;            //이 문장은 변수의 선언문이 아니다.
    int num2;          //컴파일 에러가 발생하는 지점
    num2=0;
}
```

위의 경우는 변수 num2의 선언문 앞에 변수의 선언이 아닌 문장이 등장했기 때문에 컴파일 에러가 발생한다.  
따라서 중괄호의 앞부분에 변수의 선언문이 오도록 해야 한다.  
참고로, __1999년도에 발표된 C언어의 표준에서는 변수의 선언 위치에 아무런 제한을 두지 않고 있다.__  

2. 변수의 이름을 규칙에 맞게 지어야 한다.
   - 변수의 이름은 알파벳, 숫자, 언더바(_)로 구성된다.
   - C언어는 대소문자를 구분한다. 따라서 변수 Num과 변수 num은 서로 다른 변수이다.
   - 변수의 이름은 숫자로 시작할 수 없고, 키워드도 변수의 이름으로 사용할 수 없다.
   - 이름 사이에 공백이 삽입될 수 없다.

아래 변수 선언은 모두 유효하지 않다.

```c
int 7Number;        //변수의 이름이 숫자로 시작
int phone#;         //변수의 이름에 특수문자 #이 포함됨
int your name;      //이름 사이에 공백이 삽입됨
```



> 변수의 자료형(Data Type)

변수는 크게 두 가지로 나눌 수 있다.

- 정수형 변수: 정수의 저장을 목적으로 선언된 변수
- 실수형 변수: 소수점 이하의 값을 지니는 실수의 저장을 목적으로 선언된 변수

변수의 종류가 크게 두 가지로 나뉘는 이유는 __정수냐, 실수냐에 따라서 값이 메모리 공간에 저장 및 참조되는 방식이 다르기 때문이다.__



> 덧셈 프로그램의 완성

예제 SimpleAddTwo.c

```c
#include <stdio.h>

int main(void){
    int num1=3;
    int num2=4;
    int result=num1+num2;
    
    printf("덧셈 결과: %d \n", result);
    printf("%d+%d=%d \n", num1, num2, result);
    printf("%d와(과) %d의 합은 %d 입니다.\n", num1, num2, result);
    return 0;
}
```



실행 결과

```
덧셈 결과: 7
3+4=7
3와(과) 4의 합은 7입니다.
```



## C언어의 다양한 연산자 소개

> 대입 연산자(=)와 산술 연산자(+, -, *, /, %)

두 개의 피연산자를 요구하는 연산자를 가리켜 __이항 연산자(binary operator)__라 한다.  
아래에 소개하는 대입 연산자와 산술 연산자는 모두 이항 연산자들이다.

- =

  연산자 오른쪽에 있는 값을 연산자 왼쪽에 있는 변수에 대입한다.

  예) num = 10; 결합방향 ←

  

- +

  두 피연산자의 값을 더한다.

  예) num = 4 + 3; 결합방향 →

  

- -

  왼쪽의 피연산자 값에서 오른쪽의 피연산자 값을 뺀다.

  예) num = 4 - 3; 결합방향 →

  

- *

  두 피연산자의 값을 곱한다.

  예) num = 4 * 3; 결합방향 →

  

- /

  왼쪽의 피연산자 값을 오른쪽의 피 연산자 값으로 나눈다.

  예) num = 7 / 3; 결합방향 →

  

- %

  왼쪽의 피연산자 값을 오른쪽의 피연산자 값으로 나눴을 때 얻게 되는 나머지를 반환한다.

  예) num = 7 % 3; 결합방향 →



예제 OperatorOne.c

```c
#include <stdio.c>

int main(void){
    int num1=9, num2=2;
    printf("%d+%d=%d \n", num1, num2, num1+num2);
    printf("%d-%d=%d \n", num1, num2, num1-num2);
    printf("%d*%d=%d \n", num1, num2, num1*num2);
    printf("%d/%d의 몫=%d \n", num1, num2, num1/num2);
    printf("%d/%d의 나머지=%d \n", num1, num2, num1%num2);
    return 0;
}
```



실행 결과

```
9 + 2 = 11
9 - 2 = 7
9 * 2 = 18
9 / 2 = 4
9 % 2 = 1
```



위 예제로 알 수 있는 사실은 다음과 같다.

__함수 호출문의 인자전달 위치에 연산식이 올 수 있다.__

이러한 경우 함수 호출에 앞서 연산식이 먼저 진행되며, 그 연산의 결과가 인자가 되어 함수의 호출까지 이어지는 것이다.



> 복합 대입 연산자

__복합 대입 연산자란?__ 다른 연산자와 합쳐진 형태의 대입 연산자이다.

__*=, /=, %=, +=, -=, <<=, >>=, &=, ^=, |=__



예제 OperatorTwo.c

```c
#include <stdio.h>

int main(void){
    int num1=2, num2=4, num3=6;
    num1 += 3;        //num1 = num1 + 3;
    num2 *= 4;        //num2 = num2 * 4;
    num3 %= 5;        //num3 = num3 % 5;
    printf("Result: %d, %d, %d \n", num1, num2, num3);
    return 0;
}
```



실행 결과

```
Result: 5, 16, 1
```



> 부호연산의 의미를 갖는 +연산자와 -연산자

연산자 +, - 는 이항 연산자로서 덧셈과 뺄셈을 의미하지만, 피연산자가 하나인 단항 연산자로서 부호를 뜻하기도 한다.



예제 OperatorThree.c

```c
#include <stdio.h>

int main(void){
    int num1 = +2;
    int num2 = -4;
    
    num1 = -num1;
    printf("num1: %d \n", num1);
    num2 = -num2;
    printf("num2: %d \n", num2);
    return=0;
}
```



실행 결과

```
num1: -2
num2: 4
```



> 증가, 감소 연산자

증가, 감소 연산자는 변수에 저장된 값을 1 증가 및 감소 시키는 경우에 사용되는 연산자이다.

- ++variable

  값을 1 증가 후, 속한 문장의 나머지를 진행(선 증가, 후  연산)

  예) num = ++variable; 결합방향 ←

  

- variable++

  속한 문장을 먼저 진행한 후, 값을 1 증가(선 연산, 후 증가)

  예) num = variable++; 결합방향 →

  

- --variable

  값을 1 감소 후, 속한 문장의 나머지를 진행(선 감소, 후 연산)

  예) num = --variable; 결합방향 ←

  

- variable--

  속한 문장을 먼저 진행한 후, 값을 1 감소(선 연산, 후 감소)

  예) num = variable--; 결합방향 →



예제 OperatorFour.c

```c
#include <stdio.h>

int main(void){
    int num1=12;
    int num2=12;
    printf("num1: %d \n, num1");
    printf("num1++: %d \n", num1++);        //후위 증가
    printf("num1: %d \n\n", num1);
    
    printf("num2: %d \n", num2);
    printf("++num2: %d \n", ++num2);
    printf("num2: %d \n\n", num2);
    return 0;
}
```



실행 결과

```
num1: 12
num1++: 12
num1: 13

num2: 12
++num2: 13
num2: 13
```



예제 OperatorFive.c

```c
#include <stdio.h>

int main(void){
    int num1=10;
    int num2=(num1--)+2;            //후위 감소
    
    printf("num1: %d \n", num1);
    printf("num2: %d \n", num2);
    return 0;
}
```



실행 결과

```
num1: 9
num2: 12
```



C언어에서는 소괄호도 연산자이다. 수학에서의 소괄호처럼 먼저 연산하라는 뜻이다.  
하지만 위의 예제를 보면 정수 2와의 덧셈 연산이 진행되어 num2에 12가 저장된 이후에 값이 감소했음을 보여준다.  
즉, 후위 증가(선 연산, 후 증가) 및 후위 감소(선 연산, 후 감소) 연산 시에는 __소괄호의 옇양을 받지 않고, 다음 문장으로 넘어가야만 비로소 값의 증가 및 감소가 이뤄진다__는 것을 알 수 있다.



>관계 연산자( <, >, ==, !=, <=, >=)

__관계 연산자란?__ 대소와 동등의 관계를따지는 연산자이다. 관계 연산자는 두 개의 값을 비교하기 때문에 __비교 연산자__라고도 한다.

- <

  예) n1 < n2

  n1이 n2보다 작은가? 결합방향 →

  

- &#62;

  예) n1 > n2

  n1이 n2보다 큰가? 결합방향 →

  

- ==

  예) n1 == n2

  n1과 n2가 같은가? 결합방향 →

  

- !=

  예) n1 != n2

  n1과 n2가 다른가? 결합방향 →

  

- <=

  예) n1 <= n2

  n1이 n2보다 같거나 작은가? 결합방향 →

  

- &#62;=

  예) n1 >= n2

  n1이 n2보다 같거나 큰가? 결합방향 →



위의 관계 연산자들은 __조건을 만족하면 1, 만족하지 않으면 0을 반환한다.__

여기서 말하는 1은 참(true)을, 0은 거짓(false)을 의미하는 대표적인 숫자다.



예제 OperatorSix.c

```c
#include <stdio.h>

int main(void){
    int num1=10;
    int num2=12;
    int result1, result2, result3;
    
    result1=(num1==num2);
    result2=(num1<=num2);
    result3=(num1>num2);
    
    printf("result1: %d \n", result1);
    printf("result2: %d \n", result2);
    printf("result3: %d \n", result3);
    return 0;
}
```



실행 결과

```
result1: 0
result2: 1
result3: 0
```



> 논리 연산자(&&, ||, !)

__논리 연산자란?__ AND(논리곱), OR(논리합), NOT(논리부정)을 표현하는 연산자이다.



- &&

  예) A && B

  A와 B 모두 '참'이면 연산결과로 '참'을 반환(논리 AND) 결합방향 →

- ||

  예) A || B

  A와 B 둘 중 하나라도 '참'이면 연산결과로 '참'을 반환(논리OR) 결합방향 →

- !

  예) !A

  A가 '참'이면 '거짓', A가 '거짓'이면 '참'을 반환(논리 NOT) 결합방향 ←



예제 OperatorSeven.c

```c
#include <stdio.c>

int main(void){
    int num1=10;
    int num2=12;
    int result1, result2, result3;
    
    result1 = (num1==10 && num2==12);
    result2 = (num1<12 || num2>12);
    result3 = (!num1);
    
    printf("result1: %d \n", result1);
    printf("result2: %d \n", result2);
    printf("result3: %d \n", result3);
    return 0;
}
```



실행 결과

```
result1: 1
result2: 1
result3: 0
```

