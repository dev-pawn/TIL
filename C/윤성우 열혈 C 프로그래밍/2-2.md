# Chapter 12 포인터의 이해



## 목차

- [포인터란 무엇인가?](#포인터란-무엇인가-)
- [포인터와 관련 있는 연산자: & 연산자와 * 연산자](#포인터와-관련-있는-연산자---연산자와---연산자)



## 포인터란 무엇인가?

> 주소 값의 저장을 목적으로 선언되는 포인터 변수

다음과 같이 변수가 선언되었다고 가정해보자.

```c
int	main(void)
{
	char ch1='A', ch2='Q';
	int	num=7;
	....
}
```

그럼 총 6바이트(1+1+4)가 메모리 공간에 할당된다.

C언어에서는 시작번지만을 가지고 메모리의 위치를 표현한다.

"int형 변수 num은 0x12ff76번지에 할당되어 있습니다."

그런데 위의 대답에 포함되어 있는 0x12ff76 주소값 역시 정수이다. 딸서 이것도 저장이 가능한 값이며,  
이의 저장을 위해 마련된 변수가 바로 '포인터 변수'이다.

"포인터 변수란 메모리의 주소 값을 저장하기 위한 변수이다."

참고로 포인터는 변수 형태의 포인터와 상수 형태의 포인터를 어우르는 표현이다.  
하지만 포인터와 관련된 이야기의 대부분이 포인터 변수와 관련이 있으므로, 포인터라 하면 우선 포인터 변수를 연상하면 된다.



> 포인터 변수와 & 연산자에 대해서 간단히 맛보기!

정수 7이 저장된 int형 변수 num을 선언하고 이 변수의 주소 값 저장을 위한 포인터 변수 pnum을 선언하자. 그리고 나서 pnum에 변수 num의 주소 값을 저장하자.

위 문장을 코드로 작성하면

```c
int	main(void)
{
	int num=7;		
	int *pnum;			//포인터 변수 pnum의 선언
	pnum = &num;		//num의 주소 값을 포인터 변수 pnum에 저장
}
```

위의 코드에서 다음의 문장이 바로 포인터 변수의 선언이다.

```c
int *pnum;
```

위의 문장은 다음과 같이 해석하면 된다.

```
pnum		포인터 변수의 이름
int *		int형 변수의 주소 값을 저장하는 포인터 변수의 선언
```

때문에 pnum은 int형 변수의 주소 값을 저장할 수 있는 포인터 변수가 된다.

이어서 위 코드의 그 다음 문장을 보자.

```c
pnum = &num;
```

위의 문장에서 & 연산자는 '오른쪽에 등장하는 피연산자의 주소 값을 반환하는 연산자'이다.  
따라서 위의 문장에서는 & 연산의 결과로 변수 num의 주소 값이 반환되며, 이를 포인터 변수 pnum에 저장하게 된다.  
그리고 이 상황을 다음과 같이 표현한다.

포인터 변수 pnum이 int형 변수 num을 가르킨다.

> 포인터 변수 선언하기

포인터 변수는 가리키고자 하는 변수의 자료형에 따라서 선언하는 방법이 달라진다.  
사실 주소 값은 동일한 시스템에서 그 크기가 동일하며 모두 정수의 형태를 띈다.  
그래도 가리키고자 하는 변수의 자료형에 따라서 선언하는 방법이 다음과 같이 달라진다.

```c
int *pum1; // int * 는 int형 변수를 가리키는 pnum1의 선언을 의미함.

double * pnum2; // double * 는 double형 변수를 가리키는 pnum2의 선언을 의미함

unsigned int * pnum3; // unsigned int * 는 unsigned int형 변수를 가리키는 pnum3의 선언을 의미함
```

위의 예에서 볼 수 있듯이 포인터 변수 선언의 기본 공식은 다음과 같다.

```c
type * prt; //type형 변수의 주소 값을 저장하는 포인터 변수 prt의 선언
```



> 포인터의 형(Type)

int, char, double과 같이 변수의 선언 및 구분에 사용되는 키워드를 자료형이라 하듯이  
포인터 변수의 선언 및 구분에 사용되는 int *, char *, double * 등을 가리켜 포인터형이라 한다.  
하지만 포인터 변수도 값을 저장하는 변수이기 때문에 포인터 형 역시 자료형의 범주에 포함시키기도 한다.

int *							int형 포인터

int * pnum1;			int형 포인터 변수 pnum1

double *					double형 포인터

double * pnum2;	double형 포인터 변수 pnum2

즉 표현의 기본 원리는 다음과 같다.

type *						type형 포인터

type * ptr;				type형 포인터 변수 ptr



## 포인터와 관련 있는 연산자: & 연산자와 * 연산자

일반적으로 & 연산자와 * 연산자를 가리켜 포인터 연산자라고 한다.  
여기서 말하는 * 연산자는 곱셈 연산자를 말하는 것이 아니다. 곱셈 연산자는 이항 연산자인 반면, 포인터 연산자는 단항 연산자이다. * 연산자는 사용되는 위치에 따라 의미가 달라진다.



> 변수의 주소 값을 반환하는 & 연산자

&연산자는 피연산자의 주소 값을 반환하는 연산자이다.

```c
int	main(void)
{
	int num = 5;
    int * pum = &num;		//num의 주소 값을 반환해서 포인터 변수 pnum을 초기화
    ....
}
```

이처럼 & 연산자의 피연산자는 변수(variable)이어야 하며, 상수는 피연산자가 될 수 없다.  
그리고 다음과 같이 변수의 자료형에 맞지 않는 포인터 변수의 선언은 문제가 될 수 있다.

```c
int	main(void)
{
    int num1 = 5;
    double * pnum1 = &num1;		//일치하지 않음
    
    double num2 = 5;
    int * pnum2 = &num2;		//일치하지 않음
    ....
}
```

위와 같이 int형 변수의 주소 값을 double형 포인터 변수에 저장하거나 double형 변수의 주소 값을 int형 포인터 변수에 저장하는 것은 잘못된 것이다.  
비록 컴파일 에러는 발생하지 않지만 포인터 관련 연산시 문제가 발생한다.



> 포인터가 가리키는 메모리를 참조하는 * 연산자

*연산자는 포인터가 가리키는 메모리 공간에 접근할 때 사용하는 연산자이다.

```c
int main(void)
{
    int num=10;
    int *pnum = &num;			//포인터 변수 pnum이 변수 num을 가리키게 하는 문장 
    *pnum=20;					//pnum이 가리키는 변수에 20을 저장하라!
    printf("%d", *pnum);		//pnum이 가리키는 변수를 부호 있는 정수로 출력하라!
    ....
}
```

위 예제는 다음과 같이 해석된다.

포인터 변수 pnum이 가리키는 메모리 공간인 변수 num에 정수 20을 저장하라.

포인터 변수 pnum이 가리키는 메모리 공간인 변수 num에 저장된 값을 출력해라.



PointerOpertation.c

```c
#include <stdio.h>

int	main(void)
{
	int num1=100, num2=100;
    int *pnum;
    
    pnum=&num1;			//포인터 pnum이 num1을 가리킴
    (*pnum)+=30;		// num1+=30;과 동일
    
    pnum=&num2;			//포인터 pnum이 num2를 가리킴
    (*pnum)-=30;		//num2-=30;과 동일
    
    printf("num1:%d, num2:%d \n", num1, num2);
    return 0;
}
```



실행 결과

```
num1:130, num2:70
```

위 예제에서 중요한 것은 포인터 변수 pnum이 가리키는 대상이 num1에서 num2로 한차례 변경되었다는 것이다.



> 다양한 '포인터 형'이 존재하는 이유!

아래의 return 문에서 pnum은 포인터 변수이다.

```c
return *pnum;
```

위의 문장을 통해서 값을 반환하려면 pnum이 가리키는 메모리 공간에 접근을 해서 값을 읽어 들어야 한다.  
그렇다면 어떻게 값을 읽어 들여야 하는가?

"pnum에 저장된 주소를 시작으로 몇 바이트를 읽어 들여야 하는가? 그리고 읽어 들인 데이터는 정수로 해석해야 하는가? 실수로 해석해야 하는가?"

사실 위의 return문만 가지고는 위의 질문에 답을 하지 못한다.  
위의 질문에 답을 하기 위해서는 pnum의 포인터 형 정보가 필요하다. 그렇다면 pnum을 int형 포인터 변수라고 가정하고 답을 해보자.

"pnum이 int형 포인터 변수이므로 pnum에 저장된 주소를 시작으로 4바이트를 읽어 들여서 이를 정수로 해석해야 한다."

그렇다면 pnum이 double형 포인터 변수라고 가정하면 어떻게 될까?

"pnum이 double형 포인터 변수이므로 pnum에 저장된 주소를 시작으로 8바이트를 읽어 들여서 이를 실수로 해석해야 한다."

이렇듯 __포인터의 형은 메모리 공간을 참조하는 기준이 된다.__  
즉 포인터 형을 정의한 이유는 * 연산자를 통한 메모리 공간의 접근 기준을 마련하기 위해서이다.  
그렇다면 아래의 코드를 보며 무엇이 문제인지 말해보자.

```c
int	main(void)
{
    double num = 3.14;
    int *pnum=&num;					//형(type) 불일치
    printf("%d", *pnum);			//예측 불가능한 의미 없는 출력
}
```

위의 코드를 컴파일 하면 경고 메시지는 출력되지만, 에러는 발생하지 않는다.  
이는 C언어가 메모리 접근에 대한 유연성을 최대한 보장하기 때문이다.  
코드를 실행하게 되면 int형 포인터 변수 pnum은 double형 변수 num을 가리키게 된다.  
따라서 pnum이 가리키는 메모리 공간에 저장된 값을 얻기 위해서 * 연산을 하는 경우 다음의 형태로 데이터를 읽어서 해석하게 된다.

"4바이트를 읽어 들여서 이를 정수로 해석한다."

즉, 실제 저장할 때는 8바이트 크기의 실수형 데이터로 저장을 했는데, 해석은 전혀 엉뚱하게 해버린 셈이다.  
따라서 얼마가 출력될지 예측이 불가능할 뿐만 아니라, 이렇게 해석해서 얻게 되는 정수 값은 아무 의미도 없는 쓰레기 값이다.

마지막으로 정리하면 포인터의 형이 존재하는 이유는 포인터 기반의 메모리 접근 기준을 마련하기 위함이다.  
포인터에 형이 존재하지 않는다면 * 연산을 통한 메모리의 접근은 불가능하다.



> 잘못된 포인터의 사용과 널 포인터

```c
int	main(void)
{
	int *ptr;		//포인터 변수 ptr은 쓰레기 값으로 초기화 됨
    *ptr=200;
    ....
}
```

위와 같이 포인터 변수를 선언만 하고 초기화하지 않으면, 포인터 변수는 쓰레기 값으로 초기화된다.  
때문에 이러한 상태에서 * 연산을 통해 200을 저장하는 것은 치명적인 결과를 가져올 수 있다.  
ptr이 가리키는 위치를 알 수 없기 때문에 만약 ptr이 가리키는 위치가 메모리 공간의 중요한 위치였다면,  
이것은 시스템 전체에 심각한 위험이 될 수 있다.  
요즘 운영체제는 이러한 시도를 감지했을때 해당 프로그램을 중지시켜서 메모리의 접근을 미연에 방지한다.



```c
int	main(void)
{
   int *ptr = 125;		//125번지가 어딘줄 알고?
   *ptr = 10;
    ....
}
```

위의 경우는 포인터 변수 ptr을 초기화 한답시고 125를 저장하였다.  
125번지가 어딘줄 알고 포인터 변수를 125로 초기화하는가? 결국 이는 쓰레기 값으로 포인터를 초기화한 것과 다르지 않다.

그렇다면 포인터 변수는 어떻게 초기화 해야 할까?

```
int	main(void)
{
	int *ptr1 = 0;
	int *ptr2 = NULL;		//NULL은 사실상 0을 의미함.
}
```

위에서 ptr을 초기화하는 값 __0을 가리켜 '널 포인터'라 한다.__  
이는 0을 의미하는 것이 아니다. 널 포인터가 의미하는 값은 "아무대도 가리키지 않는다"라는 뜻이다.  
따라서 이를 이용한 * 연산은 메모리 공간에 어떠한 영향도 미치지 않는다.  
물론 프로그램이 멈추는 현상은 동일하게 일어나지만, 이는 잘못된 메모리의 접근에 대한 보호장치가 없는 운영체제에서도 시스템에 치명적인 영향을 주지 않는다.  
마지막으로 키워드 NULL은 널 포인터를 의미하며, 실제로 이는 상수 0으로 정의되어 있다.
