# Chapter 12 포인터의 이해



## 목차

- 포인터란 무엇인가?
- 포인터와 관련 있는 연산자: & 연산자와 * 연산자



## 포인터란 무엇인가?

> 주소 값의 저장을 목적으로 선언되는 포인터 변수

다음과 같이 변수가 선언되었다고 가정해보자.

```c
int	main(void)
{
	char ch1='A', ch2='Q';
	int	num=7;
	....
}
```

그럼 총 6바이트(1+1+4)가 메모리 공간에 할당된다.

C언어에서는 시작번지만을 가지고 메모리의 위치를 표현한다.

"int형 변수 num은 0x12ff76번지에 할당되어 있습니다."

그런데 위의 대답에 포함되어 있는 0x12ff76 주소값 역시 정수이다. 딸서 이것도 저장이 가능한 값이며,  
이의 저장을 위해 마련된 변수가 바로 '포인터 변수'이다.

"포인터 변수란 메모리의 주소 값을 저장하기 위한 변수이다."

참고로 포인터는 변수 형태의 포인터와 상수 형태의 포인터를 어우르는 표현이다.  
하지만 포인터와 관련된 이야기의 대부분이 포인터 변수와 관련이 있으므로, 포인터라 하면 우선 포인터 변수를 연상하면 된다.



> 포인터 변수와 & 연산자에 대해서 간단히 맛보기!

정수 7이 저장된 int형 변수 num을 선언하고 이 변수의 주소 값 저장을 위한 포인터 변수 pnum을 선언하자. 그리고 나서 pnum에 변수 num의 주소 값을 저장하자.

위 문장을 코드로 작성하면

```c
int	main(void)
{
	int num=7;		
	int *pnum;			//포인터 변수 pnum의 선언
	pnum = &num;		//num의 주소 값을 포인터 변수 pnum에 저장
}
```

위의 코드에서 다음의 문장이 바로 포인터 변수의 선언이다.

```c
int *pnum;
```

위의 문장은 다음과 같이 해석하면 된다.

```
pnum		포인터 변수의 이름
int *		int형 변수의 주소 값을 저장하는 포인터 변수의 선언
```

때문에 pnum은 int형 변수의 주소 값을 저장할 수 있는 포인터 변수가 된다.

이어서 위 코드의 그 다음 문장을 보자.

```c
pnum = &num;
```

위의 문장에서 & 연산자는 '오른쪽에 등장하는 피연산자의 주소 값을 반환하는 연산자'이다.  
따라서 위의 문장에서는 & 연산의 결과로 변수 num의 주소 값이 반환되며, 이를 포인터 변수 pnum에 저장하게 된다.  
그리고 이 상황을 다음과 같이 표현한다.

포인터 변수 pnum이 int형 변수 num을 가르킨다.

> 포인터 변수 선언하기

포인터 변수는 가리키고자 하는 변수의 자료형에 따라서 선언하는 방법이 달라진다.  
사실 주소 값은 동일한 시스템에서 그 크기가 동일하며 모두 정수의 형태를 띈다.  
그래도 가리키고자 하는 변수의 자료형에 따라서 선언하는 방법이 다음과 같이 달라진다.

```c
int *pum1; // int * 는 int형 변수를 가리키는 pnum1의 선언을 의미함.

double * pnum2; // double * 는 double형 변수를 가리키는 pnum2의 선언을 의미함

unsigned int * pnum3; // unsigned int * 는 unsigned int형 변수를 가리키는 pnum3의 선언을 의미함
```

위의 예에서 볼 수 있듯이 포인터 변수 선언의 기본 공식은 다음과 같다.

```c
type * prt; //type형 변수의 주소 값을 저장하는 포인터 변수 prt의 선언
```



> 포인터의 형(Type)

int, char, double과 같이 변수의 선언 및 구분에 사용되는 키워드를 자료형이라 하듯이  
포인터 변수의 선언 및 구분에 사용되는 int *, char *, double * 등을 가리켜 포인터형이라 한다.  
하지만 포인터 변수도 값을 저장하는 변수이기 때문에 포인터 형 역시 자료형의 범주에 포함시키기도 한다.

int *							int형 포인터

int * pnum1;			int형 포인터 변수 pnum1

double *					double형 포인터

double * pnum2;	double형 포인터 변수 pnum2

즉 표현의 기본 원리는 다음과 같다.

type *						type형 포인터

type * ptr;				type형 포인터 변수 ptr



## 포인터와 관련 있는 연산자: & 연산자와 * 연산자

일반적으로 & 연산자와 * 연산자를 가리켜 포인터 연산자라고 한다.  
여기서 말하는 * 연산자는 곱셈 연산자를 말하는 것이 아니다. 곱셈 연산자는 이항 연산자인 반면, 포인터 연산자는 단항 연산자이다. * 연산자는 사용되는 위치에 따라 의미가 달라진다.



> 변수의 주소 값을 반환하는 & 연산자

&연산자는 피연산자의 주소 값을 반환하는 연산자이다.

```c
int	main(void)
{
	int num = 5;
    int * pum = &num;		//num의 주소 값을 반환해서 포인터 변수 pnum을 초기화
    ....
}
```

이처럼 & 연산자의 피연산자는 변수(variable)이어야 하며, 상수는 피연산자가 될 수 없다.  
그리고 다음과 같이 변수의 자료형에 맞지 않는 포인터 변수의 선언은 문제가 될 수 있다.

```c
int	main(void)
{
    int num1 = 5;
    double * pnum1 = &num1;		//일치하지 않음
    
    double num2 = 5;
    int * pnum2 = &num2;		//일치하지 않음
    ....
}
```

위와 같이 int형 변수의 주소 값을 double형 포인터 변수에 저장하거나 double형 변수의 주소 값을 int형 포인터 변수에 저장하는 것은 잘못된 것이다.  
비록 컴파일 에러는 발생하지 않지만 포인터 관련 연산시 문제가 발생한다.



> 포인터가 가리키는 메모리를 참조하는 * 연산자
>
> 
