# 매크로와 선행처리기(Preprocessor)

1-1에서는 실행파일이 컴파일과 링크의 과정을 거쳐서 만들어지는 것으로 설명하였다. 그러나 실제로는 컴파일 이전에 '선행처리'라는 과정을 거치게 된다.  
다만 이를 컴파일 과정에 포함시켜서 이야기 하는 것이 보통이기 때문에 1-1에서는 이를 별도로 구분하지 않았다.  
그러나 이번 챕터에서는 선행처리가 이야기의 핵심이기 때문에 이를 별도로 구분해서 언급하고자 한다.



## 목차

- 선행처리기와 매크로
- 대표적인 선행처리 명령문
- 조건부 컴파일(Conditional Compilation)을 위한 매크로
- 매개변수의 결합과 문자열화



## 선행처리기와 매크로

> 선행처리는 컴파일 이전의 처리를 의미합니다.

다음 그림에서 보이듯이 선행처리는 선행처리기에 의해서, 컴파일은 컴파일러에 의해서, 그리고 링크는 링커에 의해서 진행이 된다.  
그런데 이 그림에서는 컴파일 이전에 선행처리의 과정을 거친다는 점에 주목을 해야 한다.

![](./img/4-6/ex1.jpg)

위의 그림에서 보이듯이, 컴파일 과정을 거치게 되면 바이너리 데이터로 이루어진 오브젝트 파일이 생성된다.  
그렇다면 컴파일 이전에 진행되는 선행처리의 과정을 거치게 되면 어떠한 데이터로 채워진 파일이 생성될까?  
선행처리의 과정을 거쳐서 생성되는 파일도 그냥 소스파일일 뿐이다. 왜냐하면 소스파일의 형태가 그대로 유지되기 때문이다.  
선행처리기가 하는 일은 지극히 단순하다. 여러분이 삽입해 놓은 선행처리 명령문대로 소스코드의 일부를 수정할 뿐인데, 여기서 말하는 수정이란, 단순 치환(substitution)의 형태를 띠는 경우가 대부분이다.  
예를 들어보면, 다음은 가장 간단한 선행처리 명령문이다.

```c
#define PI 3.14
```

이처럼 선행처리 명령문은 # 문자로 시작을 하며, 컴파일러가 아닌 선행처리기에 의해서 처리되는 문장이기 때문에 명령문의 끝에 세미콜론을 붙이지 않는다.  
그리고 이렇게 구성이 된 명령문은 선행처리기에게 다음과 같은 메시지를 전달한다.

__PI를 만나면 인정사정 볼 것 없이 3.14로 치환하여라__

따라서 위의 명령문이 삽입되어 있는 소스파일은 선행처리의 과정에서 다음과 같은 방식으로 변환이 된다.

![](./img/4-6/ex2.jpg)

참고로 여기서 말하는 '선행처리'란, 컴파일 이전의 처리를 의미한다.  
따라서 소스파일은 컴파일러에 의해서 컴파일 되기 이전에, 선행처리기에 의해서 선행처리의 과정을 거치게 된다고 이야기한다.



## 대표적인 선행처리 명령문



> #define: Object-like macro

앞서 정의한 #define 명령문을 다시 한번 관찰해보자.

![](./img/4-6/ex3.jpg)

위 그림에서 보이듯이 선행처리 명령문은 기본적으로 세 부분으로 나뉘는데, 제일 먼저 등장하는 #define을 가리켜 '지시자'라 한다.  
선행처리기가 이 부분을 보고 프로그래머가 지시하는 바를 파악하기 때문에 지시자라 하는 것이다.  
그리고 앞서 설명해씃이 #define 지시자는 선행처리기에게 다음과 같은 내용을 지시한다.

__이어서 등장하는 매크로를 마지막에 등장하는 매크로 몸체로 치환하라__

위의 그림에서 보이듯이, #define 지시자 뒤에 등장하는 것을 가리켜 '매크로'라 하고, 그 뒤에 등장하는 것을 가리켜 '매크로 몸체(또는 대체 리스트)'라 한다.  
따라서 위의 선행처리 명령문은 다음의 내용을 선행처리기에게 지시한다.

__매크로 PI를 매크로 몸체 3.1415로 전부 치환하라.__

결과적으로 PI라는 이름의 매크로는 그 자체로 상수 3.1415가 된 셈이다. 참고로 PI와 같은 매크로를 가리켜 '오브젝트와 유사한 매크로(object-like macro)'또는 그냥 간단히 '매크로 상수'라 한다.  
그럼 다음 예제를 통해서 매크로 상수가 적용된 예와 그 결과를 확인해보자.



MacroConst.c

```c
#include <stdio.h>

#define NAME	"홍길동"
#define AGE		24
#define PRINT_ADDR	puts("주소: 경기도 고양시\n");

int main(void)
{
    printf("이름: %s \n" NAME);
    printf("나이: %d \n", AGE);
    PRINT_ADDR;
    return 0;
}
```



실행 결과

```
이름: 홍길동
나이: 24
주소: 경기도 고양시
```



참고로 위 예제에서 보이는 매크로처럼 매크로의 이름은 대문자로 정의하는 것이 일반적이다.  
대문자로 정의함으로써 이 식별자가 매크로라는 사실을 부각시킬수 있기 때문이다.



> define: Function-like macro

매크로는 매개변수가 존재하는 형태로도 정의할 수 있다.  
그리고 이렇게 매개변수가 존재하는 매크로는 그 동작방식이 마치 함수와 유사하여 '함수와 유사한 매크로(function-like macro)'라 하는데, 줄여서 간단히 '매크로 함수'라 부르기도 한다.  
다음은 매크로 함수의 예이다.

```
#define SQUARE(X) X*X
```

#define으로 시작을 하는 것은 매크로 상수의 정의와 동일하다. 그러나 매크로에 괄호가 등장함으로 인해서 아래 그림에서 보이는 바와 같이 해석이 된다.  
여기서 괄호 안에 존재하는 X는(X라는 이름이 중요한 것이 아니라, 괄호 안에 존재한다는 사실이 중요하다. X라는 이름은 바꿔도 된다.) 정해지지 않은 임의의 값(또는 문장)을 의미한다.

![](./img/4-6/ex4.jpg)

그리고 위 그림에서 정의한 매크로를 접한 선행처리기는 SQUARE(X)와 동일한 패턴을 만나면, 무조건 X*X로 치환해버린다.  
예를 들어서 위의 매크로 정의 이후에 다음과 같은 문장을 접했다고 가정해보자.

```
SQUARE(123);
SQUARE(NUM);
```

그러면 선행처리 후에는 다음과 같이 변경이 된다.

```
123*123;
NUM*NUM;
```

이러한 변환의 결과가 마치 함수의 호출과 유사하지 않은가? 참고로 이렇게 선행처리기에 의해서 변환되는 과정 자체를 가리켜 '매크로 확장(macro expanstion)'이라 한다.  
그럼 예제를 통해서 매크로 확장의 결과를 확인해 보겠다.



MacroFunction.c

```c
#include <stdio.h>
#define SQUARE(X) X*X

int main(void)
{
    int num = 20;
    
    /* 정상적 결과 출력 */
    printf("Square of num: %d \n", SQUARE(num));
    printf("Square of -5: %d \n", SQUARE(-5));
    printf("Square of 2.5: %g \n", SQUARE(2.5));
    
    /* 비정상적 결과 출력 */
    printf("Sqaure of 3+2: %d \n", SQUARE(3+2));
    return 0;
}
```



실행 결과

```
Sqaure of num: 400
Sqaure of -5: 25
Sqaure of 2.5: 6.25
Sqaure of 3+2: 11
```



> 잘못된 매크로 정의

앞서 보인 예제의 2행에 정의된 매크로에 어떠한 문제가 있는지 살펴보겠다. 이 예제 14행에는 다음 문장이 있다.

```c
SQUARE(3+2)
```

이를 함수의 관점에서 본다면 3과 2의 합인 5를 SQUARE 함수의 인자로 전달하는 것으로 생각하는 것이 당연하다. 즉 25가 반환되어야 한다. 그러나 출력결과는 11이다. 무엇이 문제일까?  
먼저 연산을 하고, 그 연산결과를 가지고 함수를 호출하게끔 돕는 것은 컴파일러이지 선행처리기가 아니다. 그런데 매크로는 선행처리기에 의해서 처리가 된다.  
때문에 위의 문장은 단순히 다음과 같이 치환될뿐이다.

```C
3+2*3+2
```

따라서 결과로 11이 출력되는 것은 아주 당연한 일이다. 그렇다면 해결책은 무엇인가?  
위 예제 14행의 SQUARE를 다음과 같이 구성하면 된다.

```c
SQUARE((3+2))
```

그러면 다음과 같이 치환이 되어 문제는 해결된다.

```c
(3+2)*(3+2)
```

그러나 이는 함수를 호출하는(매크로인 SQUARE를 그냥 함수라 하자) 사람에게 주의를 요하는 형태이기 때문에 안정적이지 못하다.  
안정적인 형태가 되려면, 위 예제 14행의 실행결과로 25가 출력되어야 한다. 그래야 보다 함수답기 때문이다.



> 매크로 몸체에 괄호를 여러번 치자

예제 MacroFuntion.c의  매크로를 다음과 같이 정의하면, 14행에는 정상적인 값의 출력을 기대할 수 있다.

```c
#define SQUARE(X) (X)*(X)
```

14행 SQUARE 매크로가 다음과 같이 치환되기 때문이다.

```c
(3+2)*(3+2)
```

그러나 여전히 문제는 남아있다. 다음 문장을 예로 들겠다.

```c
int num = 120 / SQUARE(2);
```

SQUARE(2)는 4이므로 변수 num이 30으로 초기화될 것을 기대할 수 있다. 그런데 실제로 초기화되는 값은 120이다. 왜냐하면 다음과 같이 치환되어 나눗셈이 먼저 진행되기 때문이다.

```c
int num = 120 (2) * (2)
```

따라서 이런 저런 문제를 모두 해결하기 위해서는 다음과 같은 형태로 매크로 함수를 정의해야 한다.  

```c
#define SQUARE (X) ((X) * (X))
```

이제 변수 num은 다음 식에 의해서 30으로 초기화된다.

```c
int num = 120 / ( (2) * (2) );
```

이처럼 매크로 함수를 정의할 때에는 매크로의 몸체부분을 구성하는 X와 같은 전달인자 하나하나에 괄호를 해야 함은 물론이고, 반드시 전체를 괄호로 한번 더 묶어줘야 한다는 사실을 기억하자.



> 매크로를 두 줄에 걸쳐서 정의하려면 어떻게 해야할까?

