# 매크로와 선행처리기(Preprocessor)

1-1에서는 실행파일이 컴파일과 링크의 과정을 거쳐서 만들어지는 것으로 설명하였다. 그러나 실제로는 컴파일 이전에 '선행처리'라는 과정을 거치게 된다.  
다만 이를 컴파일 과정에 포함시켜서 이야기 하는 것이 보통이기 때문에 1-1에서는 이를 별도로 구분하지 않았다.  
그러나 이번 챕터에서는 선행처리가 이야기의 핵심이기 때문에 이를 별도로 구분해서 언급하고자 한다.



## 목차

- 선행처리기와 매크로
- 대표적인 선행처리 명령문
- 조건부 컴파일(Conditional Compilation)을 위한 매크로
- 매개변수의 결합과 문자열화



## 선행처리기와 매크로

> 선행처리는 컴파일 이전의 처리를 의미합니다.

다음 그림에서 보이듯이 선행처리는 선행처리기에 의해서, 컴파일은 컴파일러에 의해서, 그리고 링크는 링커에 의해서 진행이 된다.  
그런데 이 그림에서는 컴파일 이전에 선행처리의 과정을 거친다는 점에 주목을 해야 한다.

![](./img/4-6/ex1.jpg)

위의 그림에서 보이듯이, 컴파일 과정을 거치게 되면 바이너리 데이터로 이루어진 오브젝트 파일이 생성된다.  
그렇다면 컴파일 이전에 진행되는 선행처리의 과정을 거치게 되면 어떠한 데이터로 채워진 파일이 생성될까?  
선행처리의 과정을 거쳐서 생성되는 파일도 그냥 소스파일일 뿐이다. 왜냐하면 소스파일의 형태가 그대로 유지되기 때문이다.  
선행처리기가 하는 일은 지극히 단순하다. 여러분이 삽입해 놓은 선행처리 명령문대로 소스코드의 일부를 수정할 뿐인데, 여기서 말하는 수정이란, 단순 치환(substitution)의 형태를 띠는 경우가 대부분이다.  
예를 들어보면, 다음은 가장 간단한 선행처리 명령문이다.

```c
#define PI 3.14
```

이처럼 선행처리 명령문은 # 문자로 시작을 하며, 컴파일러가 아닌 선행처리기에 의해서 처리되는 문장이기 때문에 명령문의 끝에 세미콜론을 붙이지 않는다.  
그리고 이렇게 구성이 된 명령문은 선행처리기에게 다음과 같은 메시지를 전달한다.

__PI를 만나면 인정사정 볼 것 없이 3.14로 치환하여라__

따라서 위의 명령문이 삽입되어 있는 소스파일은 선행처리의 과정에서 다음과 같은 방식으로 변환이 된다.

![](./img/4-6/ex2.jpg)

참고로 여기서 말하는 '선행처리'란, 컴파일 이전의 처리를 의미한다.  
따라서 소스파일은 컴파일러에 의해서 컴파일 되기 이전에, 선행처리기에 의해서 선행처리의 과정을 거치게 된다고 이야기한다.



## 대표적인 선행처리 명령문



> #define: Object-like macro

앞서 정의한 #define 명령문을 다시 한번 관찰해보자.

![](./img/4-6/ex3.jpg)

위 그림에서 보이듯이 선행처리 명령문은 기본적으로 세 부분으로 나뉘는데, 제일 먼저 등장하는 #define을 가리켜 '지시자'라 한다.  
선행처리기가 이 부분을 보고 프로그래머가 지시하는 바를 파악하기 때문에 지시자라 하는 것이다.  
그리고 앞서 설명해씃이 #define 지시자는 선행처리기에게 다음과 같은 내용을 지시한다.

__이어서 등장하는 매크로를 마지막에 등장하는 매크로 몸체로 치환하라__

위의 그림에서 보이듯이, #define 지시자 뒤에 등장하는 것을 가리켜 '매크로'라 하고, 그 뒤에 등장하는 것을 가리켜 '매크로 몸체(또는 대체 리스트)'라 한다.  
따라서 위의 선행처리 명령문은 다음의 내용을 선행처리기에게 지시한다.

__매크로 PI를 매크로 몸체 3.1415로 전부 치환하라.__

결과적으로 PI라는 이름의 매크로는 그 자체로 상수 3.1415가 된 셈이다. 참고로 PI와 같은 매크로를 가리켜 '오브젝트와 유사한 매크로(object-like macro)'또는 그냥 간단히 '매크로 상수'라 한다.  
그럼 다음 예제를 통해서 매크로 상수가 적용된 예와 그 결과를 확인해보자.



MacroConst.c

```c
#include <stdio.h>

#define NAME	"홍길동"
#define AGE		24
#define PRINT_ADDR	puts("주소: 경기도 고양시\n");

int main(void)
{
    printf("이름: %s \n" NAME);
    printf("나이: %d \n", AGE);
    PRINT_ADDR;
    return 0;
}
```



실행 결과

```
이름: 홍길동
나이: 24
주소: 경기도 고양시
```



참고로 위 예제에서 보이는 매크로처럼 매크로의 이름은 대문자로 정의하는 것이 일반적이다.  
대문자로 정의함으로써 이 식별자가 매크로라는 사실을 부각시킬수 있기 때문이다.



> define: Function-like macro

