# 매크로와 선행처리기(Preprocessor)

1-1에서는 실행파일이 컴파일과 링크의 과정을 거쳐서 만들어지는 것으로 설명하였다. 그러나 실제로는 컴파일 이전에 '선행처리'라는 과정을 거치게 된다.  
다만 이를 컴파일 과정에 포함시켜서 이야기 하는 것이 보통이기 때문에 1-1에서는 이를 별도로 구분하지 않았다.  
그러나 이번 챕터에서는 선행처리가 이야기의 핵심이기 때문에 이를 별도로 구분해서 언급하고자 한다.



## 목차

- 선행처리기와 매크로
- 대표적인 선행처리 명령문
- 조건부 컴파일(Conditional Compilation)을 위한 매크로
- 매개변수의 결합과 문자열화



## 선행처리기와 매크로

> 선행처리는 컴파일 이전의 처리를 의미합니다.

다음 그림에서 보이듯이 선행처리는 선행처리기에 의해서, 컴파일은 컴파일러에 의해서, 그리고 링크는 링커에 의해서 진행이 된다.  
그런데 이 그림에서는 컴파일 이전에 선행처리의 과정을 거친다는 점에 주목을 해야 한다.

![](./img/4-6/ex1.jpg)

위의 그림에서 보이듯이, 컴파일 과정을 거치게 되면 바이너리 데이터로 이루어진 오브젝트 파일이 생성된다.  
그렇다면 컴파일 이전에 진행되는 선행처리의 과정을 거치게 되면 어떠한 데이터로 채워진 파일이 생성될까?  
선행처리의 과정을 거쳐서 생성되는 파일도 그냥 소스파일일 뿐이다. 왜냐하면 소스파일의 형태가 그대로 유지되기 때문이다.  
선행처리기가 하는 일은 지극히 단순하다. 여러분이 삽입해 놓은 선행처리 명령문대로 소스코드의 일부를 수정할 뿐인데, 여기서 말하는 수정이란, 단순 치환(substitution)의 형태를 띠는 경우가 대부분이다.  
예를 들어보면, 다음은 가장 간단한 선행처리 명령문이다.

```c
#define PI 3.14
```

이처럼 선행처리 명령문은 # 문자로 시작을 하며, 컴파일러가 아닌 선행처리기에 의해서 처리되는 문장이기 때문에 명령문의 끝에 세미콜론을 붙이지 않는다.  
그리고 이렇게 구성이 된 명령문은 선행처리기에게 다음과 같은 메시지를 전달한다.

__PI를 만나면 인정사정 볼 것 없이 3.14로 치환하여라__

따라서 위의 명령문이 삽입되어 있는 소스파일은 선행처리의 과정에서 다음과 같은 방식으로 변환이 된다.

![](./img/4-6/ex2.jpg)

참고로 여기서 말하는 '선행처리'란, 컴파일 이전의 처리를 의미한다.  
따라서 소스파일은 컴파일러에 의해서 컴파일 되기 이전에, 선행처리기에 의해서 선행처리의 과정을 거치게 된다고 이야기한다.



> 대표적인 선행처리 명령문

