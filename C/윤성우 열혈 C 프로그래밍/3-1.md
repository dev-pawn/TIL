# 다차원 배열



## 목차

- [다차원 배열의 이해와 활용](#다차원-배열의-이해와-활용)
- 3차원 배열



## 다차원 배열의 이해와 활용

다차원 배열은 2차원 이상의 배열을 의미한다. 즉 2차원, 3차원 배열을 총칭해서 다차원 배열이라 한다.

> 2차원, 3차원 배열? OK! 4차원, 5차원 배열? NO!

1차원 배열은 논리적으로 1차원의 형태를 띈다. 마찬가지로 2차원 3차원 배열은 논리적으로 각각 2차원과 3차원의 형태를 띤다.  
즉, 2차원 배열은 평면구조의 배열이고, 3차원 배열은 직육면체 구조의 배열이다.

C언어의 문법은  4차원 이상의 배열선언을 문법적으로 허용하고 있다.  
하지만 이는 불필요하기도 하고 논리적으로 이해하기도 어려운 형태의 배열이다. 따라서 다차원 배열은 2차원 배열과 3차원 배열을 의미하는 것으로 이해하면 된다.  
참고로 1차원, 2차원, 3차원 배열의 선언형태는 다음과 같다.

```c
int arrOneDim[10];			길이가 10인 1차원 int형 배열
int arrTwoDim[5][5];		가로, 세로의 길이가 각각 5인 2차원 int형 배열
int arrThreeDim[3][3][3];	가로, 세로, 높이의 길이가 각각 3인 3차원 int형 배열
```

이 중에서 실제로 많이 사용되는 것은 1차원 배열과 2차원 배열이다.  
따라서 사실상 2차원 배열이 다차원 배열을 대표한다고 보면 된다.



> 다차원 배열을 대표하는 2차원 배열의 선언

다음 두 2차원 배열의 선언을 보자.

```c
int arr1[3][4];			//세로가 3, 가로가 4인 int형 2차원 배열
int arr2[2][6];			//세로가 2, 가로가 6인 int형 2차원 배열
```

위에서 보이는 것처럼 2차원 배열의 선언 방식은 1차원 배열의 선언 방식과 매우 유사하다.  
다만 그 특성상 세로와 가로의 길이를 각각 명시하는 형태를 띨 뿐이다.  
정리하자면 배열의 이름이 arr이고 배열요소의 자료형이 TYPE이라 할 때, 2차원 배열의 선언 형태는 다음과 같다.

```c
TYPE arr[세로길이][가로길이]
```

이전에 sizeof 연산자의 피연산자로 배열의 이름이 오면, 배열의 크기가 바이트 단위로 계산되어서 반환됨을 설명하였다.  
그런데 이는 2차원 배열의 경우에도 해당이 되니, sizeof 연산자를 이용해서 2차원 배열의 크기를 계산해보도록 하겠다.



TwoDimArraySize.c

```c
#include <stdio.h>

int main(void)
{
    int arr1[3][4];
    int arr2[7][9];
    printf("세로3, 가로4: %d \n", sizeof(arr1));
    printf("세로7, 가로9: %d \n", sizeof(arr1));
    return 0;
}
```



실행 결과

```
세로3, 가로4: 48
세로7, 가로9: 252
```

3 x 4 x 4 는 48이고, 7 x 9 x 4는 252이다. 따라서 sizeof 연산자가 2차원 배열의 크기를 정확히 계산해서 반환하고 있음을 실행결과를 통해 확인할 수 있다.



> 2차원 배열요소의 접근

이름이 arr인 int형 배열을 대상으로 세로 N번째 위치(1부터 시작해서 N번째), 그리고 가로 M번째 위치(1부터 시작해서 M번째)에 저장된 값을 변경 및 참조하는 방법을 일반화하면 아래와 같다.

```c
arr[N-1][M-1] = 20;					// 세로 N, 가로 M의 위치에 정수 20을 저장
printf("%d", arr[N-1][M-1]);		// 세로 N, 가로 M의 위치에 저장된 값 출력
```



지금까지 이야기한 내용을 바탕으로 층별로 두 가구가 사는 4층짜리 빌라의 가구별 거주인원 수를 입력 받는 예제를 작성해보자.



PopuResearch.c

```c
#include <stdio.h>

int main(void)
{
	int villa[4][2];
    int popu, i, j;
    
    /* 가구별 거주 인원 입력 받기 */
    for(i=0; i<4; i++)
    {
        for(j=0; j<2; j++)
        {
            printf("%d층 %d호 인구수: ", i+1, j+1);
            scanf("%d", &villa[i][j]);
        }
	}
    
    /* 빌라의 층별 인구수 출력하기 */
    for(i=0; i<4; i++)
    {
        popu = 0;
        popu += villa[i][0];
        popu += villa[i][1];
        printf("%d층 인구수: %d \n", i+1, popu);
    }
    return 0;
}
```



실행 결과

```
1층 1호 인구수: 2
1층 2호 인구수: 4
2층 1호 인구수: 3
2층 2호 인구수: 5
3층 1호 인구수: 2
3층 2호 인구수: 6
4층 1호 인구수: 4
4층 2호 인구수: 3
1층 인구수: 6
2층 인구수: 8
3층 인구수: 8
4층 인구수: 7
```

참고로 위의 예제는 1차원 배열로도 구현이 가능하다. 하지만 이는 프로그램을 복잡하게 만들뿐이다.  
사실 모든 2차원 배열은 1차원 배열로 대신 할 수 있다. 그러나 그렇게 해서 얻게 되는 이점은 아무것도 없다.



> 2차원 배열의 메모리상 할당의 형태

2차원 배열은 물리적으로도 2차원의 형태로 존재할까? 이는 메모리의 주소 값을 통해서 알 수 있다.  
예제를 통해 알아보자.



TwoDimArrayAddr.c

```c
#include <stdio.h>

int main(void)
{
    int arr[3][2];
    int i, j;
    for(i=0; i<3; i++)
    {
        for(j=0; j<2; j++)
        {
            printf("%p \n", &arr[i][j]);
		}
    }
    return 0;
}
```



실행 결과

```
002AFD54
002AFD58
002AFD5C
002AFD60
002AFD64
002AFD68
```



> 2차원 배열 선언과 동시에 초기화하기

1차원 배열과 마찬가지로 2차원 배열도 선언과 동시에 초기화가 가능하다.

```c
int arr[3][3] = {
	{1, 2, 3},
	{4, 5, 6},
	{7, 8, 9}
};
```

위와 같이 초기화 리스트 안에는 행 단위로 초기화할 값들을 별도의 중괄호로 명시해야 한다.  
물론 모든 배열의 요소를 초기화 해야 하는 것은 아니다. 다음과 같이 일부 요소에 대해서는 초기화를 생략할 수  있다.  
그리고 이렇게 해서 비는 공간은 1차원 배열과 마찬가지로 0으로 초기화 된다.

```c
int arr[3][3] = {
	{1},
	{4, 5},
	{7, 8, 9}
};
```

마지막으로, 다음과 같이 하나의 중괄호 안에 초기화할 값을 순서대로 나열할 수도 있다.

```c
int arr[3][3] = {1, 2, 3, 4, 5, 6, 7};
```

그런데 이 경우에도 8번째 요소와 9번째 요소는 0으로 초기화가 이뤄지니, 이는 다음의 배열 선언과 동일한 결과로 이어진다.

```c
int arr[3][3] = {1, 2, 3, 4, 5, 6, 7, 0, 0};
```



이제 지금까지 설명한 초기화 관련내용의 확인을 위한 예제를 살펴보며 초기화를 마무리하겠다.



TwoDimArrayInit.c

```c
#include <stdio.h>

int main(void)
{
	int i, j;
	
	/* 2차원 배열 초기화의 예 1 */
	int arr1[3][3] = {
		{1, 2, 3},
		{4, 5, 6},
		{7, 8, 9}
	};
	
	/* 2차원 배열 초기화의 예 2 */
	int arr2[3][3] = {
		{1},
		{4, 5},
		{7, 8, 9}
	};
	
	/* 2차원 배열 초기화의 예 3 */
	int arr3[3][3] = {1, 2, 3, 4, 5, 6, 7};
	
	for(i=0; i<3; i++)
	{
		for (j=0; j < 3; j++)
			printf("%d ", arr1[i][j]);
		printf("\n");
	}
	printf("\n");
	
	for(i=0; i<3; i++)
	{
		for (j=0; j < 3; j++)
			printf("%d ", arr2[i][j]);
		printf("\n");
	}
	printf("\n");
	
	for(i=0; i<3; i++)
	{
		for (j=0; j < 3; j++)
			printf("%d ", arr3[i][j]);
		printf("\n");
	}
	return 0;
}
```



실행 결과

```c
1 2 3
4 5 6
7 8 9

1 0 0
4 5 0
7 8 9

1 2 3
4 5 6
7 0 0
```

