# 다차원 배열과 포인터의 관계



## 목차

- 2차원 배열이름의 포인터 형
- 2차원 배열이름의 특성과 주의사항



## 2차원 배열이름의 포인터 형

> 1차원 배열이름의 포인터 형과 2차원 배열이름의 포인터 형

아래 배열이름의 포인터 형은 무엇인가?

```c
int arr[10];			// arr은 int형 포인터
```

여기서 arr는 int형 포인터이다. 따라서 다음과 같이 함수의 인자로 전달되기 위해서는

```c
SimpleFunc(arr);
```

함수의 매개변수가 다음과 같이 int형 포인터로 선언되어야 한다.

```c
void	SimpleFunc(int * ptr)
{
	....
}
```



그런데 이를 토대로 다음과 같이 오해하는 경우가 흔히 발생한다.

```
int형 2차원 배열의 이름은 int형 더블 포인터이니(이것이 잘못되었다), int형 2차원 배열의 이름을 인자로 전달받으려면, 매개변수로 int형 더블 포인터 변수가 선언되어야 한다.
```

그리고 이러한 오해를 근거로 다음과 같은 코드를 작성하기도 한다.

```c
void	ComplexFunc(int ** ptr)
{
	....
}
int main(void)
{
	int arr2d[2][3];
    ComplexFunc(arr2d);		//int형 2차원 배열의 이름 전달
    ....
}
```

위의 코드에서 잘못된 것은 무엇일까?  
위의 코드에서는 배열 arr2d의 이름이 int ** 형 포인터로 매개변수로 넘어가고 있는데 이는 잘못되었다.  
앞에서 우리는 ``int * parr[20];`` 포인터 배열의 이름 parr이 int **형 포인터 임을 확인하였다.  
따라서 2차원 배열의 이름은 더블 포인터 형이 아니다.



> 2차원 배열이름이 가리키는 것들은?

다음과 같이 선언된 2차원 배열이 있다고 가정해보자.

```c
int arr2d[3][3];
```

그렇다면 배열이름 arr2d가 가리키는 것은 인덱스 기준으로 &#91;0]&#91;0]에 위치한 첫 번째 요소이다.  
그런데 2차원 배열의 경우는 arr2d[0], arr2d[1], arr2d[2]도 의미를 갖는다. 이들은 각각 1행, 2행, 3행의 첫 번째 요소를 가리킨다.  
따라서 2차원 배열의 첫 번째 요소의 주소 값 출력을 위해서는 다음 두 가지 형태의 문장을 구성해볼 수 있다.

```c
printf("%p", arr2d);
printf("%p", arr2d[0]);
```

실제로 위 두 문장의 출력결과는 동일하다.  
그렇다면 arr2d와 arr2d[0]은 같은 것일까? 사실 이는 매우 중요한 질문이다.  
예제를 통해 살펴보자.



2DArrayAddress.c

```c
#include <stdio.h>

int main(void)
{
	int arr2d[3][3];
	printf("%d \n", arr2d);
	printf("%d \n", arr2d[0]);
	printf("%d \n\n", &arr2d[0][0]);
	
	printf("%d \n", arr2d[1]);
	printf("%d \n\n", &arr2d[1][0]);
	
	printf("%d \n", arr2d[2]);
	printf("%d \n\n", &arr2d[2][0]);
	
	printf("sizeof(arr2d): %d \n", sizeof(arr2d));
	printf("sizeof(arr2d[0]): %d \n", sizeof(arr2d[0]));
	printf("sizeof(arr2d[1]): %d \n", sizeof(arr2d[1]));
	printf("sizeof(arr2d[2]): %d \n", sizeof(arr2d[2]));
	return 0;
}
```



실행 결과

```c
4585464
4585464
4585464

4585476
4585476

4585488
4585488

sizeof(arr2d): 36
sizeof(arr2d[0]): 12
sizeof(arr2d[1]): 12
sizeof(arr2d[2]): 12
```

위의 예제의 실행 결과를 살펴보면  

- 배열이름 arr2d를 대상으로 sizeof 연산을 하는 경우 배열 전체 크기를 반환하고
- arr2d[0], arr2d[1], arr2d[2]를 대상으로 sizeof 연산을 하는 경우 각 행의 크기를 반환하는 것을 알 수 있다.

이를 기반으로__arr2d는 첫 번째 요소를 가리키면서 배열 전체를 의미하고, arr2d[0]는 첫 번째 요소를 가리키되 1행만을 의미함을 알 수 있다.__



> 배열이름 기반의 포인터 연산: 배열이름에 1을 더한 결과는?

```c
int iarr[3];		// iarr은 int형 포인터
double darr[7];		// darr은 double형 포인터
```

위에 선언된 두 배열을 대상으로 다음 문장을 실행하면 출력결과는 어떻게 되겠는가?

```c
printf("%p", iarr+1);
printf("%p", darr+1);
```



배열이름 iarr는 int형 포인터이므로 iarr+sizeof(int)의 계산결과가 출력되고,  
배열이름 darr는 double형 포인터이므로 darr+szieof(double)의 계산결과가 출력된다.  
이를 바탕으로 다음과 같이 정리할 수 있다.

__두 포인터의 포인터 형이 같다면, 두 포인터를 대상으로 하는 증가 및 감소연산의 결과로 증가 및 감소하는 값의 크기는 동일하다.__

사실 여기까지는 앞에서 이미 공부한 내용이다. 그렇다면 2차원 배열이름을 대상으로 증가연산을 진행하여 이를 바탕으로 2차원 배열이름의 포인터 형을 결정짓는 힌트를 얻어보자.



2DArrPointerOp.c

```c
#include <stdio.h>

int main(void)
{
	int arr1[3][2];
	int arr2[2][3];
	
	printf("arr1: %p \n", arr1);
	printf("arr1+1: %p \n", arr1+1);
	printf("arr1+2: %p \n\n", arr1+2);
	
	printf("arr2: %p \n", arr2);
	printf("arr2+1: %p \n", arr2+1);
	return 0;
}
```



실행 결과

```
arr1: 004BFBE0
arr1+1: 004BFBE8
arr1+2: 004BFBF0

arr2: 004BFBC0
arr2+1: 004BFBCC
```

실행 결과를 보면 arr1을 대상으로 값을 1씩 증가시키면 주소 값이 8씩 증가하고, arr2를 대상으로 값을 1씩 증가시키면 주소 값이 12씩 증가하였음을 알 수 있다.  
이렇듯 2차원 배열이름을 대상으로 증가 및 감소연산을 할 경우, 연산결과는 각 행의 첫 번째 요소의 주소 값이 된다.  
즉, arr1이 1행의 첫 번째 요소를 가리키면, arr1+1이 반환하는 주소 값은 2행의 첫 번째 요소를 가리키게 되고, arr1+2가 반환하는 주소 값은 3행의 첫 번째 요소를 가리키게 된다.  
때문에 2차원 배열을 이루는 요소의 자료형이 동일하더라도 배열의 가로길이가 다르면, 위 예제에서 처럼 배열이름을 대상으로 하는 포인터 연산의 결과는 달라진다.  
__2차원 배열이름의 포인터 형은 가로 길이에 따라서도 달라진다.  
그리고 그것이 1차원 배열이름의 포인터형을 결정하는 것과 달리, 2차원 배열이름의 포인터 형 결정을 어렵게 하는 이유가 된다.__



> 최종결론 2차원 배열이름의 포인터 형

