# 상수와 기본 자료형



## 목차

- C언어가 제공하는 기본 자료형의 이해
- 문자의 표현방식과 문자를 위한 자료형
- 상수에 대한 이해
- 자료형의 변환



## C언어가 제공하는 기본 자료형의 이해

> 자료형은 데이터를 표현하는 방법입니다.

우리는 공간을 할당하기에 앞서 아래의 내용을 먼저 결정해야 한다.

__정수를 저장할 것인지, 실수를 저장할 것인지, 문자열을 저장할 것인지__

따라서 메모리 공간을 할당할 때, 그 용도가 결정되어야 한다.  
정수를 저장하기로 했다면 이어서 다음의 내용도 결정해야 한다.

__정수를 저장하기 위해서 몇 바이트를 사용할까요?__

정수는 몇 바이트를 사용하건 저장할 수 있다. 다만 바이트의 크기가 크면 클수록 저장할 수 있는 정수의 크기가 커질 뿐이다.  
정리하자면 num이라는 이름의 변수를 선언하기 위해서는 프로그램상에서 다음과 같은 내용을 담은 문장을 구성해야 한다.

__정수를 저장할것이고, 크기는 4바이트로, 변수의 이름은 num으로 한다.__

이 문장을 나타내는 키워드가 바로 __int__이다. 따라서 아래와 같이 간단하게 표현이 가능하다.

__int num;__

즉, __자료형(data type)이란?__ 데이터를 표현하는 방법을 뜻한다.



> 기본 자료형의 종류와 데이터의 표현범위

기본적으로 제공되는 자료형을 __기본 자료형__이라 하며, 그 종류와 특징은 아래와 같다.

![](./img/1-5/ex1.jpg)

위의 표에서도 알수 있듯이 같은 정수 자료형이라고 하더라도 바이트의 크기가 커질수록 표현범위가 넓어짐을 알 수 있다.  
참고로 C의 표준을 정하는 ANSI에서는 아래와 같이 자료형의 크기를 표준화하고 있다.

__short과 int는 최소 2바이트이되, int는 short와 크기가 같거나 더 커야 한다.__

즉, __자료형 별 크기를 정확히 제한하고 있지 않다.__   
따라서 자료형 별 크기는 컴파일러마다 차이를 보인다.

이렇게 많은 수의 자료형을 제공하는 이유는 무엇일까? 그 이유는

1. 데이터의 표현방식이 다르므로, 최소 둘 이상의 자료형이 필요하다.

   위의 표를 보면 알 수 있듯이 자료형의 종류는 크게 정수 자료형과 실수 자료형으로 나뉜다.  
   이렇게 크게 두 가지로 나눠놓은 이유는 컴퓨터가 정수와 실수를 표현하는 방식이 다르기 때문이다.  
   따라서 정수와 실수를 각각 표현하기 위해 자료형은 최소 2가지는 있어야 한다.  
   하지만 위의 표를 살펴보면 2가지가 훨씬 넘는 종류의 자료형이 있음을 알 수 있는데 그 이유는

   

2. 메모리 공간의 적절한 사용을 위해서 다양한 크기의 자료형이 필요하다.

   예를 들어 5000개의 정수를 저장한다고 가정했을때, 이 정수들은 short형으로 표현이 가능한 정수들이다.  
   따라서 이 정수들을 short로 표현하여 저장한다면 총 5000*2=10000바이트가 소모된다.  
   반면, 이를 int형으로 저장한다면, 이의 두 배에 해당하는 바이트 수가 소모되어 그만큼 메모리를 낭비하는 결과로 이어질 수 있다.  
   즉, __메모리의 효율적 사용을 위해서 다양한 크기의 자료형이 존재하는 것이다.__

   

> 연산자 sizeof를 이용하면 자료형의 크기를 확인할 수 있습니다.

메모리 공간에서 소모하는 메모리의 크기를 바이트 단위로 계산하여 반환하는 sizeof라는 연산자가 존재한다.  
이 연산자의 피연산자로는 변수와 상수뿐만 아니라, 자료형의 이름도 올 수 있기 때문에 이 연산자를 사용하여  
자신이 사용하는 컴파일러의 자료형 별 바이트 크기도 확인할 수 있다.

sizeof 연산자의 사용법은 다음과 같다.

```c
int main(void) {
    int num = 10;
    int sz1 = sizeof(num);        //변수 num의 크기를 계산하여 sz1을 초기화
    int sz2 = sizeof(int);        //자료형 int의 크기를 계산하여 sz2를 초기화
    .....
}
```



위의 코드에서는 sizeof의 피연산자를 모두 소괄호로 감싸줬는데, __이 소괄호는 int와 같은 자료형의 이름에는 필수지만, 나머지 피연산자에 대해서는 선택적이다.__  
하지만 소괄호를 사용하는 것이 문장을 이해하는데 도움이 되기 때문에, __피연산자의 종류에 상관없이 무조건 소괄호를 사용하는 것이 일반적__이다.



SizeOfOperator.c

```c
#include <stdio.h>

int main(void){
    char ch=9;
    int inum=1052;
    double dnum=3.1415;
    printf("변수 ch의  크기: %d\n", sizeof(ch));
    printf("변수 inum의  크기: %d\n", sizeof(inum));
    printf("변수 dnum의  크기: %d\n", sizeof(dnum));
    
    printf("char의 크기: %d\n", sizeof(char));
    printf("int의 크기: %d\n", sizeof(int));
    printf("long의 크기: %d\n", sizeof(long));
    printf("long long의 크기: %d\n", sizeof(long long));
    printf("float의 크기: %d\n", sizeof(float));
    printf("double의 크기: %d\n", sizeof(double));
    return 0;
}
```



실행 결과

```
변수 ch의 크기: 1
변수 inum의 크기: 4
변수 dnum의 크기: 8
char의 크기: 1
int의 크기: 4
long의 크기: 4
long long의 크기: 8
float의 크기: 4
double의 크기: 8
```



> 정수를 표현 및 처리하기 위한 일반적인 자료형의 선택

정수형 변수의 자료형을 선택할 때, 가장 먼저 생각할 문제는 __저장하고자 하는 값의 범위__이다.  
예를 들어, short형 변수가 저장할 수 있는 값의 범위는 -32,768 ~ +32,767이하이다.  
이의 범위를 넘어서는 변수를 저장하기 위해서는 int형 변수를 선언해야 한다.  
그렇다면 저장하고자 하는 값이 short형 변수의 범위 내에 있다면 int형 변수를 선언하는것보다 short형 변수를 선언하는 것이 더 효율적일까? 그것은 상황에 따라 다르다.



CharShortBaseAdd.c

```c
#include <stdio.h>

int main(void){
    char num1=1, num2=2, result1=0;
    short num3=300, num4=400, result2=0;
    
    printf("size of num1 & num2: %d, %d\n", sizeof(num1), sizeof(num2));
    printf("size of num3 & num4: %d, %d\n", sizeof(num3), sizeof(num4));
    
    printf("size of char add: %d\n", sizeof(num1+num2));
    printf("size of short add: %d\n", sizeof(num3+num4));
    result1=num1+num2;
    result2=num3+num4;
    printf("size of result1 & result2: %d, %d\n", sizeof(result1), sizeof(result2));
    return 0;
}
```



실행 결과

```
size of num1 & num2: 1, 1
size of num3 & num4: 2, 2
size of char add: 4
size of short add: 4
size of result1 & result2: 1,2
```



위 예제의 핵심은 아래의 두 문장에 있다.

```c
    printf("size of char add: %d\n", sizeof(num1+num2));        //4
    printf("size of short add: %d\n", sizeof(num3+num4));       //4
```

위의 두 문장이 실행되는 순서를 정리하면

1. num1+num2
2. num1+num2의 결과로 반환되는 값을 대상으로 sizeof 연산
3. sizeof 연산의 반환 값을 대상으로 printf 함수를 호출

이처럼 __연산의 결과로 반환되는 값을 대상으로도 size of 연산이 가능하며__, 그 결과는 연산의 결과로 반환되는 값의 크기가 된다.

```
sizeof(num1+num2)   // num1+num2의 결과값의 크기를 바이트 단위로 반환
sizeof(num3+num4)   // num3+num4의 결과값의 크기를 바이트 단위로 반환
```



또한 위 예제를 다시 살펴보면 char형 덧셈 결과로 반환된 값의 크기는 1바이트, short형 덧셈 결과로 반환된 크기는 2바이트가 될 것 같은데, 출력 결과에서는 그 크기가 모두 4바이트임을 알 수 있다.  
이것은 __컴퓨터가 CPU성능을 내기 가장 좋은 연산인 int형으로 데이터를 바꿔서 연산이 진행된 것__이다.  
그러므로 __연산의 대상이 되는 변수를 선언하는 경우에는, 특히 연산의 경우가 빈번한 경우에는 저장되는 값의 크기가 작더라도 int형 변수를 사용하는 것이 좋다.__



> 실수를 표현 및 처리하기 위한 일반적인 자료형의 선택

실수형 데이터가 표현할 수 있는 값의 표현범위는 매우 넓다.  
double형이나 float형이나 둘 다 범위는 매우 넓기 때문에 값의 표현 범위는 중요한 요소가 되지 않는다.  
그렇다면 실수 자료형의 선택에 있어서 중요하게 고려되어야 할 요소는 무엇일까?

그것은 __정밀도__이다.

여기서 말하는 정밀도는 __오차가 발생하지 않는 소수점 이하의 자릿수__를 뜻한다.  
앞에서 실수의 표현에는 오차가 존재할 수 밖에 없음을 살펴보았다. 그런데 이러한 오차도 데이터 표현에 사용되는 바이트의 수가 커지면 줄어들기 마련이다.

| 실수 자료형 | 소수점 이하 정밀도 | 바이트 수 |
| :---------: | :----------------: | :-------: |
|    float    |       6자리        |     4     |
|   double    |       15자리       |     8     |
| long double |       18자리       |    12     |

정수 자료형에서는 보편적으로 int형을 선택하듯이 __실수 자료형에서는 보편적으로 double형을 선택__한다.(float형은 정밀도가 너무 낮음)



CircleArea.c

```c
#include <stdio.h>

int main(void){
    double rad;
    double area;
    printf("원의 반지름 입력: ");
    scanf("%lf, &rad");
    
    area = rad*rad*3.1415;
    printf("원의 넓이: %f\n", area);
    return 0;
}
```



실행 결과

```
원의 반지름 입력: 2.4
원의 넓이: 18.095040
```





> unsigned를 붙여서 0과 양의 정수만 표현하게 할 수 있습니다.

정수 자료형의 이름에 한해서 unsigned 선언을 추가하면, 0 이상의 값만 표현하는 자료형이 되어서 표현할 수 있는 값의 범위가 양의 정수 방향으로 두 배 더 넓어지게 된다.