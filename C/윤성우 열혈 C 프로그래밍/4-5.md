# 메모리 관리와 메모리의 동적 할당



## 목차

- C언어의 메모리 구조
- 메모리의 동적 할당



## C언어의 메모리 구조

프로그램을 실행하면 해당 프로그램의 실행을 위한 메모리 공간이 운영체제에 의해서 미리 마련이 된다. 그리고 바로 이 메모리 공간 내에서 변수가 선언되고, 문자열이 선언되는 것이다.



> 메모리의 구성

프로그램 실행 시 운영체제에 의해서 마련되는 메모리의 구조는 다음과 같이 네 개의 영역으로 구분이 된다.

![](./img/4-5/ex1.jpg)

이렇듯 메모리 공간을 나눠놓은 이유는 커다란 서랍장의 수납공간이 나뉘어 있는 이유와 유사하다.  
메모리 공간을 나눠서 유사한 성향의 데이터를 묶어서 저장을 하면, 관리가 용이해지고 메모리의 접근속도가 향상된다.  
서랍장의 수납공간이 나뉘어 있으면, 물건을 찾을 때 한결 수월하다. 이렇듯 메모리 공간을 나눠놓은 이유는 매우 단순하다.



> 메모리 영역별로 저장되는 데이터 유형

이어서 각 영역별 특성에 대해서 구체적으로 살펴보자.

__코드 영역(Code Area)__

코드 영역은 이름 그대로 실행할 프로그램의 코드가 저장되는 메모리 공간이다. 따라서 CPU는 코드 영역에 저장된 명령문들을 하나씩 가져가서 실행을 한다.

__데이터 영역(Data Area)__

데이터 영역에는 전역변수와 static으로 선언되는 static 변수가 할당된다. 즉, 이 영역에 할당되는 변수들은 프로그램의 시작과 동시에 메모리 공간에 할당되어 __프로그램 종료 시까지 남아있게 된다는 특징__이 있다.

__스택 영역(Stack Area)__

스택 영역에는 지역변수와 매개변수가 할당된다. 이렇듯 이 영역에 할당되는 변수들은 선언된 __함수를 빠져나가면 소멸된다는 특징__이 있다.

__힙 영역(Heap Area)__

데이터 영역에 할당되는 변수와 스택 영역에 할당되는 변수들은 생성과 소멸의 시점이 이미 결정되어 있다.  
그러나 프로그램을 구현하다 보면, 이 두 영역의 변수들과는 다른 성격의 변수가 필요하기도 하다. 그래서 C언어에서는 프로그래머가 원하는 시점에 변수를 할당하고 또 소멸하도록 지원을 하는데,  
바로 이러한 유형의 변수들이 할당되는 영역이 힙 영역이다. 이 힙 영역을 대상으로 하는 변수의 할당과 소멸에 대해서는 잠시 후에 별도로 설명하겠다.



> 프로그램의 실행에 따른 메모리의 상태 변화

그럼 프로그램의 실행과정에서 보이는 메모리 공간의 변화를 통해서 각 영역별 특징에 대해 다시 한번 정리하겠다. 단 코드 영역은 변수가 할당되는 영역이 아니니 생략을 하고 설명을 진행하겠다.  
다음 그림에서는 왼편의 코드가 실행된 직후(main 함수가 호출되기 직전)의 상황을 보이고 있다.

![](./img/4-5/ex2.jpg)

지금까지는 '프로그램의 시작은 main 함수의 호출에서부터이다.'라고 이야기해 왔지만, 실제로는 main 함수가 호출되기 이전에 데이터 영역이 먼저 초기화된다.  
위 그림에서 보이듯이 전역변수가, 그리고 그림에는 없지만 static 변수가 먼저 데이터 영역에 할당이 되고 나서 main 함수가 호출된다.  
이어서 main 함수가 호출되고 main 함수 내에 선언된 지역변수 num1이 스택에 할당되어 다음의 구조가 된다.

![](./img/4-5/ex3.jpg)

다음으로 main 함수 내에서 `fct` 함수가 호출된다. 때문에 `fct` 함수의 매개변수가 스택에 할당되고 `fct` 함수의 지역변수도 다음 그림에서 보이듯이 그 뒤를 이어서 할당이 된다.

![](./img/4-5/ex4.jpg)

다음으로 `fct` 함수가 반환을 하면서 `fct` 함수호출 시 할당되었던 매개변수와 지역변수가 소멸되면서 다음의 형태가 된다.  
참고로 다음 그림에서는 `fct` 함수를 빠져 나온 이후에 main 함수내에서 num1의 값이 증가한 상황까지의 결과를 보이고 있다.

![](./img/4-5/ex5.jpg)

이어서 다시 `fct` 함수의 호출이 진행되고, 더불어 매개변수와 지역변수가 다시 스택에 할당되어 다음의 구조가 된다.

![](./img/4-5/ex6.jpg)

마지막으로 `fct` 함수가 반환되고, jmain 함수의 return 문이 실행되면서 프로그램이 종료된다.  
그리고 프로그램이 종료되면, 운영체제에 의해서 할당된 메모리 공간 전체를 반환하게 되는데, 발 ㅗ그때가 전역변수가 소멸되는 시점이다.

![](./img/4-5/ex7.jpg)

지금까지 살펴 본 내용을 기준으로 스택 영역의 특징을 하나 더 찾아보겠다. 당므의 순서로 함수가 호출 되었다고 가정해 보자.

__main 함수의 호출 → fct1 함수의 호출 → fct2 함수의 호출__

이는 `fct1` 함수가 반환된 이후에 `fct2` 함수가 호출되었다는 뜻이 아니고, `fct1` 함수 내에서 `fct2` 함수가 호출되었다는 뜻이다. 그리고 이러한 경우 지역(매개)변수의 소멸순서는 다음과 같다.

__fct2의 지역 변수 소멸 → fct1의 지역변수 소멸 → main의 지역변수 소멸__

이렇듯 먼저 호출된 함수의 스택공간일수록 늦게 해제된다는 것을 알 수 있다. 그래서 메모리 영역의 이름이 스택이다.  
스택(Stack)은 '쌓아 올려진 더미'를 뜻한다. 이로써 메모리 구조에 대한 전반적인 이야기가 끝이 났다. 남은 것은 힙 영역이 필요한 이유와 힙 영역을 활용하는 방법을 이해하는 것이다.



## 메모리의 동적 할당

언뜻 생각해보면 전역변수와 지역변수만 있으면 충분하다는 생각이 든다. 하지만 프로그램을 구현하다보면 이 둘이 아닌 다른 유형의 변수를 필요로 하게 된다.



> 전역변수와 지역변수로 해결이 되지 않는 상황

다음 예제에는 프로그램 사용자로부터 입력 받은 문자열의 정보를 반환하는 함수가 정의되어 있다.  
우선 이 함수의 문제점을 지적해보자.



ReadStringFault1.c

```c
#include <stdio.h>

char * ReadUserName(void)
{
    char name[30];
    printf("What's your name?");
    gets(name);
    return name;		// 무엇을 반환하는가?
}

int main(void)
{
    char * name1;
    char * name2;
    name1 = ReadUserName();
    printf("name1: %s \n", name1);
    name2 = ReadUserName();
    printf("name2: %s \n", name2);
    return 0;
}
```



위 예제의 문제점은 무엇인가? 그것은 함수 내에 지역적으로 선언된 배열(변수)의 주소 값을 반환하는데 있다. 함수 내에서 프로그램 사용자로부터 문자열을 입력 받아서 그 결과를 반환하는 것은 좋다.  
문제는 그 문자열이 저장되어 있는 배열이 지역적으로 선언되었기 때문에 함수를 빠져나오면서 소멸된다는데 있다.  
그래서 실제로 실행을 해보면 정상적이지 못한 결과로 이어지는 것을 확인할 수 있다. 간혹 정상적인 결과를 보일 수도 있지만, 이는 우연이며, 결국에 가서는 문제를 일으키고 만다.  
그렇다면 이 문제를 전역변수를 이용해서 해결해보겠는가? 하지만 다음 예제에서 보이듯이 이 역시 답이 될 수 없다.



ReadStringFault2.c

```c
#include <stdio.h>
char name[30];

char * ReadUserName(void)
{
    printf("What's your name? ");
    gets(name);
    return name;
}

int main(void)
{
    char * name1;
    char * name2;
    name1 = ReadUserName();
    pritnf("name1: %s \n", name1);
    name2 = ReadUserName();
    printf("name2: %s \n", name2);
    
    printf("name1: %s \n", name1);
    printf("name2: %s \n", name2);
    return 0;
}
```



실행 결과

```
What's your name? ki hyun Jung
name1: ki hyun Jung
What's your name? Choi jun kyung
name2: Choi jun kyung
name1: Choi jun kyung
name2: Choi jun kyung
```

위의 실행결과에서 보이듯이 하나의 전역변수(전역으로 선언된 배열)을 이용하면, 이 전역변수를 덮어쓰게 되기 때문에, 함수호출을 통해서 얻게 된 이름정보가 유지되지 않는다.  
즉 프로그램 사용자에게 이름정보를 입력 받아서 이를 반환하는 함수를 정의하기에는 지역변수도 전역변수도 답이 될 수 없다.  
그렇다면 어떠한 성격의 변수가 필요한 것일까?

__함수가 매번 호출될 때마다 새롭게 할당되고 또 함수를 빠져나가도 유지가 되는 유형의 변수__

다시 말해서, 지역변수와 같이 함수가 호출될 때마다 매번 할당이 이뤄지지만, 할당이 되면 전역변수와 마찬가지로 함수를 빠져나가도 소멸되지 않는 성격의 변수가 필요하다.  
그런데 다행스럽게도 이렇듯 __생성과 소물의 시기가 지역변수나 전역변수와는 다른 유형의 변수__는 `malloc`과 `free` 라는 이름의 함수를 통해서 힙 영역에 할당하고 소멸할 수 있다.  
그럼 위 예제에서 보인 문제점의 해결은 잠시 뒤로 하고 먼저 `malloc` 과 `free` 함수에 대해서 살펴보기로 하자.



> 힙 영역의 메모리 공간 할당과 해제: malloc과 free 함수

