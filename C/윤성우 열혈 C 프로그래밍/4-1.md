# 문자와 문자열 관련 함수



## 목차

- [스트림과 데이터의 이동](#스트림과-데이터의-이동)
- [문자 단위 입출력 함수](#문자-단위-입출력-함수)



## 스트림과 데이터의 이동

> 무엇이 '입력'이고 무엇이 '출력'인가?

데이터의 입력과 출력은 프로그램의 흐름을 뜻하는 것이다. 그렇다면 무엇이 '입력'이고 무엇이 '출력'일까?  
프로그램을 중심으로 데이터가 흘러 들어오는 것이 입력이고, 프로그램 밖으로 데이터가 흘러 나가는 것이 출력이다.  
가장 대표적인 입력장치로는 키보드가 있으며, 파일도 입력의 대상이 될 수 있다.  
그리고 대표적인 출력장치로는 모니터가 있으며, 마찬가지로 파일도 출력의 대상이 될 수 있다.  
입출력의 대상은 이외에도 굉장히 넓고 의미 또한 굉장히 포괄적이다.



> 데이터의 이동수단이 되는 스트림

아래의 질문에 대해 생각해보자.

__프로그램상에서 모니터로 문자열을 출력할 수 있는 이유는 무엇일까?__

우리가 구현하는 프로그램과 모니터, 키보드는 기본적으로 연결되어 있는 개체가 아닌 서로 떨어져 있는 개체이다.  
따라서 프로그램상에서 모니터와 키보드를 대상으로 데이터를 입출력 하기 위해서는 이들을 연결시켜 주는 다리가 필요하다.  
그리고 이러한 다리의 역할을 하는 매개체를 가리켜 __스트림(stream)__이라 한다.  
그렇다면 이러한 스트림의 정체는 무엇일까?  
이는 운영체제에서 제공하는 소프트웨어적인(소프트웨어로 구현되어 있는) 가상의 다리이다.  
다시 말해서, 운영체제는 외부장치와 프로그램과의 데이터 송수신의 도구가 되는 스트림을 제공하고 있다.



> 스트림의 생성과 소멸

콘솔(일반적으로 키보드와 모니터를 의미) 입출력과 파일 입출력 사이에는 차이점이 하나 있다.  
그것은 파일과의 연결을 위한 스트림의 생성은 우리가 직접 요구해야 하지만,  
콘솔과의 연결을 위한 스트림의 생성은 요구할 필요가 없다는 것이다.  
지금까지 `printf`함수와 `scanf`함수를 호출해오면서 스트림의 생성과 관련된 코드를 본 적이 없다는 사실을 상기해보자.  
콘솔 입출력을 위한 스트림은 자동으로 생성이 되고 있다는 사실을 알 수 있을 것이다.  
정리하자면, __콘솔 입출력을 위한 '입력 스트림'과 '출력 스트림'은 프로그램이 실행되면 자동으로 생성되고, 프로그램이 종료되면 자동으로 소멸되는 스트림이다.__  
즉, 이 둘은 기본적으로 제공되는 표준 스트림(standard stream)이다. 그리고 표준 스트림에는 '에러 스트림'도 존재하며 이들 각각에는 다음과 같이 __stdin, stdout, sterr__라는 이름이 붙어있다.

- stdin			표준 입력 스트림				키보드 대상으로 입력
- stdout         표준 출력 스트림                모니터 대상으로 출력
- stderr          표준 에러 스트림                모니터 대상으로 출력



## 문자 단위 입출력 함수

> 문자 출력 함수: putchar, fputc

모니터로 하나의 문자를 출력할 때 일반적으로 사용하는 두 함수는 다음과 같다.

```c
#include <stdio.h>

int putchar(int c);
int fputc(int c, FILE * stream);
/*
함수 호출 성공 시 쓰여진 문자정보가, 실패 시 EOF 반환
*/
```

putchar 함수는 인자로 전달된 문자정보를 stdout으로 표현되는 표준 출력 스트림으로 전송하는 함수이다.  
따라서 인자로 전달된 문자를 모니터로 출력하는 함수라 할 수 있다.  
그리고 문자를 전송한다는 측면에서는 fputc 함수도 putchar 함수와 동일하다.  
__단, fputc 함수는 문자를 전송할 스트림을 지정할 수 있다.__ 즉 fputc 함수를 이용하면 stdout뿐만 아니라, 파일을 대상으로도 데이터를 전송할 수 있다.  
fputc함수에 대해서 더 설명하자면 fputc 함수의 두 번째 매개변수 stream은 문자를 출력할 스트림의 지정에 사용된다.  
따라서 이 인자에 표준 출력 스트림을 의미하는 stdout을 전달하면, putchar 함수와 동일한 함수가 된다.  
그리고 위의 두 함수 모두 오류가 발생해서 정상적인 결과를 보장하지 못할 경우 EOF를 반환하는데, EOF에 대해서는 뒤에서 더 알아보도록 하자.



> 문자 입력 함수: getchar, fgetc

키보드로부터 하나의 문자를 입력 받을 때 일반적으로 사용하는 두 함수는 다음과 같다.

```c
#include <stdio.h>

int getchar(void);
int fgetc(FILE * stream);
/*
파일의 끝에 도달하거나 함수호출 실패 시 EOF 반환
*/
```

getchar 함수는 stdin으로 표현되는 표준 입력 스트림으로부터 하나의 문자를 입력 받아서 반환하는 함수이다. 따라서 키보드로부터 하나의 문자를 입력 받는 함수라 할 수 있다.  
그리고 fgetc 함수도 하나의 문자를 입력 받는 함수이다. 다만 getchar 함수와 달리 문자를 입력 받을 스트림을 지정할 수 있다.  
즉, 위의 두 함수의 관계는 앞서 설명한 putchar, fputc 함수의 관계와 동일하다.  
그럼 지금까지 설명한 함수의 동작을 설명하기 위해서 다음 예제를 살펴보자. 예제에는 앞에서 살펴본 4가지 함수가 모두 들어 있다.



ReadWriteChar.c

```c
#include <stdio.h>

int main(void)
{
	int ch1, ch2;
	
	ch1 = getchar();		// 문자 입력
	ch2 = fgetc(stdin);		// 엔터 키 입력
	
	putchar(ch1);			// 문자 출력
	fputc(ch2, stdout);		// 엔터 키 출력
	return 0;
}
```



실행 결과

```
p
p
```



우리는 분명히 p와 엔터 2개의 문자를 입력하였다. 그런데 실행결과만 놓고 보면 하나의 문자(p)만 입력되고 출력된 것처럼 보인다.  
그러나 실제로는 두 개의 문자가 입력되고 출력되었다. 다만 두 번째 문자가 '엔터 키'이다 보니 눈에 띄지 않을 뿐이다.  
위 예제에서 문자를 int형 변수에 저장하는 모습을 볼 수 있는데 이는 함수 getchar 함수와 fgetc 함수의 반환형이 int형이기 때문이다.  
그래도 아직 int형인 이유에 대한 의문이 생길것이다. 이는 뒤에 EOF를 알아본다음 다시 살펴보자.



> 문자 입출력에서의 EOF

__EOF는 End Of File의 약자로서__, 파일의 끝을 표현하기 위해서 정의해 놓은 상수이다.  
따라서 파일을 대상으로 fgetc 함수가 호출되면, 그리고 그 결과로 EOF가 반환되면, 이는 __파일의 끝에 도달해서 더 이상 읽을 내용이 없다__는 뜻이 된다.  
그렇다면 키보드를 대상으로 하는 fgetc 함수와 getchar 함수는 언제 EOF를 반환할까?  
이는 다음 두 가지 경우 중 하나가 만족되었을 때이다.

- 함수 호출의 실패
- Windows에서 CTRL+Z 키, Linux에서 CTRL+D 키가 입력되는 경우

키보드의 입력에 '파일의 끝'이라는 것이 존재할 수 있겠는가?  
따라서 EOF의 반환시기를 CTRL+Z 또는 CTRL+D의 입력으로 별도로 약속해 놓은 것이다.  
그럼 다음 예제를 통해 키보드를 통한 EOF의 입력을 확인해보자.



ConsoleEOF.c

```c
#include <stdio.h>

int main(void)
{
	int ch;
	
	while(1)
	{
		ch = getchar();
		if(ch==EOF)
			break;
    	putchar(ch);
	}
    return 0;
}
```



실행 결과

```
Hi~
Hi~
I like C lang.
I like C lang.
^Z
```

위의 실행결과는 WIndows에서의 실행결과이다. 따라서 프로그램의 종료를 위해서 CTRL+Z를 입력하였다.  
참고로 위의 예제에서는 getchar 함수가 호출된다고 해서 하나의 문자만 입력하려고 노력하지 않아도 된다. 문자가 아닌 공백을 포함하는 문장을 입력해도 된다.  
문장이 입력되면 문장을 구성하는 문자의 수만큼 getchar 함수가 호출 되면서 모든 문자를 읽어들이니 말이다.



> 반환형이 int이고, int형 변수에 문자를 담는 이유는?

앞서 소개한 getchar 함수와 fgetc 함수를 다시 한번 관찰하자.

```c
int getchar(void);
int fgetc(FILE * stream);
```

반환되는 것은 1바이트 크기의 문자인데, 반환형이 int이다. 이유가 무엇일까?  
앞서 1-5에서 다음의 내용을 '참고'를 통해 언급한 적이 있다.

- 제목: char 형은 예외일 수 있습니다.
- 내용: char를 unsigned char로 처리하는 컴파일러도 존재한다.

그런데 위의 두 함수가 반환하는 값 중 하나인 __EOF는 -1로 정의된 상수__이다.  
따라서 반환형이 char형 이라면, 그리고 char를 unsigned char로 처리하는 컴파일러에 의해서 컴파일이 되었다면,  
EOF는 반환의 과정에서 엉뚱한 양의 정수로 형 변환이 되어버리고 만다. 그래서 어떠한 상황에서도 -1을 인식할 수 있는 int형으로 반환형을 정의해 놓은 것이다.  
물론 반환되는 값을 그대로 유지하기 위해서 우리도 int형 변수에 반환 값을 저장해야 한다. 앞서 예제를 통해서 보였듯이 말이다.



문제 1

프로그램 사용자로부터 알파벳 문자를 하나 입력 받아서, 입력 받은 문자가 대문자면 이를 소문자로 변환해서 출력해주고, 입력 받은 문자가 소문자면 이를 대문자로 변환해서 출력해주는 프로그램을 작성해보자.  
단, 문자의 입출력에는 getchar 함수와 putchar 함수를 사용하기로 하자.  
그리고 프로그램 사용자가 알파벳 이외의 문자를 입력하는 경우에는 그에 따른 오류 메시지를 간단히 출력하기로 하자.



답안
