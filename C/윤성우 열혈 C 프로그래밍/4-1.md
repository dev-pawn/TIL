# 문자와 문자열 관련 함수



## 목차

- [스트림과 데이터의 이동](#스트림과-데이터의-이동)
- [문자 단위 입출력 함수](#문자-단위-입출력-함수)
- [문자열 단위 출력 함수](#문자열-단위-출력-함수)
- [표준 입출력과 버퍼](#표준-입출력과-버퍼)
- [입출력 이외의 문자열 관련 함수](#입출력-이외의-문자열-관련-함수)



## 스트림과 데이터의 이동

> 무엇이 '입력'이고 무엇이 '출력'인가?

데이터의 입력과 출력은 프로그램의 흐름을 뜻하는 것이다. 그렇다면 무엇이 '입력'이고 무엇이 '출력'일까?  
프로그램을 중심으로 데이터가 흘러 들어오는 것이 입력이고, 프로그램 밖으로 데이터가 흘러 나가는 것이 출력이다.  
가장 대표적인 입력장치로는 키보드가 있으며, 파일도 입력의 대상이 될 수 있다.  
그리고 대표적인 출력장치로는 모니터가 있으며, 마찬가지로 파일도 출력의 대상이 될 수 있다.  
입출력의 대상은 이외에도 굉장히 넓고 의미 또한 굉장히 포괄적이다.



> 데이터의 이동수단이 되는 스트림

아래의 질문에 대해 생각해보자.

__프로그램상에서 모니터로 문자열을 출력할 수 있는 이유는 무엇일까?__

우리가 구현하는 프로그램과 모니터, 키보드는 기본적으로 연결되어 있는 개체가 아닌 서로 떨어져 있는 개체이다.  
따라서 프로그램상에서 모니터와 키보드를 대상으로 데이터를 입출력 하기 위해서는 이들을 연결시켜 주는 다리가 필요하다.  
그리고 이러한 다리의 역할을 하는 매개체를 가리켜 __스트림(stream)__이라 한다.  
그렇다면 이러한 스트림의 정체는 무엇일까?  
이는 운영체제에서 제공하는 소프트웨어적인(소프트웨어로 구현되어 있는) 가상의 다리이다.  
다시 말해서, 운영체제는 외부장치와 프로그램과의 데이터 송수신의 도구가 되는 스트림을 제공하고 있다.



> 스트림의 생성과 소멸

콘솔(일반적으로 키보드와 모니터를 의미) 입출력과 파일 입출력 사이에는 차이점이 하나 있다.  
그것은 파일과의 연결을 위한 스트림의 생성은 우리가 직접 요구해야 하지만,  
콘솔과의 연결을 위한 스트림의 생성은 요구할 필요가 없다는 것이다.  
지금까지 `printf`함수와 `scanf`함수를 호출해오면서 스트림의 생성과 관련된 코드를 본 적이 없다는 사실을 상기해보자.  
콘솔 입출력을 위한 스트림은 자동으로 생성이 되고 있다는 사실을 알 수 있을 것이다.  
정리하자면, __콘솔 입출력을 위한 '입력 스트림'과 '출력 스트림'은 프로그램이 실행되면 자동으로 생성되고, 프로그램이 종료되면 자동으로 소멸되는 스트림이다.__  
즉, 이 둘은 기본적으로 제공되는 표준 스트림(standard stream)이다. 그리고 표준 스트림에는 '에러 스트림'도 존재하며 이들 각각에는 다음과 같이 __stdin, stdout, sterr__라는 이름이 붙어있다.

- stdin			표준 입력 스트림				키보드 대상으로 입력
- stdout         표준 출력 스트림                모니터 대상으로 출력
- stderr          표준 에러 스트림                모니터 대상으로 출력



## 문자 단위 입출력 함수

> 문자 출력 함수: putchar, fputc

모니터로 하나의 문자를 출력할 때 일반적으로 사용하는 두 함수는 다음과 같다.

```c
#include <stdio.h>

int putchar(int c);
int fputc(int c, FILE * stream);
/*
함수 호출 성공 시 쓰여진 문자정보가, 실패 시 EOF 반환
*/
```

putchar 함수는 인자로 전달된 문자정보를 stdout으로 표현되는 표준 출력 스트림으로 전송하는 함수이다.  
따라서 인자로 전달된 문자를 모니터로 출력하는 함수라 할 수 있다.  
그리고 문자를 전송한다는 측면에서는 fputc 함수도 putchar 함수와 동일하다.  
__단, fputc 함수는 문자를 전송할 스트림을 지정할 수 있다.__ 즉 fputc 함수를 이용하면 stdout뿐만 아니라, 파일을 대상으로도 데이터를 전송할 수 있다.  
fputc함수에 대해서 더 설명하자면 fputc 함수의 두 번째 매개변수 stream은 문자를 출력할 스트림의 지정에 사용된다.  
따라서 이 인자에 표준 출력 스트림을 의미하는 stdout을 전달하면, putchar 함수와 동일한 함수가 된다.  
그리고 위의 두 함수 모두 오류가 발생해서 정상적인 결과를 보장하지 못할 경우 EOF를 반환하는데, EOF에 대해서는 뒤에서 더 알아보도록 하자.



> 문자 입력 함수: getchar, fgetc

키보드로부터 하나의 문자를 입력 받을 때 일반적으로 사용하는 두 함수는 다음과 같다.

```c
#include <stdio.h>

int getchar(void);
int fgetc(FILE * stream);
/*
파일의 끝에 도달하거나 함수호출 실패 시 EOF 반환
*/
```

getchar 함수는 stdin으로 표현되는 표준 입력 스트림으로부터 하나의 문자를 입력 받아서 반환하는 함수이다. 따라서 키보드로부터 하나의 문자를 입력 받는 함수라 할 수 있다.  
그리고 fgetc 함수도 하나의 문자를 입력 받는 함수이다. 다만 getchar 함수와 달리 문자를 입력 받을 스트림을 지정할 수 있다.  
즉, 위의 두 함수의 관계는 앞서 설명한 putchar, fputc 함수의 관계와 동일하다.  
그럼 지금까지 설명한 함수의 동작을 설명하기 위해서 다음 예제를 살펴보자. 예제에는 앞에서 살펴본 4가지 함수가 모두 들어 있다.



ReadWriteChar.c

```c
#include <stdio.h>

int main(void)
{
	int ch1, ch2;
	
	ch1 = getchar();		// 문자 입력
	ch2 = fgetc(stdin);		// 엔터 키 입력
	
	putchar(ch1);			// 문자 출력
	fputc(ch2, stdout);		// 엔터 키 출력
	return 0;
}
```



실행 결과

```
p
p
```



우리는 분명히 p와 엔터 2개의 문자를 입력하였다. 그런데 실행결과만 놓고 보면 하나의 문자(p)만 입력되고 출력된 것처럼 보인다.  
그러나 실제로는 두 개의 문자가 입력되고 출력되었다. 다만 두 번째 문자가 '엔터 키'이다 보니 눈에 띄지 않을 뿐이다.  
위 예제에서 문자를 int형 변수에 저장하는 모습을 볼 수 있는데 이는 함수 getchar 함수와 fgetc 함수의 반환형이 int형이기 때문이다.  
그래도 아직 int형인 이유에 대한 의문이 생길것이다. 이는 뒤에 EOF를 알아본다음 다시 살펴보자.



> 문자 입출력에서의 EOF

__EOF는 End Of File의 약자로서__, 파일의 끝을 표현하기 위해서 정의해 놓은 상수이다.  
따라서 파일을 대상으로 fgetc 함수가 호출되면, 그리고 그 결과로 EOF가 반환되면, 이는 __파일의 끝에 도달해서 더 이상 읽을 내용이 없다__는 뜻이 된다.  
그렇다면 키보드를 대상으로 하는 fgetc 함수와 getchar 함수는 언제 EOF를 반환할까?  
이는 다음 두 가지 경우 중 하나가 만족되었을 때이다.

- 함수 호출의 실패
- Windows에서 CTRL+Z 키, Linux에서 CTRL+D 키가 입력되는 경우

키보드의 입력에 '파일의 끝'이라는 것이 존재할 수 있겠는가?  
따라서 EOF의 반환시기를 CTRL+Z 또는 CTRL+D의 입력으로 별도로 약속해 놓은 것이다.  
그럼 다음 예제를 통해 키보드를 통한 EOF의 입력을 확인해보자.



ConsoleEOF.c

```c
#include <stdio.h>

int main(void)
{
	int ch;
	
	while(1)
	{
		ch = getchar();
		if(ch==EOF)
			break;
    	putchar(ch);
	}
    return 0;
}
```



실행 결과

```
Hi~
Hi~
I like C lang.
I like C lang.
^Z
```

위의 실행결과는 WIndows에서의 실행결과이다. 따라서 프로그램의 종료를 위해서 CTRL+Z를 입력하였다.  
참고로 위의 예제에서는 getchar 함수가 호출된다고 해서 하나의 문자만 입력하려고 노력하지 않아도 된다. 문자가 아닌 공백을 포함하는 문장을 입력해도 된다.  
문장이 입력되면 문장을 구성하는 문자의 수만큼 getchar 함수가 호출 되면서 모든 문자를 읽어들이니 말이다.



> 반환형이 int이고, int형 변수에 문자를 담는 이유는?

앞서 소개한 getchar 함수와 fgetc 함수를 다시 한번 관찰하자.

```c
int getchar(void);
int fgetc(FILE * stream);
```

반환되는 것은 1바이트 크기의 문자인데, 반환형이 int이다. 이유가 무엇일까?  
앞서 1-5에서 다음의 내용을 '참고'를 통해 언급한 적이 있다.

- 제목: char 형은 예외일 수 있습니다.
- 내용: char를 unsigned char로 처리하는 컴파일러도 존재한다.

그런데 위의 두 함수가 반환하는 값 중 하나인 __EOF는 -1로 정의된 상수__이다.  
따라서 반환형이 char형 이라면, 그리고 char를 unsigned char로 처리하는 컴파일러에 의해서 컴파일이 되었다면,  
EOF는 반환의 과정에서 엉뚱한 양의 정수로 형 변환이 되어버리고 만다. 그래서 어떠한 상황에서도 -1을 인식할 수 있는 int형으로 반환형을 정의해 놓은 것이다.  
물론 반환되는 값을 그대로 유지하기 위해서 우리도 int형 변수에 반환 값을 저장해야 한다. 앞서 예제를 통해서 보였듯이 말이다.



문제 1

프로그램 사용자로부터 알파벳 문자를 하나 입력 받아서, 입력 받은 문자가 대문자면 이를 소문자로 변환해서 출력해주고, 입력 받은 문자가 소문자면 이를 대문자로 변환해서 출력해주는 프로그램을 작성해보자.  
단, 문자의 입출력에는 getchar 함수와 putchar 함수를 사용하기로 하자.  
그리고 프로그램 사용자가 알파벳 이외의 문자를 입력하는 경우에는 그에 따른 오류 메시지를 간단히 출력하기로 하자.



[답안](./Chapter4Challenge/21-1.c)



## 문자열 단위 출력 함수

이번에 소개하는 문자열 입력 함수는 scanf 함수와는 다르게 공백을 포함하는 문자열도 입력 받을 수 있다.



> 문자열 출력 함수: puts, fputs

모니터로 하나의 문자열을 출력할 때 일반적으로 사용하는 두 함수는 다음과 같다.

```c
#include <stdio.h>

int puts(const char * s);
int fputs(const char * s, FILE * stream);
/*
성공 시 음수가 아닌 값을, 실패 시 EOF 반환
*/
```

puts 함수는 출력의 대상이 stdout으로 결정되어 있지만, fputs 함수는 두 번째 인자를 통해서 출력의 대상을 결정할 수 있다.  
그리고 둘 다 첫 번째 인자로 전달되는 주소 값의 문자열을 출력하지만, 출력의 형태에 있어 한가지 차이점이 있다.  
어떠한 차이점이 있는지 다음 예제를 통해 확인해보자.



WriteString.c

```c
#include <stdio.h>

int main(void)
{
	char * str = "Simple String";
	
	printf("1. puts test ------ \n");
	puts(str);
	puts("So Simple String");
	
	printf("2. fputs test ----- \n");
	fputs(str, stdout); printf("\n");
	fputs("So Simple String", stdout); pinrtf("\n");
	
	printf("3. end of main ----\n");
	return 0;
}
```



실행 결과

```
1. puts test ------
Simple String
So Simple String
2. fputs test -----
Simple String
So Simple String
3. end of main ----
```

위 예제를 통해 다음 사실을 알 수 있다.

__puts 함수가 호출되면 자동으로 개행이 이루어지지만, fputs 함수가 호출되면 문자열 출력 후 자동으로 개행이 이뤄지지 않는다.__



> 문자열 입력 함수: gets, fgets

이번에 소개하는 두 개의 문자열 입력 함수는 다음과 같다.

```c
#include <stdio.h>
char * gets(char * s);
char * fgets(char * s, int n, FILE * stream);
/*
파일의 끝에 도달하거나 함수호출 실패 시 NULL 포인터 반환
*/
```

위의 get 함수는 다음의 유형으로 호출한다.

```c
int main(void)
{
	char str[7];		// 7바이트의 메모리 공간 할당
	gets(str);			// 입력 받은 문자열을 배열 str에 저장
	....
}
```

위의 문장구성만으로도 키보드로부터 문자열을 입력 받게 되니, 확실히 문장구성은 간단하다.  
하지만 미리 마련해 놓은 배열을 넘어서는 길이의 문자열이 입력되면, __할당 받지 않은 메모리 공간을 침범하여 실행 중 오류가 발생한다는 단점__이 있다.  
그래서 가급적이면 다음의 형태로 fgets 함수를 호출하는 것이 좋다.

```c
int main(void)
{
	char str[7];
	fgets(str, sizeof(str), stdin);		// stdin으로부터 문자열 입력 받아서 str에 저장
	....
}
```

위의 문장은 stdin으로부터 문자열을 입력 받아서 배열 str에 저장하되, sizeof(str)의 길이만큼만 저장하라는 뜻이다.  
만약 위의 형태로 fgets함수가 호출되었는데, "123456789"의 문자열을 입력하면 sizeof(str)의 반환 값인 7보다 하나가 작은 6에 해당하는 길이의 문자열만 읽어서 str에 저장하게 된다.  
즉, str에 저장되는 문자열은 다음과 같다.

__"123456"__

배열의 사이즈가 7인데 6개의 문자만 저장되는 이유는 문자열의 끝에 NULL 문자가 저장되기 때문이다.  
그렇다면 gets 함수호출의 예는 생략하고 fgets 함수호출의 특성을 몇 가지 더 예시로 살펴보자.



ReadString.c

```c
#include <stdio.h>

int main(void)
{
	char str[7];
	int i;
	
	for(i=0; i<3;i++)
    {
        fgets(str, sizeof(str), stdin);
        printf("Read %d: %s \n", i+1, str);
    }
    return 0;
}
```



실행 결과1

```
12345678901234567890
Read 1: 123456
Read 2: 789012
Read 3: 345678
```



이번에는 문자열의 길이를 5로 제한해서 다음과 같이 키보드를 통한 입력이 총 3회 이뤄지도록 하자.

실행 결과2

```
We
Read 1: We

like
Read 2: like

you
Read 3: you
```

위 예제 11행의 printf 함수호출 문에는 개행을 의미하는 \n이 하나 삽입되어 있다.  
그런데 위의 실행 결과를 보면 문장이 출력될 때마다 개행이 두 번 이뤄졌음을 알 수 있다.  
그 이유는 fgets함수는 \n을 만날 때까지 문자열을 읽어 들이는데, __\n을 제외시키거나 버리지 않고 문자열의 일부로 받아들인다.__



이제 마지막으로 공백을 포함하는 형태의 문자열을 입력하는 방식으로 예제를 실행해보자.  
참고로 scanf 함수를 통해서는 공백을 포함하는 형태의 문자열을 입력 받을 수 없다.

실행 결과3

```
Y & I
Read 1: Y & I

ha ha
Read 2: ha ha

^^ --
Read 3: ^^ --
```

마찬가지로 fgets 함수는 \n을 만날 때까지 문자열을 읽어 들이기 때문에,  
위의 실행결과에서 보이듯이 중간에 삽입된 공백문자도 문자열의 일부로 읽어 들인다.



## 표준 입출력과 버퍼

> 표준 입출력 기반의 버퍼

우리가 지금까지 공부해 온 입출력 함수들을 가리켜 __표준 입출력 함수__라 한다. ANSI C의 표준에서 정의된 함수이기 때문이다.  
그런데 이러한 표준 입출력 함수를 통해서 데이터를 입출력 하는 경우, 해당 데이터들은 __운영체제가 제공하는 '메모리 버퍼'를 중간에 통과__하게 된다.  
여기서 말하는 '메모리 버퍼'는 데이터를 임시로 모아두는(저장하는) 메모리 공간이다.  
키보드를 통해 입력된 데이터는 일단 입력버퍼에 저장된 다음에(버퍼링 된 다음에) 프로그램에서 읽혀진다. 즉 fgets 함수가 읽어 들이는 문자열은 입력버퍼에 저장된 문자열이다.  
그럼 키보드로부터 입력된 데이터가 입력 스트림을 거쳐서 입력버퍼로 들어가는 시점은 언제일까? 이는 엔터 키가 눌리는 시점이다.  
그래서 키보드로 아무리 문자열을 입력해도 엔터 키가 눌리기 전에는 fgets 함수가 문자열을 읽어 들이지 못하는 것이다.  
엔터 키가 눌리기 전에는 입력버퍼가 비워져 있기 때문이다.



> ''버퍼링(Buffering)'을 하는 이유는 무엇인가?

데이터를 목적지로 바로 전송하지 않고 중간에 출력버퍼와 입력버퍼를 둬서 전송하고자 하는 데이터를 임시 저장하는 이유는 무엇일까?  
이러한 데이터 버퍼링의 가장 큰 이유는 __'데이터 전송의 효율성'__과 관련이 있다.  
키보드나 모니터와 같은 외부 장치와의 데이터 입출력은 생각보다 시간이 걸리는 작업이다.  
따라서 버퍼링 없이 키보드가 눌릴 때마다 문자의 정보를 목적지로 바로 이동시키는 것보다 중간에 메모리 버퍼를 둬서 데이터를 한데 묶어서 이동시키는 것이 보다 효율적이고 빠르다.  
마치 창고에 물건을 하나씩 옮기는 것보다 한번에 옮기는 것이 더 효율적인것과 같은 이치다.



> 출력버퍼를 비우는 fflush 함수

출력버퍼가 비워진다는 것은 __출력버퍼에 저장된 데이터가 버퍼를 떠나서 목적지로 이동됨__을 뜻한다.  
그런데 출력버퍼가 비워지는 시점은 시스템에 따라 그리고 버퍼의 성격에 따라 달라진다.  
예를 들어서 버퍼가 꽉 찼을 때 비워지는 버퍼도 있고, 하나의 문장이 완전히 입력되었을 때마다 비워지는 버퍼도 있다.  
이렇듯 버퍼가 비워지는 시점은 동일하지 않기 때문에 다음 함수를 알아 둘 필요가 있다.

```c
#include <stdio.h>

int fflush(FILE * stream);
/*
함수호출 성공 시 O, 실패 시 EOF 반환
*/
```

위 함수는 __인자로 전달된 스트림의 버퍼를 비우는 기능을 제공한다.__  
따라서 다음과 같이 함수를 호출하면,

```c
fflush(stdout);		// 표준 출력버퍼를 비워라!
```

어떠한 시스템의 어떠한 표준 출력버퍼라 할지라도 버퍼에 저장된 내용이 비워지면서 데이터가 목적지로 이동한다.  
참고로 위의 함수는 파일을 대상으로도 호출이 가능하다. 인자로 파일의 스트림정보가 전달되면, 해당 버퍼에 저장되어 있던 데이터들이 버퍼를 떠나서 파일에 기록이 된다.  
그런데 여러분이 콘솔 입출력을 하는 상황이라면, 그리고 Windows나 Linux와 같은 범용 OS를 사용하고 있다면 stdout을 대상으로 위의 함수를 호출할 일은 사실상 많지 않다.



> 입력버퍼는 어떻게 비워야 하나요?

입력버퍼의 비워짐과 출력버퍼의 비워짐은 개념적으로 차이가 있다.  
출력버퍼의 비워짐이 저장된 데이터가 목적지로 전송됨을 의미한다면, 입력버퍼의 비워짐은 __데이터의 소멸을 의미__하기 때문이다.  
그런데 잠시 후에 예제를 통해서 보게 되겠지만, 가끔은 입력버퍼에 남아있는 불필요한 데이터의 소멸을 위해서 입력버퍼를 비워야 하는 경우가 종종 있다.  
만약 그 경우에 위에서 배운 함수를 사용하면 어떻게 될까?

```c
fflush(stdin);		// 어떠한 의미로 해석될까?
```

위에서 언급했듯이 fflush 함수는 출력버퍼를 대상으로 호출하는 함수이다.  
조금 더 정확히 말하자면 C언어의 표준에서는 위의 결과에 대해 정의하고 있지 않다. 따라서 위의 함수호출 결과는 예측이 불가능하다.  
물론 일부 컴파일러는(대표적으로 windows 계열) 위의 형태로 함수가 호출되었을 때 입력버퍼를 비워주기도 한다.  
하지만 그 외의 컴파일러는 전혀 다른 결과를 보인다.  
그렇다면 입력 버퍼에 저장된 불필요한 데이터는 어떻게 소멸해야 할까? 다음 예제를 실행한 뒤 고민해보도록 하자.



NeedInputBufFlush.c

```c
#include <stdio.h>

int main(void)
{
	char perID[7];
    char name[10];
    
    fputs("주민번호 앞 6자리 입력: ", stdout);
    fgets(perID, sizeof[perID], stdin);
    
    fputs("이름 입력: ", stdout);
    fgets(name, sizeof(name), stdin);
    
    printf("주민번호: %s \n", perID);
    printf("이름: %s \n", name);
    return 0;
}
```



실행 결과

```
주민번호 앞 6자리 입력: 950915
이름 입력: 주민번호: 950915
이름:
```



분명히 6자리만 입력했는데도 문제가 생겼다. 이름을 입력할 기회를 얻지 못한 것이다.  
이러한 문제가 발생한 이유는 무엇일까? 위의 실행결과에서 입력한 데이터는 다음과 같다.

```
900915\n
```

이렇듯 엔터 키를 포함하여 총 7문자가 입력되었다. 그런데 9행의 fgets 함수의 인자로 7이 전달되었으니, 널 문자를 제외하고 최대 6문자를 읽어들인다.  
따라서 \n을 제외한 나머지 여섯 문자만 읽혀지고 \n은 입력버퍼에 남아있게 된다. 그리고 이어서 12행의 fgets 함수가 호출된다.  
그런데 fgets 함수는 \n을 만날 때까지 읽어들이는 함수이니, 버퍼에 남아있는 \n만 읽어버리고 만다.  
때문에 위와 같은 실행 결과가 나타나는 것이다. 이러한 문제의 상황을 해결하기 위해서는 예제 실행 중간에, 입력버퍼에 남아있는 \n 문자 하나만 지워버리면 된다.  
하지만 다음의 실행 결과까지 고려하면 상황은 달라진다.

실행 결과2

```
주민번호 앞 6자리 입력: 950709-1122345
이름 입력: 주민번호: 950709
이름: -1122345
```

분명히 주민번호 앞 6자리만 입력하라고 했는데, -를 포함하여 총 14자리의 주민번호를 전부 입력하였다.  
그래서 9행의 fgets 함수호출을 통해서 여섯 개의 문자가 읽혀지고, 12행의 fgets 함수호출을 통해서 나머지 문자들이 읽혀진 것이다.  
이렇듯 명시한대로 행동하지 않는 프로그램 사용자를 고려한다면, 주민번호 앞 6자리를 제외한 나머지 문자들을 입력버퍼에서 지워줘야 한다.  
이제 필요한 것이 무엇인지 알았을 것이다. 위의 예제가 정상적으로 동작하기위해 필요한 함수를 정의하여 보자.

```
void ClearLineFromReadBuffer(void)
{
	while(getchar()!='\n');
}
```

입력버퍼에 저장된 문자들은 읽어 들이면 지워진다. 그래서 \n을 만날 때까지 문자를 읽어 들이는 함수를 정의하였다.  
물론 읽어들인 문자를 저장하거나 하지는 않는다. 버리는 것이 목적이니 말이다.  
그럼 이 함수를 추가한 예제를 다시 실행해보자.



InputButFlush.c

```c
void ClearLineFromReadBuffer(void)
{
	while(getchar()!='\n');
}

#include <stdio.h>

int main(void)
{
	char perID[7];
    char name[10];
    
    fputs("주민번호 앞 6자리 입력: ", stdout);
    fgets(perID, sizeof[perID], stdin);
    ClearLineFromReadBuffer();	// 입력버퍼 비우기
    
    fputs("이름 입력: ", stdout);
    fgets(name, sizeof(name), stdin);
    
    printf("주민번호: %s \n", perID);
    printf("이름: %s \n", name);
    return 0;
}
```



실행 결과

```
주민번호 앞 6자리 입력: 950123
이름 입력: 이성규
주민번호: 950123
이름: 이성규
```

입력버퍼에 남아있는 \n을 지워버리기 때문에 정상적으로 실행이 된다.



실행 결과2

```
주민번호 앞 6자리 입력: 890123-1234567
이름 입력: 정지영
주민번호: 890123
이름: 정지영
```

프로그램 사용자가 잘못 입력해도, 필요한 만큼만 읽어들이고 나머지는 지워버리기 때문에 정상적으로 동작한다.



## 입출력 이외의 문자열 관련 함수

표준 C에서는 문자열과 관련된 다양한 함수들을 정의하고 있다.  
여기서는 헤더파일 string.h에 선언된 문자열 관련 함수들 중 사용 빈도수가 높은 몇몇 함수를 소개한다.



> 문자열의 길이를 반환하는 함수: strlen

다음 함수는 인자로 전달된 문자열의 길이를 반환하는 함수로서 문자열과 관련해서 많이 사용되는 대표적인 함수이다.

```c
#include <string.h>

size_t strlen(const char * s);
/*
전달된 문자열의 길이를 반환하되, 널 문자를 길이에 포함하지 않는다.
*/
```

위 함수의 반환형 size_t는 일반적으로 다음과 같이 선언되어 있다.

```c
typedef unsigned int size_t;
```

아직 typedef 선언을 배우지 않아서 위의 문장이 의미하는 바를 알지 못한다.  
그러니 당분간은 위의 문장이 의미하는 바가 다음과 같다고만 기억을 하자.

__unsigned int의 선언을 size_t로 대신할 수 있다.__

즉, 위의 typedef 선언으로 인해서 size_t가 unsigned int 를 대신할 수 있게 된 것이다.  
따라서 다음 두 선언은 완전히 동일하다.

```c
size_t len;
unsigned int len;
```

그럼 이어서 strlen 함수의 호출방법을 보자.

```c
int main(void)
{
	char str[] = "1234567";
	printf("%u \n", strlen(str));		// 문자열의 길이 7이 출력된다.
	....
}
```

참고로 strlen 함수의 반환형은 size_t이니, 이 함수의 반환 값을 unsinged int형 변수에 저장하고 서식문자 `%u`로 출력하는 것이 정확하다.  
그러나  문자열이 아무리 길어도 문자열의 길이정보는 int형 변수에 저장이 가능하기 때문에,  
strlen 함수의 반환 값을 int형 변수에 저장하고 서식문자 %d로 출력하는 것도 가능할 뿐만 아니라 이것이 더 흔한 일이다.  
그럼 strlen 함수에 관련해서 다음 예제를 살펴보자. 이 예제에서는 다음 요구사항에 대한 해결책을 제시한다.

__fgets 함수호출을 통해서 문자열을 입력 받고 싶은데, 같이 딸려서 들어오는 \n 문자는 문자열에서 제외시키고 싶어요__



RemoveBSN.c

```c
#include <stdio.h>
#include <string.h>

void RemoveBSN(char str[])
{
	int len = strlen(str);
	str[len-1] = 0;
}

int main(void)
{
    char str[100];
    printf("문자열 입력: ");
    fgets(str, sizeof(str), stdin);
    printf("길이: %d, 내용: %s \n", strlen(str), str);
    
    RemoveBSN(str);
    printf("길이: %d, 내용: %s \n", strlen(str), str);\
    return 0;
}
```



실행 결과

```
문자열 입력: Good morning
길이: 13, 내용: Good morning

길이: 12, 내용: Good morning
```

15행을 통한 출력에서는 개행이 두번 이뤄졌다. 그런데 17행의 RemoveBSN 함수호출 이후에 18행의 출력에서는 개행이 한 번 이뤄졌다.  
이는 RemoveBSN 함수호출을 통해서 \n 문자가 소멸되었기 때문이다.



> 문자열을 복사하는 함수들: strcpy, strncpy

이번에는 문자열의 복사에 사용되는 함수 둘을 소개하겠다.

```c
#include <string.h>

char * strcpy(char * dest, const char * src);
char * strncpy(char * dest, const char * src, size_t n);
/*
복사된 문자열의 주소 값 반환
*/
```

위의 strcpy 함수를 호출하는 형태는 다음과 같다.

```c
int main(void)
{
	char str1[30] = "Simple String";
    char str2[30];
    strcpy(str2, str1);		// str1의 문자열을 str2에 복사
    ....
}
```

위의 코드가 실행되면 str2에는 str1이 저장하고 있는 문자열이 복사된다.  
다만 문자열이 복사될 배열의 길이가 문자열의 길이보다 작지 않도록 주의해야 한다.  
그럼 이제 strncpy 함수의 호출형태를 살펴 보자.

```c
int main(void)
{
    char str1[30] = "Simple String";
    char str2[30];
    strncpy(str2, str1, sizeof(str2));
    ....
}
```

위 코드의 strncpy 함수 호출문이 의미하는 바는 다음과 같다.

__str1에 저장된 문자열을 str2에 복사하되, str1의 길이가 매우 길다면, sizeof(str2)가 반환한 값에 해당하는 문자의 수 만큼만 복사를 진행해라__

이렇듯 strncpy 함수는 복사될 배열의 길이를 넘어서지 않는 범위 내에서 복사를 진행하고자 하는 경우에 유용하다.  
하지만 이 역시 주의해야 할 사실이 하나 있는데, 예제를 통해 살펴 보자.



StringCopyCase.c

```c
#include <stdio.h>
#include <string.h>

int main(void)
{
	char str1[20] = "1234567890";
    char str2[20];
    char str3[5];
    
    /**** case 1 ****/
    strcpy(str2, str1);
    puts(str2);
    /**** case 2 ****/
    strncpy(str3, str1, sizeof(str3));
    puts(str3);
    /**** case 3 ****/
    strncpy(str3, str1, sizeof(str3)-1);
    str3[sizeof(str3)-1] = 0;
    puts(str3);
    return 0;
}
```



실행 결과

```
1234567890
12345惙惙惙惙惙惙?234567890
1234
```



위의 예제 15행에는 다음 문장이 삽입되어 있다.

```c
strncpy(str3, str1, sizeof(str3));
```

그리고 이 문장을 보면서 복사하려는 최대 문자의 수로 sizeof(str3)의 반환 값이 전달되었으니, 할당된 배열을 넘어서 복사가 이뤄지지 않는다고 생각할 수도 있다.  
실제로 배열을 넘어서 복사가 이뤄지지 않으니 이것이 잘못된 판단은 아니다. 즉, 배열 str3의 길이가 5이니 총 5개의 문자가 복사된다.  
단! 이 5개의 문자 안에 __널 문자가 포함되지 않는다는 문제__가 있다. strncpy 함수는 문자열을 단순하게 복사한다. 마지막 문자가 널 문자인지 아닌지는 상관하지 않는다.  
따라서 위의 문장 실행 후 str3에 저장되는 다섯 개의 문자는 다음과 같다.

```
1, 2, 3, 4, 5
```

그래서 16행의 출력결과가 이상한 것이다. 널 문자가 존재해야 널 문자 이전까지 출력을 할 텐데, 널 문자가 존재하지 않으니 엉뚱한 영역까지 출력을 하는것이다.  
그럼 strncpy 함수는 어떻게 호출해야 할까? 위 예제 19, 20행에서 보이듯이 다음과 같이 호출해야 한다.

```c
strncpy(str3, str1, sizeof(str3)-1);
str3[sizeof(str3)-1] = 0;
```

strncpy 함수의 세 번재 인자로 배열의 실제길이보다 하나 작은 값을 전달해서 널 문자가 삽입될 공간을 남겨두고 복사를 진행해야 한다. 그리고 이어서 배열의 끝에 널 문자를 삽입해야 한다.



> 문자열을 덧붙이는 함수들: strcat, strncat

이번에 소개하는 두 함수는 문자열의 뒤에 다른 문자열을 복사하는 기능을 제공한다.

```
#include <string.h>

char * strcat(char * dest, const char * src);
char * strncat(char * dest, const char * src, size_t n);
/*
덧붙여진 문자열의 주소 값 반환
*/
```



strcat 함수를 호출하는 형태는 다음과 같다.

```c
int main(void)
{
	char str1[30]="First~";
	char str2[30]="Second";
	strcat(str1, str2);		//str1의 문자열 뒤에 str2를 복사
	....
}
```

위의 형태로 strcat 함수가 호출되면 str2의 문자열이 str1의 문자열 뒤에 덧붙여지는데, 덧붙임이 시작되는 위치는 널 문자 다음이 아닌, 널 문자가 저장된 위치에서부터이다.  
이렇듯 널 문자가 저장된 위치에서부터 복사가 진행되어야 덧붙임 이후에도 문자열의 끝에 하나의 널 문자만 존재하는 정상적인 문자열이 된다.  
이어서 다음 문장을 보자. 이는 strncat 함수의 호출문이다.

```c
strncat(str1, str2, 8);
```

이 문장이 의미하는 바는 다음과 같다.

__str2의 문자열중 최대 8개를 str1의 뒤에 덧붙여라__

즉 str2의 길이가 8을 넘어선다면 8개의 문자까지만 str1에 덧붙이라는 의미인데, 이 8개의 문자에는 널 문자가 포함되지 않는다는 사실에 주목하자. 따라서 실제로는 총 9개의 문자가 str1에 덧붙여진다.  
이렇듯 strncpy 함수와 달리 strncat 함수는 문자열의 끝에 널 문자를 자동으로 삽입해준다.  
지금까지 내용을 확인하는 예제를 살펴보자.



StringConcatCase.c

```c
#include <stdio.h>
#include <string.h>

int main(void)
{
	char str1[20] = "First~";
    char str2[20] = "Second";
    
    char str3[20] = "Simple num: ";
    char str4[20] = "1234567890";
    
    /**** case 1 ****/
    strcat(str1, str2);
    puts(str1);
    
    /**** case 2 ****/
    strncat(str3, str4, 7)
    puts(str3);
    return 0;
}
```



실행 결과

```
First~Second
Simple num: 1234567
```



> 문자열을 비교하는 함수들: strcmp, strncmp

