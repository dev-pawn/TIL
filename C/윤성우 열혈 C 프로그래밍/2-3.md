# Chapter 13 포인터와 배열! 함께 이해하기



## 목차

- [포인터와 배열의 관계](#포인터와-배열의-관계)
- [포인터 연산](#포인터-연산)
- 상수 형태의 문자열을 가리키는 포인터
- 포인터 변수로 이뤄진 배열: 포인터 배열



## 포인터와 배열의 관계

> 배열의 이름은 무엇을 의미하는가?

__배열의 이름은 포인터이다.__ 단 값을 바꿀수 없는 __상수 형태의 포인터__이다.  
아래 예제를 통해 증명해보자.



ArrayNameType.c

```c
#include <stdio.h>

int	main(void)
{
    int	arr[3] {0, 1, 2};
    printf("배열의 이름: %p \n", arr);
    printf("첫 번째 요소: %p \n", &arr[0]);
    printf("두 번째 요소: %p \n", &arr[1]);
    printf("세 번째 요소: %p \n", &arr[2]);
    //	arr = & arr[i];	//이 문장은 컴파일 에러를 일으킨다.
}
```



실행 결과

```
배열의 이름: 0012FF50
첫 번째 요소: 0012FF50
두 번째 요소: 0012FF54
세 번째 요소: 0012FF58
```

위 예제를 통해 우리는 int형 배열요소간의 주소 값의 차는 4바이트라는 사실을 알 수 있다.  
그리고 배열의 첫 번째 바이트의 주소 값이 0x0012FF50인데, 배열의 이름을 출력한 결과도 이와 같다는 사실을 알 수 있다.  
또한 arr = & arr[i]; 를 통해 배열의 이름은 대입 연산자의 피연산자가 될 수 없으므로(값을 저장할 수 없으므로) 다음의 결론을 내릴 수 있다.

__배열의 이름은 배열의 시작 주소 값을 의미하며, 그 형태는 값의 저장이 불가능한 상수이다.__

그렇다면 포인터 변수와 배열의 이름을 비교해보자.

|                               | 포인터 변수      | 배열의이름       |
| ----------------------------- | ---------------- | ---------------- |
| 이름이 존재하는가?            | 존재             | 존재             |
| 무엇을 나타내거나 저장하는가? | 메모리의 주소 값 | 메모리의 주소 값 |
| 주소 값의 변경이 가능한가?    | 가능             | 불가능           |

위의 표에서 알 수 있듯이 포인터 변수는 그 이름이 의미하듯이 변수이지만, 배열의 이름은 가리키는 대상의 변경이 불가능한 상수라는 점에서만 차이를 보인다.  
즉 배열의 이름은 __상수 형태의 포인터__이다. 그래서 배열의 이름을 가리켜 __포인터 상수__라고 부르기도 한다.  
__배열의 이름도 포인터이기 때문에 배열의 이름을 피연산자로 하는 *연산이 가능하다.__



> 1차원 배열이름의 포인터 형과 배열이름을 대상으로 하는 *연산

다음과 같이 배열이 선언되었을 때,

```c
int arr1[5];
```

배열의 이름 arr1이 가리키는 것은 배열의 첫 번째 요소이다. 그런데 배열의 첫 번째 요소가 int형 변수이니, arr1은 __int형 포인터(int *)__라는 것을 알 수 있다.

```c
double arr2[7];
```

배열이름 arr2가 가리키는 것은 첫 번째 배열요소인 double형 변수이므로 arr2는 __double형 포인터(double *)__가 된다.

__1차원 배열이름의 포인터 형은 배열의 이름이 가리키는 대상을 기준으로 결정__된다.

이제 1차원 배열이름의 포인터 형을 결정할 수 있게 되었으니, 이를 대상으로 *연산을 해 보자.



ArrayNamePointerOperation.c

```c
#include <stdio.h>

int	main(void)
{
    int arr1[3] = {1, 2, 3};
    double arr2[3] = {1.1, 2.2, 3.3};
    
    printf("%d %g \n", *arr1, *arr2);
    *arr1 += 100;
    *arr2 += 120.5;
    printf("%d %d \n", arr1[0], arr2[0]);
    return 0;
}
```



실행 결과

```
1 1.1
101 121.6
```

위 예제를 통해서 배열의 이름도 포인터라는 사실을 충분히 이해할 수 있다.



```c
int	main(void)
{
	int arr[3] = {1, 2, 3};
	arr[0] += 5;
	arr[1] += 7;
	arr[2] += 9;	// 포인터를 대상으로 이 문장을 구성한 셈이다.
	....
}
```

위의 코드에서 배열이름 arr은 int형 포인터이니, 포인터를 대상으로 배열의 모든 요소를 arr[0], arr[1], arr[2]로 접근한 셈이다.  
그렇다면 포인터 변수를 대상으로도 이러한 형태의 접근이 가능해야 하지 않을까? 배열의 이름이나 포인터 변수나 둘 다 포인터이니 말이다.  
실제로 포인터 변수는 배열의 이름처럼 사용할 수 있다.  
즉, 포인터 변수 ptr을 대상으로 ptr[0], ptr[1], ptr[2]와 같이 배열의 형태로 메모리 공간에 접근이 가능하다.



> 포인터를 배열의 이름처럼 사용할 수도 있다.

사실 배열의 이름과 포인터 변수는 변수냐 상수냐의 특성적 차이가 있을 뿐, 둘 다 포인터이기 때문에 포인터이기 때문에 포인터 변수로 할 수 있는 연산은 배열의 이름으로도 할 수 있고, 배열의 이름으로 할 수 있는 연산은 포인터 변수로도 할 수 있다.



ArrayNameIsPointer.c

```c
#include <stdio.h>

int	main(void)
{
    int	arr[3] = {15, 25, 35};
    int *ptr = &arr[0];		//int *ptr = arr; 와 동일한 문장
    
    printf("%d %d \n"), ptr[0], arr[0]);
    printf("%d %d \n"), ptr[1], arr[1]);
    printf("%d %d \n"), ptr[2], arr[2]);
    printf("%d %d \n"), *ptr, *arr);
    return 0;
}
```



실행 결과

```
15 15
25 25
35 35
15 15
```

참고로 위 예제에서 보이는 것처럼 포인터 변수를 배열의 이름처럼 사용하는 경우는 거의 없다.  
마찬가지로 배열의 이름을 포인터 변수처럼 사용하는 경우도 거의 없다.  
하지만 이러한 일이 가능하다는 사실은 알고 있어야 한다.



## 포인터 연산

> 포인터를 대상으로 하는 증가 및 감소연산

포인터 변수를 대상으로 다음과 같이 다양한 형태의 증가 및 감소연산을 진행할 수 있다.

```c
int	main(void)
{
	int *ptr1 = ...;		// 포인터 변수 ptr1이 적절히 초기화 되었다고 가정!
    int *ptr2 = ...;		// 포인터 변수 ptr2이 적절히 초기화 되었다고 가정!
    ptr1++;
    ptr1 += 3;
    ptr2 -= 5;
    ptr2 = ptr1 + 2;
    ...
}
```



위 연산의 결과를 알아보기 위해 아래 예제를 확인해보자.

PointerOperationResult.c

```
#include <stdio.h>

int	main(void)
{
	int *ptr1 = 0x0010;
	double *ptr2= 0x0010;
	
	printf("%p %p \n", ptr1+1, ptr1+2);			// 4가 증가하고 8이 증가한다.
	printf("%p %p \n", ptr2+1, ptr2+2);			// 8이 증가하고 16이 증가한다.
	
	printf("%p %p \n", ptr1, ptr2);
	ptr1++;			// 4가 증가한다.
	ptr2++;			// 8이 증가한다.
	printf("%p %p \n", ptr1, ptr2);
	return 0;
}
```



실행 결과

```
00000014 00000018
00000018 00000020
00000010 00000010
00000014 00000018
```



사실 위 예제의 ptr1 과 ptr2는 적절한 초기화가 아니다. 그러나 이 예제에서는 증가연산의 결과 확인을 위해서 부적절한 초기화를 진행하였다.

위의 예제를 통해 알 수 있는 사실은

int형 포인터를 대상으로 1을 증가시키면 4가 증가하고, double형 포인터를 대상으로 1을 증가시키면 8이 증가한다.

즉, 포인터를 대상으로 하는 증가연산의 결과는 다음과 같다.

- int형 포인터를 대상으로 n 증가			n x sizeof(int) 의 크기만큼 증가
- double형 포인터를 대상으로 n 증가    n x sizeof(double) 의 크기만큼 증가

또한 감소연산도 이와 동일하게 감소할 것을 알 수 있다.

위의 내용을 일반화 시키면 다음과 같은 결론을 얻을 수 있다.

__TYPE형 포인터를 대상으로 n의 크기만큼 증가 및 감소 시, n * sizeof(TYPE)의 크기만큼 주소 값이 증가 및 감소한다.__

이러한 포인터의 연산특성으로 인해 아래 예제의 형태처럼 배열 접근이 가능하다.



PointerBaseArrayAccess.c

```c
#include <stdio.h>

int	main(void)
{
    int arr[3] = {11, 22, 33};
    int * ptr = arr;		// int * ptr = &arr[0]; 과 같은 문장
    printf("%d %d %d \n", *ptr, *(ptr+1), *(ptr+2));
    
    printf("%d ", *ptr); ptr++;		//printf 함수호출 후, ptr++ 실행
    printf("%d ", *ptr); ptr++;
    printf("%d ", *ptr); ptr--;		//printf 함수호출 후, ptr-- 실행
    printf("%d ", *ptr); ptr--;
    printf("%d ", *ptr); printf("\n");
    return 0;
}
```



실행 결과

```
11 22 33
11 22 33 22 11
```



위 예제에서 선언된 포인터 변수 ptr은 int형 포인터이므로 값을 1 증가시키는 연산을 할 때마다 실제로는 4가 증가한다.  
따라서 배열 arr이 할당된 위치의 주소 값을 0x001000 이라 가정할 때, (ptr+1) 과 (ptr+2)의 연산결과로 반환되는 주소 값이 가리키는 위치는 다음과 같다.  
ptr+1 = 0x001004  
ptr+2 = 0x001008

따라서 *ptr, *(ptr+1), *(ptr+2)의 참조결과 출력 시 arr[0], arr[1], arr[2]에 저장된 요소가 출력된 것이다.

이어서 포인터 변수 ptr에 저장된 값을 증가 및 감소시키는 연산을 수행하고 있다.  
이 결과로 포인터 변수 ptr에 저장된 값은 4씩 증가 및 감소가 이뤄지기 때문에 포인터 변수 ptr이 가리키는 위치는 다음과 같이 변경된다.  

ptr = 0x001000  
ptr++ = 0x001004  
ptr++ = 0x001008  
ptr-- = 0x001004  
ptr-- = 0x001000

그렇다면 아래 두 연산의 차이점은 무엇일까?

```c
*(++ptr)=20;		// ptr에 저장된 값 자체를 변경
*(ptr+1)=20;		// ptr에 저장된 값은 변하지 않음
```

위의 두 문장 모두 현재 ptr이 가리키는 위치에서 4바이트 떨어진 메모리 공간에 20을 저장하는 문장이다.  
하지만 연산 이후 포인터 변수 ptr의 상태에는 차이가 있다.  
첫 번째 문장의 경우 ++ 연산의 결과로 인해서 포인터 변수 ptr에 저장된 값이 4만큼 증가한다.  
두 번째 문장의 경우 + 연산으로 인해서는 ptr에 저장된 값이 증가하지 않는다. 다만 증가된 값을 연산의 결과로 얻어서 * 연산을 진행할 뿐이다.



> 중요한 결론! arr[i] == *(arr+i)

앞에서 보인 예제의 코드 일부는 다음과 같다.

```c
int main(void)
{
	int arr[3] = {11, 22, 33};
	int *ptr = arr;
	printf("%d %d %d \n", *ptr, *(ptr+1), *(ptr1+2));
	....
}
```

그리고 *ptr, *(ptr+1), *(ptr+2)의 출력결과는 arr[0], arr[1], arr[2]의 출력결과와 동일함을 이미 확인하였다.  
그리고 배열의 이름과 포인터 변수는 상수냐 변수냐의 차이만 있을 뿐이다.  
따라서 ptr에 저장된 값이 arr의 주소 값이기 때문에 다음 네 문장은 사실상 같은 것이고 동일한 출력결과를 보인다.

```c
printf("%d %d %d \n", *(ptr+0), *(ptr+1), *(ptr+2));	//*(ptr+0)는 *ptr과 같다.
printf("%d %d %d \n", ptr[0], ptr[1], ptr[2]);
printf("%d %d %d \n", *(arr+0), *(arr+1), *(arr+2));	//*(arr+0)은 *arr와 같다.
printf("%d %d %d \n", arr[0], arr[1], arr[2]);
```

따라서 아래와 같은 식을 도출할 수 있다.

__arr[i] == *(arr+i)__	//arr[i]는 *(arr+i)와 같다.

