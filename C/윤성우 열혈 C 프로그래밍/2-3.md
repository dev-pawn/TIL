# Chapter 13 포인터와 배열! 함께 이해하기



## 목차

- [포인터와 배열의 관계](#포인터와-배열의-관계)
- [포인터 연산](#포인터-연산)
- 상수 형태의 문자열을 가리키는 포인터
- 포인터 변수로 이뤄진 배열: 포인터 배열



## 포인터와 배열의 관계

> 배열의 이름은 무엇을 의미하는가?

__배열의 이름은 포인터이다.__ 단 값을 바꿀수 없는 __상수 형태의 포인터__이다.  
아래 예제를 통해 증명해보자.



ArrayNameType.c

```c
#include <stdio.h>

int	main(void)
{
    int	arr[3] {0, 1, 2};
    printf("배열의 이름: %p \n", arr);
    printf("첫 번째 요소: %p \n", &arr[0]);
    printf("두 번째 요소: %p \n", &arr[1]);
    printf("세 번째 요소: %p \n", &arr[2]);
    //	arr = & arr[i];	//이 문장은 컴파일 에러를 일으킨다.
}
```



실행 결과

```
배열의 이름: 0012FF50
첫 번째 요소: 0012FF50
두 번째 요소: 0012FF54
세 번째 요소: 0012FF58
```

위 예제를 통해 우리는 int형 배열요소간의 주소 값의 차는 4바이트라는 사실을 알 수 있다.  
그리고 배열의 첫 번째 바이트의 주소 값이 0x0012FF50인데, 배열의 이름을 출력한 결과도 이와 같다는 사실을 알 수 있다.  
또한 arr = & arr[i]; 를 통해 배열의 이름은 대입 연산자의 피연산자가 될 수 없으므로(값을 저장할 수 없으므로) 다음의 결론을 내릴 수 있다.

__배열의 이름은 배열의 시작 주소 값을 의미하며, 그 형태는 값의 저장이 불가능한 상수이다.__

그렇다면 포인터 변수와 배열의 이름을 비교해보자.

|                               | 포인터 변수      | 배열의이름       |
| ----------------------------- | ---------------- | ---------------- |
| 이름이 존재하는가?            | 존재             | 존재             |
| 무엇을 나타내거나 저장하는가? | 메모리의 주소 값 | 메모리의 주소 값 |
| 주소 값의 변경이 가능한가?    | 가능             | 불가능           |

위의 표에서 알 수 있듯이 포인터 변수는 그 이름이 의미하듯이 변수이지만, 배열의 이름은 가리키는 대상의 변경이 불가능한 상수라는 점에서만 차이를 보인다.  
즉 배열의 이름은 __상수 형태의 포인터__이다. 그래서 배열의 이름을 가리켜 __포인터 상수__라고 부르기도 한다.  
__배열의 이름도 포인터이기 때문에 배열의 이름을 피연산자로 하는 *연산이 가능하다.__



> 1차원 배열이름의 포인터 형과 배열이름을 대상으로 하는 *연산

다음과 같이 배열이 선언되었을 때,

```c
int arr1[5];
```

배열의 이름 arr1이 가리키는 것은 배열의 첫 번째 요소이다. 그런데 배열의 첫 번째 요소가 int형 변수이니, arr1은 __int형 포인터(int *)__라는 것을 알 수 있다.

```c
double arr2[7];
```

배열이름 arr2가 가리키는 것은 첫 번째 배열요소인 double형 변수이므로 arr2는 __double형 포인터(double *)__가 된다.

__1차원 배열이름의 포인터 형은 배열의 이름이 가리키는 대상을 기준으로 결정__된다.

이제 1차원 배열이름의 포인터 형을 결정할 수 있게 되었으니, 이를 대상으로 *연산을 해 보자.



ArrayNamePointerOperation.c

```c
#include <stdio.h>

int	main(void)
{
    int arr1[3] = {1, 2, 3};
    double arr2[3] = {1.1, 2.2, 3.3};
    
    printf("%d %g \n", *arr1, *arr2);
    *arr1 += 100;
    *arr2 += 120.5;
    printf("%d %d \n", arr1[0], arr2[0]);
    return 0;
}
```



실행 결과

```
1 1.1
101 121.6
```

위 예제를 통해서 배열의 이름도 포인터라는 사실을 충분히 이해할 수 있다.



```c
int	main(void)
{
	int arr[3] = {1, 2, 3};
	arr[0] += 5;
	arr[1] += 7;
	arr[2] += 9;	// 포인터를 대상으로 이 문장을 구성한 셈이다.
	....
}
```

위의 코드에서 배열이름 arr은 int형 포인터이니, 포인터를 대상으로 배열의 모든 요소를 arr[0], arr[1], arr[2]로 접근한 셈이다.  
그렇다면 포인터 변수를 대상으로도 이러한 형태의 접근이 가능해야 하지 않을까? 배열의 이름이나 포인터 변수나 둘 다 포인터이니 말이다.  
실제로 포인터 변수는 배열의 이름처럼 사용할 수 있다.  
즉, 포인터 변수 ptr을 대상으로 ptr[0], ptr[1], ptr[2]와 같이 배열의 형태로 메모리 공간에 접근이 가능하다.



> 포인터를 배열의 이름처럼 사용할 수도 있다.

사실 배열의 이름과 포인터 변수는 변수냐 상수냐의 특성적 차이가 있을 뿐, 둘 다 포인터이기 때문에 포인터이기 때문에 포인터 변수로 할 수 있는 연산은 배열의 이름으로도 할 수 있고, 배열의 이름으로 할 수 있는 연산은 포인터 변수로도 할 수 있다.



ArrayNameIsPointer.c

```c
#include <stdio.h>

int	main(void)
{
    int	arr[3] = {15, 25, 35};
    int *ptr = &arr[0];		//int *ptr = arr; 와 동일한 문장
    
    printf("%d %d \n"), ptr[0], arr[0]);
    printf("%d %d \n"), ptr[1], arr[1]);
    printf("%d %d \n"), ptr[2], arr[2]);
    printf("%d %d \n"), *ptr, *arr);
    return 0;
}
```



실행 결과

```
15 15
25 25
35 35
15 15
```

참고로 위 예제에서 보이는 것처럼 포인터 변수를 배열의 이름처럼 사용하는 경우는 거의 없다.  
마찬가지로 배열의 이름을 포인터 변수처럼 사용하는 경우도 거의 없다.  
하지만 이러한 일이 가능하다는 사실은 알고 있어야 한다.



## 포인터 연산

